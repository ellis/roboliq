# Design Tables

In Roboliq terminology, a *Design Table* is a table that specifies all relevant
factors for later analyzing the experimental results.

Experiments on microwell plates can easily involve hundreds of unique
liquid combinations, so specifying them manually can be tedious and error-prone.
Here we present a short-hand for creating design tables.

WARNING: This is very abstract.  Don't bother with it if you're looking for something
easy.  That said, it makes complex experiments much, much easier to design,
trouble-shoot, and analyze.

NOTE: this document uses the following terms interchangeably: column, factor, variable.

## First examples

Let's create a design table with a single row like this:

plate | source | destination | volume
----- | ------ | ----------- | -----:
plate1 | water | A01 | 25 ul

This table could be used to specify a single pipetting operation that dispenses 25 ul of water into well `A01` of `plate1`.

Here is how to specify this in Roboliq:

```yaml
roboliq: v1
objects:
  design1:
    type: Design
    description: First example
    conditions:
      plate: plate1
      source: water
      destination: A01
      volume: 25 ul
---
```

Within a Roboliq protocol, the design would be place in the `objects` property.  Its object name is `design1`, its type is `Design`, and it has a description.
The `conditions` property is where factors are specified.




Let's expand the design table a bit to dispenses 25 ul of water into several destinations.

plate | source | destination | volume
----- | ------ | ----------- | -----:
plate1 | water | A01 | 25 ul
plate1 | water | B01 | 25 ul
plate1 | water | C01 | 25 ul

To specify this in Roboliq, we change the `destination` property to a *branching* factor:

```yaml
roboliq: v1
objects:
  design1:
    type: Design
    description: First example
    conditions:
      plate: plate1
      source: water
      destination*: [A01, B01, C01]
      volume: 25 ul
---
```

Notice the asterisk in `destination*`.  An asterisk at the end of a factor name indicates *branching*.  Branching factors require an array of values, and for each value in the array, the existing rows are first replicated and then the value is assigned to the factor in that row.



Now let's assign a different volume to each row:

plate | source | destination | volume
----- | ------ | ----------- | -----:
plate1 | water | A01 | 25 ul
plate1 | water | B01 | 50 ul
plate1 | water | C01 | 75 ul

To specify this in Roboliq, we change the `volume` property to an array:

```yaml
roboliq: v1
objects:
  design1:
    type: Design
    description: First example
    conditions:
      plate: plate1
      source: water
      destination*: [A01, B01, C01]
      volume: [25 ul, 50 ul, 75 ul]
---
```

When a factor value is an array, a new column is added with those values.

**Try it**. Copy the above code to a new file in Roboliq's root directory named `design1Test.yaml`.  Open a terminal and change directory to the Roboliq root, and run the following command:

```sh
npm run design -- --path objects.design1 design1Test.yaml
```

It should produce this output:

```
plate   source  destination  volume
======  ======  ===========  ======
plate1  water   A01          25 ul
plate1  water   B01          50 ul
plate1  water   C01          75 ul
======  ======  ===========  ======
```


Branches can also be specified as integers and arrays.
If you specify an integer, it creates that many branches which are each
given an integer index, as follows:

```yaml
roboliq: v1
objects:
  designInteger:
    type: Design
    conditions:
      a*: 3
      b*: 3
```

Which creates the following table:

a | b
- | -
1|1
1|2
1|3
2|1
2|2
2|3
3|1
3|2
3|3

TODO: show use of array of objects in branching.


## Nested branching

Nested branching provides a lot of power to the design specification, but it
is also where the complexity starts.  Consider this table where two sources
are nested in each destination, and each source has its own volume:

plate | destination | source | volume | liquidClass
----- | ------ | ----------- | -----: | -------
plate1 | A01 | water | 50 ul | Roboliq_Water_Air_1000
plate1 | A01 | dye | 25 ul | Roboliq_Water_Air_1000
plate1 | B01 | water | 50 ul | Roboliq_Water_Air_1000
plate1 | B01 | dye | 25 ul | Roboliq_Water_Air_1000
plate1 | C01 | water | 50 ul | Roboliq_Water_Air_1000
plate1 | C01 | dye | 25 ul | Roboliq_Water_Air_1000

This can be described in Roboliq as follows:

```yaml
roboliq: v1
objects:
  design2:
    type: Design
    description: Nested example
    conditions:
      plate: plate1
      destination*: [A01, B01, C01]
      source*:
        water:
          volume: 50 ul
        dye:
          volume: 25 ul
      liquidClass: Roboliq_Water_Air_1000
---
```

An alternative way of achieving the same result is:

```yaml
roboliq: v1
objects:
  design2:
    type: Design
    description: Nested example
    conditions:
      plate: plate1
      destination*: [A01, B01, C01]
      .sourceId*:
      - source: water
        volume: 50 ul
      - source: dye
        volume: 25 ul
      liquidClass: Roboliq_Water_Air_1000
---
```

Create a file named `design2Test.yaml` with those contents and run:

```sh
npm run design -- --path objects.design2 design2Test.yaml
```

What's happening here is:

1. `plate = plate1` is assign to the first table row.
2. three copies of the previous row are created, and a column for `destination` is added to each row, each with its own value.
3. Two copies are made of each of the previous three rows.
    a. For the first copy of each of the three original rows:
        1. `source = water`
        2. Then the conditions embedded under `water:` are applied to those rows -- in this case, `volume = 50 ul`
    b. For the second copy of each of the three original rows:
        1. `source = water`
        2. Then the conditions embedded under `water:` are applied to those rows -- in this case, `volume = 25 ul`
4. `liquidClass = Roboliq_Water_Air_1000` is assigned to all rows.


## Advanced assignment #1

```yaml
"a*": [1, 2, 3, 4]
"b=":
  values: [1, 2]
  order: "reverse"
```

```yaml
a*: 2
b*: 2
```

Step 0:

{}

Step 1':
{a: 1}

Step 1:
[{a: 1}, {a: 2}, {a: 3}, {a: 4}]

Step 2:
[{a: 1, b: 1}, {a: 2, b: 2}, {a: 3, b: 2}, {a: 4, b: 1}]

---

```yaml
a*: 2
b*: 2
c=:
  values: [A, B]
  groupBy: b
```

a1 b1
a1 b2
a2 b1
a2 b2

a1 b1 cA
a2 b1 cB
--
a1 b2 cA
a2 b2 cB

a1 b1 cA
a1 b2 cA
a2 b1 cB
a2 b2 cB

```yaml
a*: [{x: 1}, {y: 2}, {z: 3}]
a*:
  - x: q
  - y: 2
  - z: 3
```

a1 xq
a2    y2
a3       z3

```yaml
a*:
  - {}
  - y: 2
  - {}
```

a1
a2 y2
a3

```yaml
steps:
  data: {source: design1}
  1:
    command: pipetter.pipette
    source: $whereItsFrom
```

## Actions

* allocateWells
* range
* calculate
* case

```{yaml}
replicate*: 2
well=allocateWells:
  rows: 8
  columns: 12
  order: shuffle
```

```{yaml}
{replicate: 1, well: E05}
{replicate: 2, well: H01}
```

```{yaml}
a*: 2
b*: 2
c=range: {from: 10, step: 10}
```

a1 b1 c10
a1 b2 c20
a2 b1 c30
a2 b2 c40

```{yaml}
a*: 3
volume=calculate: '(a * 10) ul'
more=calculate: '(50 ul) - volume'
```

```
a1 volume:10ul more:40ul
a2 volume:20ul more:30ul
a3 volume:30ul more:20ul
```

```{yaml}
a*: [10 ul, 20 ul]
volume=calculate:
  value: '(a * 10) ul'
  units: l
```

```{yaml}
a*: 3
.volumeCase=case:
  - where: a < 2
    conditions:
      volume: 10ul
  - conditions:
      volume: 12354 ul
```

```
a1 volumeCase1 volume10
a2 volumeCase2 volume12354
a3 volumeCase2 volume12354
```

## Order values

* `shuffle`
* `reshuffle`
* `reverse`
* `repeat`


## Advanced assignment

More complex assignments are possible that allow for randomizing and changing
the order of assignment.

```yaml
```
					"a*": [1, 2, 3, 4],
					"b=": {
						values: [1, 2],
						order: "repeat"
					}

a | b | c
1 | 1 |
1 | 2 |
1 | 3 |
2 | 1 |
2 | 2 |
3 | 3 |



TODO:

* [ ] Functions
* [ ] Hiding factors with `.` prefix
* [ ] `orderBy` at end

## Step-by-step

```
flattenArrayAndIndexes:

[{}] ; [0]

a*: 2
[{}] ; [0] =>
	[{}, {}] ; [0,1] => [{a: 1}, {a: 2}] ; [0,1]
[[{a: 1}, {a: 2}]] ; [0]
[{a: 1}, {a: 2}] ; [0,1]

b*: 2
[{a: 1}, {a: 2}] ; [0,1] =>
	[{a: 1}, {a: 1}] ; [0,1] => [{a: 1, b: 1}, {a: 1, b: 2}] ; [0,1]
	[{a: 2}, {a: 2}] ; [0,1] => [{a: 2, b: 1}, {a: 2, b: 2}] ; [0,1]
[[{a: 1, b: 1}, {a: 1, b: 2}], [{a: 2, b: 1}, {a: 2, b: 2}]] ; [0,1]
[{a: 1, b: 1}, {a: 1, b: 2}, {a: 2, b: 1}, {a: 2, b: 2}] ; [0,1,2,3]
```

## TODOs:

* consider GraphQL
* consider https://facebook.github.io/relay/

## `data` directive

You can load one design per step, but you can nest steps and load another design in the sub-step.

Consider these two designs:

design1:
  conditions:
    a: Alice
    b: *3
    c: Charles
    d: Daniel

design2:
  conditions:
    d: David

And these steps:

1:
  data: {source: design1}
  description: "`{{$a}} {{$c}} {{$d}}`"
  1:
    data: {source: design2}
    description: "`{{$a}} {{$c}} {{$d}}`"

The descriptions should be:

1.description: "Alice Charles Daniel"
1.1.description: "Alice Charles David"

In 1.1, "\$\$b" does not exist, but "\$a" and "\$c" still do.  That is to say: column data from a previous `data` directive are not carried into sub-steps with a new `data` directive, but the values that were the same for all columns remain in scope.
