<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"commands_evoware.js.html":{"id":"commands_evoware.js.html","title":"Source: commands/evoware.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: commands/evoware.js /** * Handles instructions which are specifically for controlling evoware. * @module */ import _ from 'lodash'; import commandHelper from 'roboliq-processor/dist/commandHelper.js'; import * as evowareHelper from './evowareHelper.js'; export function _execute(params, parsed, data) { const line = evowareHelper.createExecuteLine(parsed.orig.path, parsed.orig.args, parsed.orig.wait); return [{line}]; } export function _facts(params, parsed, data) { const line = evowareHelper.createFactsLine(parsed.orig.factsEquipment, parsed.orig.factsVariable, parsed.orig.factsValue); if (params.labware) { const values = commandHelper.lookupPaths({ plateModelName: [[&quot;@labware&quot;, &quot;model&quot;], &quot;evowareName&quot;], plateOrigName: [&quot;@labware&quot;, &quot;location&quot;], plateOrigCarrierName: [[&quot;@labware&quot;, &quot;location&quot;], &quot;evowareCarrier&quot;], plateOrigGrid: [[&quot;@labware&quot;, &quot;location&quot;], &quot;evowareGrid&quot;], plateOrigSite: [[&quot;@labware&quot;, &quot;location&quot;], &quot;evowareSite&quot;] }, params, data); const tableEffects = [ [[values.plateOrigCarrierName, values.plateOrigGrid, values.plateOrigSite], {label: _.last(values.plateOrigName.split('.')), labwareModelName: values.plateModelName}], ]; return [{line, tableEffects}]; } else { return [{line}]; } } export function _raw(params, parsed, data) { return _(parsed.value.commands).split(&quot;;&quot;).map(_.trim).compact().map(s =&gt; ({line: s+&quot;;&quot;})).value(); } export function _subroutine(params, parsed, data) { const line = `Subroutine(&quot;${params.filename}&quot;,0);`; return [{line}]; } export function _userPrompt(params, parsed, data) { const line = evowareHelper.createUserPromptLine(parsed.orig.text, parsed.orig.beep, parsed.orig.autoclose); return [{line}]; } export function _variable(params, parsed, data) { const line = evowareHelper.createVariableLine(parsed.orig.name, parsed.orig.value); return [{line}]; } × Search results Close "},"commands_evowareHelper.js.html":{"id":"commands_evowareHelper.js.html","title":"Source: commands/evowareHelper.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: commands/evowareHelper.js /** * Helper functions for evoware command handlers. * @module */ import _ from 'lodash'; import assert from 'assert'; /** * Create the Evoware token to execute an external command. * @param {string} path - path to command to execute * @param {array} args - array of arguments to pass * @param {boolean} wait - true if evoware should wait for the command to complete execution * @param {string} exitCodeVariableName - optional name of * @return {string} a string representing an Evoware 'Execute' token. */ export function createExecuteLine(path, args, wait, exitCodeVariableName = &quot;&quot;) { const flag1 = ((wait) ? 2 : 0) + (_.isEmpty(exitCodeVariableName) ? 0 : 4); return `Execute(&quot;${path} ${args.join(&quot; &quot;)}&quot;,${flag1},&quot;${exitCodeVariableName}&quot;,2);`; } /** * Create an Evoware FACTS token. * @param {string} equipment - equipment ID for the FACTS command * @param {string} variableName - variable name for the FACTS command * @param {string} value - optional value of the variable * @return {string} a string representing an Evoware 'FACTS' token. */ export function createFactsLine(equipment, variableName, value = &quot;&quot;) { const l = [ `&quot;${equipment}&quot;`, `&quot;${variableName}&quot;`, `&quot;${value}&quot;`, `&quot;0&quot;`, `&quot;&quot;` ]; return `FACTS(${l.join(&quot;,&quot;)});`; } /** * Create an 'If' token. * @param {string} variable - name of the variable to test * @param {string} test - one of &quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; * @param {string|number} value - value to compare to * @param {string} target - target to jump to: an Evoware &quot;Comment&quot; token * @return {string} - line for an &quot;If&quot; token */ export function createIfLine(variable, test, value, target) { const cmps = [&quot;==&quot;, &quot;!-&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;]; const cmp = cmps.indexOf(test); assert(cmp &gt;= 0, `Unknown test: ${test}`); return `If(&quot;${variable}&quot;,${cmp},&quot;${value}&quot;,&quot;${target}&quot;);` } /** * Create the Evoware 'StartScript' token. * @param {string} path - path to the script to start * @return {string} - line for a &quot;StartScript&quot; token */ export function createStartScriptLine(path) { return `StartScript(&quot;${path}&quot;);`; } /** * Create the Evoware token to prompt the user. * @param {string} text - text to show the user * @param {numeric} beep - 0: none, 1: beep once, 2: beep three times, 3: beep every 3 seconds * @param {numeric} autoclose - number of second to leave the prompt open before autoclosing it and continuing operation (-1 means no autoclose) */ export function createUserPromptLine(text, beep = 0, autoclose = -1) { return `UserPrompt(&quot;${text}&quot;,${beep},${autoclose});`; } /** * Create the Evoware token to prompt the user. * @param {string} text - text to show the user * @param {numeric} beep - 0: none, 1: beep once, 2: beep three times, 3: beep every 3 seconds * @param {numeric} autoclose - number of second to leave the prompt open before autoclosing it and continuing operation (-1 means no autoclose) */ export function createVariableLine(name, value) { const min = &quot;1.000000&quot;; const max = &quot;10.000000&quot;; return `Variable(${name},&quot;${value}&quot;,0,&quot;&quot;,0,${min},${max},${(_.isNumber(value) ? 0 : 1)},2,0,0);`; } /** * Put double-quotes around a string, if it doesn't already have them. * @param {string} s - any input string * @return {string} string with outer double-quotes. */ export function quote(s) { return `&quot;${stripQuotes(s)}&quot;`; } /** * If a string is surrounded by double-quotes, remove them. * @param {string} s - a string, possible with outer double-quotes. * @return {string} string with outer double-quotes removed. */ export function stripQuotes(s) { return (_.startsWith(s, '&quot;') &amp;&amp; _.endsWith(s, '&quot;')) ? s.substring(1, s.length - 1) : s; } × Search results Close "},"commands_pipetter.js.html":{"id":"commands_pipetter.js.html","title":"Source: commands/pipetter.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: commands/pipetter.js /** * Handles pipetter instructions. * @module */ import _ from 'lodash'; import assert from 'assert'; import math from 'mathjs'; import {sprintf} from 'sprintf-js'; import commandHelper from 'roboliq-processor/dist/commandHelper.js'; import * as evowareHelper from './evowareHelper.js'; import * as EvowareUtils from '../EvowareUtils.js'; import * as Tokens from './tokens.js'; import wellsParser from 'roboliq-processor/dist/parsers/wellsParser.js'; export function _aspirate(params, parsed, data) { return handlePipetterSpirate(parsed, data); } export function _dispense(params, parsed, data) { return handlePipetterSpirate(parsed, data); } export function _measureVolume(params, parsed, data) { // console.log(&quot;measureVolume: &quot;+JSON.stringify(parsed, null, '\\t')) return handlePipetterSpirate(parsed, data, {well: &quot;Detect_Liquid&quot;}); } export function _mix(params, parsed, data) { return handlePipetterSpirate(parsed, data, {well: &quot;Mix&quot;}); } export function _pipette(params, parsed, data) { return handlePipetterSpirate(parsed, data); } export function _washTips(params, parsed, data) { //console.log(&quot;handleWashProgram: &quot;+JSON.stringify(parsed, null, '\\t')) function handleScript(filename) { return `Subroutine(&quot;${filename}&quot;,0);`; } function handleWashProgram(program) { const syringeRows = parsed.value.syringes.map(x =&gt; _.isNumber(x) ? x : x.row); const syringeMask = encodeSyringesByRow(syringeRows); const bUNKNOWN1 = false; const lWash = [ syringeMask, program.wasteGrid, program.wasteSite-1, program.cleanerGrid, program.cleanerSite-1, `&quot;${math.format(program.wasteVolume, {precision: 14})}&quot;`, program.wasteDelay, `&quot;${math.format(program.cleanerVolume, {precision: 14})}&quot;`, program.cleanerDelay, program.airgapVolume, program.airgapSpeed, program.retractSpeed, (program.fastWash) ? 1 : 0, (bUNKNOWN1) ? 1 : 0, 1000, 0 ]; const lineWash = `Wash(${lWash.join(&quot;,&quot;)});`; const doRetract = _.get(data, [&quot;protocol&quot;, &quot;config&quot;, &quot;evowareCompiler&quot;, &quot;retractTips&quot;], true); if (doRetract) { const labwareModel = {rows: 8, columns: 1}; const tuples = parsed.value.syringes.map(syringe =&gt; ({retract: {row: _.isNumber(syringe) ? syringe : syringe.row, col: 1, labwareModel}})); const retractWellMask = encodeWells(tuples, &quot;retract&quot;); // console.log({tuples: JSON.stringify(tuples), retractWellMask}) const lRetract = [ syringeMask, program.cleanerGrid, program.cleanerSite-1, 1, // tip spacing `&quot;${retractWellMask}&quot;`, 4, // 0=positioning with global z travel, 4=z-move 4, // 4=global z travel 0, 400, // speed (mm/s), min 0.1, max 400 0, 0 ]; const lineRetract = `MoveLiha(${lRetract.join(&quot;,&quot;)});`; return [lineWash, lineRetract]; } else { return [lineWash]; } } const program = (_.isString(parsed.value.program)) ? commandHelper.lookupPath([parsed.value.program], {}, data) : parsed.value.program; assert(!_.isEmpty(program), &quot;missing wash program&quot;) //console.log({program}) const results = []; if (!_.isEmpty(program.script)) { results.push({line: handleScript(program.script)}); } else { handleWashProgram(program).forEach(line =&gt; results.push({line})); } return results; } function handlePipetterSpirate(parsed, data, groupTypeToFunc) { if (!groupTypeToFunc) { groupTypeToFunc = { &quot;source&quot;: &quot;Aspirate&quot;, &quot;destination&quot;: &quot;Dispense&quot; }; } // Create groups of items that can be pipetted simultaneously const groups = groupItems(parsed, data); // console.log(&quot;groups:\\n&quot;+JSON.stringify(groups, null, '\\t')); // Create a script line for each group: const results = _.flatMap(groups, group =&gt; handleGroup(parsed, data, group, groupTypeToFunc)); // console.log(&quot;results:\\n&quot;+JSON.stringify(results, null, '\\t')) const doRetract = _.get(data, [&quot;protocol&quot;, &quot;config&quot;, &quot;evowareCompiler&quot;, &quot;retractTips&quot;], true); if (groups.length &gt; 0 &amp;&amp; doRetract) { results.push(handleRetract(parsed, data, groups)) } // Get list of all accessed sites // token_l2 &lt;- handlePipetterSpirateDoGroup(objects, program, func, tuple_l.drop(tuple_l3.size)) const siteToWellInfo = {}; _.forEach(groups, group =&gt; _.forEach(group.tuples, tuple =&gt; { for (let propertyName of [&quot;source&quot;, &quot;destination&quot;, &quot;well&quot;]) { const wellInfo = tuple[propertyName]; if (wellInfo &amp;&amp; !siteToWellInfo.hasOwnProperty(wellInfo.siteName)) siteToWellInfo[wellInfo.siteName] = wellInfo; } })); //console.log({siteToWellInfo}) const tableEffects = []; _.forEach(siteToWellInfo, (wellInfo, siteName) =&gt; { const key = [wellInfo.site.evowareCarrier, wellInfo.site.evowareGrid, wellInfo.site.evowareSite]; const label = _.last(siteName.split(&quot;.&quot;)); tableEffects.push([key, {label, labwareModelName: wellInfo.labwareModel.evowareName}]); }); //console.log(tableEffects) return results.concat({tableEffects}); } /** * Returns an array of groupings of the pipette items. Each group has these properties: * * - `groupType` -- either &quot;source&quot; or &quot;destination&quot;, depending on whether this group is for aspiration or dispense * - `tuples` -- an array of objects with these properties: * - `item` -- the original pipette item * - `syringeName` -- roboliq name of the syringe to use * - `syringe` -- syringe object * - `syringeRow` -- row of syringe on the LiHa * - `source` -- source properties `{labwareName, labware, labwareModel, site, siteName, row, col}` * - `destination` -- destination properties `{labwareName, labware, labwareModel, site, siteName, row, col}` * - `syringeSpacing` * * @param {object} parsed - parsed command parameters * @param {object} data - protocol data * @return {array} an array of groupings of the pipette items */ function groupItems(parsed, data) { //console.log(&quot;parsed:\\n&quot;+JSON.stringify(parsed, null, '\\t')) let items = commandHelper.copyItemsWithDefaults(parsed.value.items, parsed.value.itemDefaults); // console.log(&quot;groupItems items:&quot;+JSON.stringify(items)) if (_.isEmpty(items)) return []; const tuples = []; for (let i = 0; i &lt; items.length; i++) { const item = items[i]; const syringeName = _.isInteger(item.syringe) ? `${parsed.objectName.equipment}.syringe.${item.syringe}` : parsed.objectName[`items.${i}.syringe`]; const syringe = commandHelper._g(data, syringeName); const syringeRow = _.isInteger(item.syringe) ? item.syringe : syringe.row; //console.log(&quot;stuff: &quot;+JSON.stringify(wellsParser.parseOne(item.source))) // const well = (item.hasOwnProperty(&quot;source&quot;)) ? item.source : item.destination; function getWellInfo(well) { if (_.isUndefined(well)) return undefined; const {labware: labwareName, wellId} = wellsParser.parseOne(well); //console.log({parseOne: wellsParser.parseOne(item.source)}) //console.log({labwareName, wellId}) const labware = commandHelper.lookupPath([labwareName], {}, data); const labwareModel = commandHelper.lookupPath([[labwareName, &quot;model&quot;]], {}, data); const [row, col] = wellsParser.locationTextToRowCol(wellId); const siteName = commandHelper.lookupPath([labwareName, &quot;location&quot;], {}, data); const site = commandHelper.lookupPath([[labwareName, &quot;location&quot;]], {}, data); return {labwareName, labware, labwareModel, site, siteName, row, col}; } //labwareName &lt;- ResultC.from(wellPosition.labware_?, &quot;incomplete well specification; please also specify the labware&quot;) //labwareInfo &lt;- getLabwareInfo(objects, labwareName) tuples.push({item, syringeName, syringeRow, source: getWellInfo(item.source), destination: getWellInfo(item.destination), well: getWellInfo(item.well)}); } // console.log(&quot;tuples:\\n&quot;+JSON.stringify(tuples, null, '\\t')) //console.log({ref}) // the spread of the syringes; normally this is 1, but Evoware can spread its syringes out more function canJoinGroup(group, tuple, debug) { // console.log(&quot;canJoinGroup: &quot;+JSON.stringify({group, tuple}, null, '\\t')) const ref = group.tuples[0]; // Make sure the same syringe is not used twice in one group const isUniqueSyringe = _.every(group.tuples, tuple2 =&gt; tuple2.syringeName != tuple.syringeName); if (!isUniqueSyringe) { if (debug) console.log({group, tuple, isUniqueSyringe, syringes: group.tuples.map(x =&gt; x.syringeName)}) return false; } function checkWellInfo(wellInfo, wellInfoRef) { // Same column? if (wellInfo.col === wellInfoRef.col) { //console.log({tuple}) const dRow1 = tuple.syringeRow - ref.syringeRow const dRow2 = wellInfo.row - wellInfoRef.row; //console.log({tupleSyringe: tuple.item.syringe, refSyringe: ref.item.syringe}) if (_.isUndefined(group.syringeSpacing)) { // If using the same well if (dRow2 === 0) { group.syringeSpacing = 0; return true; } else if (dRow1 === 0 || dRow2 === 0) { if (debug) console.log({group, tuple, dRow1, dRow2}) return false; } //console.log(1) //console.log({dRow1, dRow2}) const syringeSpacing = math.fraction(dRow2, dRow1); // console.log(2) // FIXME: need to check wether the syringe spacing is permissible! Check how much the syringes need to spread physically (not just relative to the plate wells), and whether that's possible for the hardware. Also, not all fractions will be permissible, probably. if (syringeSpacing &lt; 1) { if (debug) console.log({group, tuple, syringeSpacing}) return false; } else { group.syringeSpacing = syringeSpacing; return true; } } else { // If using the same well if (dRow2 === 0 &amp;&amp; group.syringeSpacing === 0) { return true; } // console.log(3) else if (math.equal(math.fraction(dRow2, dRow1), group.syringeSpacing)) return true; // console.log(4) } } if (debug) console.log({group, tuple, col: wellInfo.col, colRef: wellInfoRef.col}) return false; } // Same labware? if ((tuple.source &amp;&amp; tuple.source.labwareName !== ref.source.labwareName) || (tuple.destination &amp;&amp; tuple.destination.labwareName !== ref.destination.labwareName) || (tuple.well &amp;&amp; tuple.well.labwareName !== ref.well.labwareName)) { if (debug) console.log({group, tuple, col: wellInfo.col, colRef: wellInfoRef.col}) return false; } // Other things ok? if (!_.isUndefined(tuple[group.groupType])) { if (checkWellInfo(tuple[group.groupType], ref[group.groupType])) return true; } return false; } let groupSrc = {groupType: &quot;source&quot;, tuples: []}; let groupDst = {groupType: &quot;destination&quot;, tuples: []}; let groupWll = {groupType: &quot;well&quot;, tuples: []}; const groups = [groupSrc, groupDst, groupWll]; const debug = false; for (let i = 0; i &lt; tuples.length; i++) { const tuple = tuples[i]; let needNew = false; if (tuple.well) { if (groupWll.tuples.length === 0 || canJoinGroup(groupWll, tuple, debug)) { groupWll.tuples.push(tuple); } else { needNew = true; } } else { if (tuple.source) { if (groupSrc.tuples.length === 0 || canJoinGroup(groupSrc, tuple, debug)) { groupSrc.tuples.push(tuple); } else { needNew = true; } } if (!needNew &amp;&amp; tuple.destination) { if (groupDst.tuples.length === 0 || canJoinGroup(groupDst, tuple, debug)) { groupDst.tuples.push(tuple); } else { groupDst = {groupType: &quot;destination&quot;, tuples: [tuple]}; groups.push(groupDst); } } } // No, so start new src and dst groups if (needNew) { // Start a new group` groupSrc = {groupType: &quot;source&quot;, tuples: []}; groupDst = {groupType: &quot;destination&quot;, tuples: []}; groupWll = {groupType: &quot;well&quot;, tuples: []}; groups.push(groupSrc); groups.push(groupDst); groups.push(groupWll); i--; } } const groups2 = groups.filter(group =&gt; group.tuples.length &gt; 0); return groups2; } function handleGroup(parsed, data, group, groupTypeToFunc) { assert(group.tuples.length &gt; 0); // If the syringe spacing is 0, that means that each syringe is accessing the // same well, in which case we actually need to seaparate the group items: if (group.syringeSpacing === 0) { const groups = group.tuples.map(tuple =&gt; ({ groupType: group.groupType, tuples: [tuple] })); return _.flatMap(groups, group =&gt; handleGroup(parsed, data, group, groupTypeToFunc)); } const tuples = group.tuples; // Calculate syringe mask const tuple0 = tuples[0]; const syringeMask = encodeSyringes(tuples); // console.log({syringeMask}) // Volumes for each syringe (in ul) const volumes = _.fill(Array(12), &quot;0&quot;); _.forEach(tuples, tuple =&gt; { const index = (tuple.syringeRow || 1) - 1; const ul = (tuple.item.volume) ? tuple.item.volume.toNumber('ul') : 0; volumes[index] = `&quot;${math.format(ul, {precision: 14})}&quot;`; }); // Script command line function makeLines(func, propertyName) { const wellInfo = tuple0[propertyName]; // console.log({func, propertyName, wellInfo}) if (_.isUndefined(wellInfo)) return []; const labwareModel = wellInfo.labwareModel; const plateMask = encodeWells(tuples, propertyName); const program = (func === &quot;Aspirate&quot; &amp;&amp; parsed.value.sourceProgram) ? parsed.value.sourceProgram : parsed.value.program; const l = [ syringeMask, `&quot;${evowareHelper.stripQuotes(program)}&quot;`, (func != &quot;Detect_Liquid&quot;) ? volumes.join(&quot;,&quot;) : undefined, wellInfo.site.evowareGrid, wellInfo.site.evowareSite - 1, group.syringeSpacing || 1, `&quot;${plateMask}&quot;`, 0, 0 ]; _.remove(l, _.isUndefined); // console.log({l0, l1: _.remove(l, _.isUndefined)}) // const l = l0; let lines = [{line: `${func}(${l.join(&quot;,&quot;)});`}]; // sourceMixing if (func === &quot;Aspirate&quot;) { const mixTuples = (parsed.value.sourceMixing) ? tuples : tuples.filter(tuple =&gt; !_.isUndefined(tuple.item.sourceMixing)); if (!_.isEmpty(mixTuples)) { const count = (mixTuples[0].item.sourceMixing || parsed.value.sourceMixing).count; const lines2 = makeLines_Mix(mixTuples, propertyName, parsed.value.sourceMixing, &quot;sourceMixing.volume&quot;, parsed.value.program, group.syringeSpacing || 1, count); lines = lines2.concat(lines); } } // destinationMixing else if (func === &quot;Dispense&quot;) { const mixTuples = (parsed.value.destinationMixing) ? tuples : tuples.filter(tuple =&gt; !_.isUndefined(tuple.item.destinationMixing)); if (!_.isEmpty(mixTuples)) { // console.log(parsed.value.destinationMixing) const count = (mixTuples[0].item.destinationMixing || parsed.value.destinationMixing).count; const lines2 = makeLines_Mix(mixTuples, propertyName, parsed.value.destinationMixing, &quot;destinationMixing.volume&quot;, parsed.value.program, group.syringeSpacing || 1, count); lines = lines.concat(lines2); } } else if (func === &quot;Detect_Liquid&quot;) { // console.log({tuples}) // console.log({well: _.first(tuples).well}) const l = tuples.map(tuple =&gt; { // Indicate to EvowareCompiler that we need to create this variable at the top of the script const variable = `DETECTED_VOLUME_${tuple.syringeRow}`; data.evowareVariables[variable] = 0; // Parameters for the call to ROBOLIQ return [tuple.syringeRow, tuple.well.labwareName, wellsParser.locationRowColToText(tuple.well.row, tuple.well.col), `~${variable}~`].join(&quot;,&quot;); }); // console.log({l}) const args = [&quot;evowareDetectedVolume&quot;, &quot;%{SCRIPTFILE}&quot;, data.path.join(&quot;.&quot;)].concat(l); const lines2 = [{line: evowareHelper.createExecuteLine(&quot;%{ROBOLIQ}&quot;, args, true)}]; lines = lines.concat(lines2); } return lines; } function makeLinesMix(propertyName) { return makeLines_Mix(tuples, propertyName, undefined, &quot;volume&quot;, parsed.value.program, group.syringeSpacing || 1, tuple0.item.count); } const func = groupTypeToFunc[group.groupType]; //console.log({syringeMask, volumes}) return (func === &quot;Mix&quot;) ? makeLinesMix(group.groupType) : makeLines(func, group.groupType); } // /** * Return Array of size 12 with volumes for each syringe (in ul), taking the * values from the 'tuples' items. For each item, the volume is queried * using the volumePropertyName. If the volume is missing, volumeDefault should * be provided. * * @param {array} tuples * @param {string} volumePropertyName * @param {mathjs.Unit} volumeDefault * @return {array} An array of volumes (in ul) */ function makeVolumes(tuples, volumePropertyName, volumeDefault) { const volumes = _.fill(Array(12), &quot;0&quot;); _.forEach(tuples, tuple =&gt; { const index = (tuple.syringeRow || 1) - 1; const ul = _.get(tuple.item, volumePropertyName, volumeDefault).toNumber('ul'); volumes[index] = `&quot;${math.format(ul, {precision: 14})}&quot;`; }); return volumes; } function makeLines_Mix(tuples, propertyName, mixingDefault, volumePropertyName, program, syringeSpacing, count) { const syringeMask = encodeSyringes(tuples); // console.log({syringeMask}) const plateMask = encodeWells(tuples, propertyName); const volumes = makeVolumes(tuples, volumePropertyName, _.get(mixingDefault, &quot;volume&quot;)); const wellInfo = tuples[0][propertyName]; if (_.isUndefined(wellInfo)) return []; const line = new Tokens.Mix({ syringeMask, program, volumes, evowareGrid: wellInfo.site.evowareGrid, evowareSite: wellInfo.site.evowareSite, syringeSpacing, plateMask, count }).toLine(); return [{line}]; } function handleRetract(parsed, data, groups) { const tuplesOrig = _.flatMap(groups, group =&gt; group.tuples); const tuple0 = _.last(tuplesOrig); const propertyName = (tuple0.well) ? &quot;well&quot; : (tuple0.destination) ? &quot;destination&quot; : &quot;source&quot;; const wellInfo = tuple0[propertyName]; // console.log({propertyName, wellInfo, tuple0}) if (_.isUndefined(wellInfo)) return undefined; const labwareModel = wellInfo.labwareModel; const syringeRows = _.uniq(tuplesOrig.map(x =&gt; x.syringeRow)).sort(); const tuples = syringeRows.map(syringeRow =&gt; ({syringeRow, retract: {row: syringeRow, col: 1, labwareModel}})); // Calculate syringe mask const syringeMask = encodeSyringes(tuples); const retractWellMask = encodeWells(tuples, &quot;retract&quot;); // console.log({tuples: JSON.stringify(tuples), retractWellMask}) const lRetract = [ syringeMask, wellInfo.site.evowareGrid, wellInfo.site.evowareSite - 1, 1, // tip spacing `&quot;${retractWellMask}&quot;`, 4, // 0=positioning with global z travel, 4=z-move 4, // 4=global z travel 0, 400, // speed (mm/s), min 0.1, max 400 0, 0 ]; const line = `MoveLiha(${lRetract.join(&quot;,&quot;)});`; return {line}; } /** * Generate a bitmap encoding of syringes to use * @param {array} syringes - array of syringes to use * @return {integer} an bitmask encoding of the syringes */ function encodeSyringes(tuples) { return _.sum(_.map(tuples, tuple =&gt; 1 &lt;&lt; (tuple.syringeRow - 1))); } /** * Generate a bitmap encoding of syringes to use * @param {array} rows - array of syringe rows (base value is 1) * @return {integer} an bitmask encoding of the syringes */ function encodeSyringesByRow(rows) { return _.sum(_.map(rows, row =&gt; 1 &lt;&lt; (row - 1))); } /** * Encode a list of wells on a plate as an evoware bitmask */ //function encodeWells(rows, cols, well_l: Traversable[WellNameSingleParsed]): ResultC[String] = { function encodeWells(tuples, propertyName) { assert(tuples.length &gt; 0); const labwareModel = tuples[0][propertyName].labwareModel; const nWellMaskChars = math.ceil(labwareModel.rows * labwareModel.columns / 7.0); const amWells = _.fill(Array(nWellMaskChars), 0); _.forEach(tuples, tuple =&gt; { const index = (tuple[propertyName].row - 1) + (tuple[propertyName].col - 1) * labwareModel.rows; const iChar = _.toInteger(index / 7); const iWell1 = index % 7; assert(iChar &lt; amWells.length, &quot;INTERNAL ERROR: encodeWells: index out of bounds -- &quot;+JSON.stringify(tuple)); // console.log({index, iChar, iWell1}) amWells[iChar] += 1 &lt;&lt; iWell1; }); // console.log({amWells}) const sWellMask = amWells.map(EvowareUtils.encode).join(&quot;&quot;); const sPlateMask = sprintf(&quot;%02X%02X&quot;, labwareModel.columns, labwareModel.rows) + sWellMask; return sPlateMask; } × Search results Close "},"commands_transporter.js.html":{"id":"commands_transporter.js.html","title":"Source: commands/transporter.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: commands/transporter.js /** * Handles transporter instructions and supplies some additional control functions * for moving the ROMAs. * @module */ import _ from 'lodash'; import commandHelper from 'roboliq-processor/dist/commandHelper.js'; function getMoveRomaHomeLine(romaIndex) { return getRomaMoveLine(romaIndex, 2); } /** * Move a ROMA * @param {number} romaIndex - index of roma * @param {number} action - 0=open gripper, 1=close gripper, 2=move home, 3=move relative, * @return {string} string representation of ROMA command */ function getRomaMoveLine(romaIndex, action) { const x = { action, gripperDistance: 80, force: 0, dx: 0, dy: 0, dz: 0, speed: 150, maximumSpeed: 1, romaIndex }; return `ROMA(${x.action},${x.gripperDistance},${x.force},${x.dx},${x.dy},${x.dz},${x.speed},${x.maximumSpeed},${x.romaIndex});`; } /** * Handle the `transporter._moveLidFromContainerToSite` instruction. * * @param {object} params - original paramters * @param {object} parsed - parsed parameters * @param {object} data - protocol data * @return {array} an array of objects that describe output, effects, and table effects */ export function _moveLidFromContainerToSite(params, parsed, data) { // console.log(&quot;_moveLidFromContainerToSite: &quot;+JSON.stringify(parsed, null, '\\t')); const params2 = { agent: params.agent, equipment: params.equipment, program: params.program, object: params.container, destination: parsed.value.container.location }; // console.log(&quot;params2: &quot;+JSON.stringify(params2, null, '\\t')); const parsed2 = commandHelper.parseParams(params2, data, data.protocol.schemas[&quot;transporter._movePlate&quot;]); const lidHandling = { lid: parsed.objectName.object, action: &quot;remove&quot;, location: parsed.objectName.destination, destination: parsed.objectName.destination }; return _movePlate(params2, parsed2, data, lidHandling); } /** * Handle the `transporter._moveLidFromSiteToContainer` instruction. * * @param {object} params - original paramters * @param {object} parsed - parsed parameters * @param {object} data - protocol data * @return {array} an array of objects that describe output, effects, and table effects */ export function _moveLidFromSiteToContainer(params, parsed, data) { // console.log(&quot;_moveLidFromContainerToSite: &quot;+JSON.stringify(parsed, null, '\\t')); const params2 = { agent: params.agent, equipment: params.equipment, program: params.program, object: params.container, destination: parsed.value.container.location }; // console.log(&quot;params2: &quot;+JSON.stringify(params2, null, '\\t')); const parsed2 = commandHelper.parseParams(params2, data, data.protocol.schemas[&quot;transporter._movePlate&quot;]); const lidHandling = { lid: parsed.objectName.object, action: &quot;cover&quot;, location: parsed.objectName.origin, destination: parsed.objectName.container }; return _movePlate(params2, parsed2, data, lidHandling); } /** * Handle the `transporter._movePlate` instruction. * * @param {object} params - original paramters * @param {object} parsed - parsed parameters * @param {object} data - protocol data * @param {object} [lidHandling0] - an optional option to define lid handling - this is only used by the `_moveLidFromContainerToSite` and `_moveLidFromSiteToContainer` handlers. * @param {string} [lidHandling0.lid] - name of the lid * @param {string} [lidHandling0.action] - should either be &quot;remove&quot; or &quot;cover&quot; * @param {string} [lidHandling0.location] - the site where the lid should be moved from or to * @param {string} [lidHandling0.destination] - the site where the lid should be after the transfer * @return {array} an array of objects that describe output, effects, and table effects */ export function _movePlate(params, parsed, data, lidHandling0) { // console.log(&quot;_movePlate: &quot;+JSON.stringify(parsed, null, '\\t')); // romaIndex: &quot;(@equipment).evowareRoma: integer&quot; const values = commandHelper.lookupPaths({ romaIndex: [&quot;@equipment&quot;, &quot;evowareRoma&quot;], programName: [&quot;@program&quot;], plateModelName: [[&quot;@object&quot;, &quot;model&quot;], &quot;evowareName&quot;], plateOrigName: [&quot;@object&quot;, &quot;location&quot;], plateOrigCarrierName: [[&quot;@object&quot;, &quot;location&quot;], &quot;evowareCarrier&quot;], plateOrig: [[&quot;@object&quot;, &quot;location&quot;]], plateOrigGrid: [[&quot;@object&quot;, &quot;location&quot;], &quot;evowareGrid&quot;], plateOrigSite: [[&quot;@object&quot;, &quot;location&quot;], &quot;evowareSite&quot;], plateDest: [[&quot;@destination&quot;]], plateDestCarrierName: [&quot;@destination&quot;, &quot;evowareCarrier&quot;], plateDestGrid: [&quot;@destination&quot;, &quot;evowareGrid&quot;], plateDestSite: [&quot;@destination&quot;, &quot;evowareSite&quot;], }, params, data); // Lid handling parameters const lidHandling = { enabled: false, grid: &quot;&quot;, carrierName: &quot;&quot;, site: &quot;(Not defined)&quot; }; if (!_.isEmpty(lidHandling0)) { lidHandling.enabled = true; lidHandling.removeAtSource = (lidHandling0.action == &quot;remove&quot;); lidHandling.grid = commandHelper.lookupPath([&quot;@location&quot;, &quot;evowareGrid&quot;], lidHandling0, data) lidHandling.carrierName = commandHelper.lookupPath([&quot;@location&quot;, &quot;evowareCarrier&quot;], lidHandling0, data) lidHandling.site = commandHelper.lookupPath([&quot;@location&quot;, &quot;evowareSite&quot;], lidHandling0, data) } const plateDestName = parsed.objectName.destination; // It may be that multiple sites are defined which are actually the same physical location. // We can supress transporter commands between the logical sites by checking whether the sames have the same siteIdUnique. // console.log({plateOrig: values.plateOrig, plateDest: values.plateDest}) if (values.plateOrig.siteIdUnique &amp;&amp; values.plateOrig.siteIdUnique === values.plateDest.siteIdUnique) { return [{ tableEffects: [ [[values.plateOrigCarrierName, values.plateOrigGrid, values.plateOrigSite], {label: _.last(values.plateOrigName.split('.')), labwareModelName: values.plateModelName}], [[values.plateDestCarrierName, values.plateDestGrid, values.plateDestSite], {label: _.last(plateDestName.split('.')), labwareModelName: values.plateModelName}], ] }]; } const romaIndexPrev = _.get(data.objects, [&quot;EVOWARE&quot;, &quot;romaIndexPrev&quot;], values.romaIndex); const bMoveBackToHome = parsed.value.evowareMoveBackToHome || false; // 1 = move back to home position values.moveBackToHome = (bMoveBackToHome) ? 1 : 0; //console.log(JSON.stringify(values, null, '\\t')) const l = [ `&quot;${values.plateOrigGrid}&quot;`, `&quot;${values.plateDestGrid}&quot;`, values.moveBackToHome, (lidHandling.enabled) ? 1 : 0, 0, // speed: 0 = maximum, 1 = taught in vector dialog values.romaIndex, (lidHandling.removeAtSource) ? 1 : 0, `&quot;${lidHandling.grid}&quot;`, `&quot;${values.plateModelName}&quot;`, `&quot;${values.programName}&quot;`, '&quot;&quot;', '&quot;&quot;', `&quot;${values.plateOrigCarrierName}&quot;`, `&quot;${lidHandling.carrierName}&quot;`, `&quot;${values.plateDestCarrierName}&quot;`, `&quot;${values.plateOrigSite}&quot;`, `&quot;${lidHandling.site}&quot;`, `&quot;${values.plateDestSite}&quot;` ]; const line = `Transfer_Rack(${l.join(&quot;,&quot;)});`; //println(s&quot;line: $line&quot;) //val let = JsonUtils.makeSimpleObject(x.`object`+&quot;.location&quot;, JsString(plateDestName)) const plateName = parsed.objectName.object; const items = []; if (values.romaIndex !== romaIndexPrev) { items.push({ line: getMoveRomaHomeLine(romaIndexPrev) }); } items.push({ line, effects: _.fromPairs(_.compact([ [`${plateName}.location`, plateDestName], (lidHandling.enabled) ? [`${lidHandling0.lid}.location`, lidHandling0.destination] : undefined, [`EVOWARE.romaIndexPrev`, values.romaIndex]] )), tableEffects: [ [[values.plateOrigCarrierName, values.plateOrigGrid, values.plateOrigSite], {label: _.last(values.plateOrigName.split('.')), labwareModelName: values.plateModelName}], [[values.plateDestCarrierName, values.plateDestGrid, values.plateDestSite], {label: _.last(plateDestName.split('.')), labwareModelName: values.plateModelName}], ] }); return items; } /** * Move the last-moved ROMA back to its home position. * * @param {object} data - protocol data * @return {array} an array of objects that describe output, effects, and table effects */ export function moveLastRomaHome(data) { const romaIndexPrev = _.get(data.objects, [&quot;EVOWARE&quot;, &quot;romaIndexPrev&quot;]); if (romaIndexPrev) { return [{ line: getMoveRomaHomeLine(romaIndexPrev) }]; } else { return []; } } × Search results Close "},"equipment_centrifuge4.js.html":{"id":"equipment_centrifuge4.js.html","title":"Source: equipment/centrifuge4.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: equipment/centrifuge4.js /** * Module for a generic 4-site centrifuge. * @module */ const _ = require('lodash'); const assert = require('assert'); const math = require('mathjs'); const commandHelper = require('roboliq-processor/dist/commandHelper.js'); const expect = require('roboliq-processor/dist/expect.js'); const {makeEvowareFacts} = require('roboliq-evoware/dist/equipment/evoware.js'); /** * @typedef CentrifugeParams * @type {object} * @property {!string} evowareId - the Evoware ID of this equipment * @property {!string} evowareCarrier - the carrier that the equipment is on * @property {!string} evowareGrid - the grid that the equipment is on * @param {!Object} sites - keys are the site names (just the base part, without namespace), values are objects with the property `evowareSite`. * @param {!CentrifugeSitesToModels[]} siteModelCompatibilities - an array of objects {sites, models} of which sites * @example * ``` * { * evowareId: &quot;Centrifuge&quot;, * evowareCarrier: &quot;Centrifuge&quot;, * evowareGrid: 54, * sites: { * CENTRIFUGE_1: { evowareSite: 1 }, * CENTRIFUGE_2: { evowareSite: 2 }, * CENTRIFUGE_3: { evowareSite: 1 }, * CENTRIFUGE_4: { evowareSite: 2 } * }, * siteModelCompatibilities: [ * { * sites: [&quot;CENTRIFUGE_1&quot;, &quot;CENTRIFUGE_2&quot;, &quot;CENTRIFUGE_3&quot;, &quot;CENTRIFUGE_4&quot;], * models: [&quot;plateModel_384_square&quot;, &quot;plateModel_96_round_transparent_nunc&quot;] * }, * { * sites: [&quot;CENTRIFUGE_2&quot;, &quot;CENTRIFUGE_4&quot;], * models: [&quot;plateModel_96_dwp&quot;] * }, * ] * } */ /** * @typedef CentrifugeSitesToModels * @type {object} * @property {!string[]} sites - array of site names (just the base part, without namespace) * @property {!string[]} models - array of model names (just the base part, without namespace) */ /** * Configure a generic centrifuge * @param {CentrifugeParams} params - parameters for the configuration * @return {EquipmentConfig} */ function configure(config, equipmentName, params) { // console.log(&quot;centrifuge4:&quot;); console.log(JSON.stringify(params, null, '\\t')) const N = Object.keys(params.sites).length; assert(N == 4, &quot;centrifuge4 has only been designed for 4-site centrifuges. Please contact the developer if you need a different number of sites.&quot;) // const sites = _.mapValues(params.sites, value =&gt; ({ // evowareCarrier: params.evowareId, // evowareGrid: params.evowareGrid, // evowareSite: value.evowareSite, // close: true // })); // Create map from site to all its compatible models const siteToModels = _(params.siteModelCompatibilities) .map(x =&gt; x.sites.map(site0 =&gt; ({site: config.getSiteName(site0), models: x.models.map(config.getModelName)}))) .flatten() .groupBy(x =&gt; x.site) .mapValues(x =&gt; _.flatten(_.map(x, &quot;models&quot;))) .value(); // console.log({siteToModels}) const agent = config.getAgentName(); const equipment = config.getEquipmentName(equipmentName); const siteNames = Object.keys(siteToModels); const objects = {}; // Add centrifuge _.set(objects, equipment, { type: &quot;Centrifuge&quot;, evowareId: params.evowareId, sitesInternal: siteNames }); // Add internal sites _.forEach(params.sites, (value, key) =&gt; { const site = config.getSiteName(key); _.set(objects, site, { type: &quot;Site&quot;, evowareCarrier: params.evowareCarrier, evowareGrid: params.evowareGrid, evowareSite: value.evowareSite, closed: true }); }); // Add predicates for siteModelCompatibilities const output = {}; config.addSiteModelCompatibilities(params.siteModelCompatibilities, output); // console.log({siteModelCompatibilities: params.siteModelCompatibilities, output}) // For the 1st and 3rd sites const predicates13 = _(siteToModels[siteNames[0]]).map(model =&gt; { return {&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;: { agent, equipment, model, site1: siteNames[0], site2: siteNames[2], }} }).flatten().value(); // For the 2nd and 4th sites const predicates24 = _(siteToModels[siteNames[1]]).map(model =&gt; { return {&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;: { agent, equipment, model, site1: siteNames[1], site2: siteNames[3], }} }).flatten().value(); // console.log({siteToModels, siteNames, predicates24}) const predicateTasks = _.flatten([ {&quot;action&quot;: {&quot;description&quot;: equipment+&quot;.close: close the centrifuge&quot;, &quot;task&quot;: {[equipment+&quot;.close&quot;]: {&quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot;}}, &quot;preconditions&quot;: [], &quot;deletions&quot;: [], &quot;additions&quot;: siteNames.map(site =&gt; ({siteIsClosed: {site}})) }}, _.map(siteNames, (site, i) =&gt; { return {&quot;method&quot;: {&quot;description&quot;: &quot;generic.openSite-&quot;+site, &quot;task&quot;: {&quot;generic.openSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [{&quot;same&quot;: {&quot;thing1&quot;: &quot;?site&quot;, &quot;thing2&quot;: site}}], &quot;subtasks&quot;: {&quot;ordered&quot;: [{[equipment+&quot;.open&quot;+(i+1)]: {}}]} }}; }), _.map(siteNames, (site, i) =&gt; { return {&quot;action&quot;: {&quot;description&quot;: equipment+&quot;.open&quot;+(i+1)+&quot;: open an internal site on the centrifuge&quot;, &quot;task&quot;: {[equipment+&quot;.open&quot;+(i+1)]: {}}, &quot;preconditions&quot;: [], &quot;deletions&quot;: [ {&quot;siteIsClosed&quot;: {&quot;site&quot;: site}} ], &quot;additions&quot;: _.map(_.without(siteNames, site), function(site2) { return {&quot;siteIsClosed&quot;: {&quot;site&quot;: site2}}; }) }}; }), _.map(siteNames, (site, i) =&gt; ({method: { &quot;description&quot;: &quot;generic.closeSite-&quot;+site, &quot;task&quot;: {&quot;generic.closeSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [ {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site&quot;, &quot;thing2&quot;: site}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {[equipment+&quot;.close&quot;]: {&quot;agent&quot;: &quot;ourlab.mario.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.mario.centrifuge&quot;}} ]} }})), ]); const planHandlers = {}; planHandlers[equipment+&quot;.close&quot;] = (params, parentParams, data) =&gt; { return [{ command: &quot;equipment.close&quot;, agent, equipment }]; }; _.forEach(siteNames, (site, i) =&gt; { planHandlers[equipment+&quot;.open&quot;+(i+1)] = (params, parentParams, data) =&gt; { return [{ command: &quot;equipment.openSite&quot;, agent, equipment, site }]; }; }); const schemas = { [`equipment.close|${agent}|${equipment}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, }, required: [&quot;agent&quot;, &quot;equipment&quot;] }, [`equipment.open|${agent}|${equipment}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, }, required: [&quot;agent&quot;, &quot;equipment&quot;] }, [`equipment.openSite|${agent}|${equipment}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, site: {description: &quot;Site identifier&quot;, type: &quot;Site&quot;} }, required: [&quot;agent&quot;, &quot;equipment&quot;, &quot;site&quot;] }, [`equipment.run|${agent}|${equipment}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: { description: &quot;Program for centrifuging&quot;, type: &quot;object&quot;, properties: { rpm: {type: &quot;number&quot;, default: 3000}, duration: {type: &quot;Duration&quot;, default: &quot;30 s&quot;}, spinUpTime: {type: &quot;Duration&quot;, default: &quot;9 s&quot;}, spinDownTime: {type: &quot;Duration&quot;, default: &quot;9 s&quot;}, temperature: {type: &quot;Temperature&quot;, default: &quot;25 degC&quot;} } } }, required: [&quot;program&quot;] }, }; const commandHandlers = { [`equipment.close|${agent}|${equipment}`]: function(params, parsed, data) { return {expansion: [makeEvowareFacts(parsed, data, &quot;Close&quot;)]}; }, [`equipment.open|${agent}|${equipment}`]: function(params, parsed, data) { return {expansion: [makeEvowareFacts(parsed, data, &quot;Open&quot;)]}; }, [`equipment.openSite|${agent}|${equipment}`]: function(params, parsed, data) { var carrier = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); var sitesInternal = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;sitesInternal&quot;); var siteIndex = sitesInternal.indexOf(parsed.objectName.site); expect.truthy({paramName: &quot;site&quot;}, siteIndex &gt;= 0, &quot;site must be one of the equipments internal sites: &quot;+sitesInternal.join(&quot;, &quot;)); return { expansion: [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: carrier, factsVariable: carrier+&quot;_MoveToPos&quot;, factsValue: (siteIndex+1).toString() }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: carrier, factsVariable: carrier+&quot;_Open&quot; }, ] }; }, [`equipment.run|${agent}|${equipment}`]: function(params, parsed, data) { //console.log(&quot;equipment.run|ourlab.mario.evoware|ourlab.mario.centrifuge:&quot;) //console.log({parsed, params}) const parsedProgram = parsed.value.program; //console.log({parsedProgram}); var list = [ math.round(parsedProgram.rpm), math.round(parsedProgram.duration.toNumber('s')), math.round(parsedProgram.spinUpTime.toNumber('s')), math.round(parsedProgram.spinDownTime.toNumber('s')), math.round(parsedProgram.temperature.toNumber('degC')) ]; var value = list.join(&quot;,&quot;); return {expansion: [makeEvowareFacts(parsed, data, &quot;Execute1&quot;, value)]}; }, }; const protocol = { schemas, objects, predicates: _.flatten([output.predicates, predicates13, predicates24, predicateTasks]), planHandlers, commandHandlers, }; // console.log(&quot;centrifuge predicates: &quot;+JSON.stringify(protocol.predicates, null, '\\t')) return protocol; } module.exports = { configure }; × Search results Close "},"equipment_evoware.js.html":{"id":"equipment_evoware.js.html","title":"Source: equipment/evoware.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: equipment/evoware.js /** * Module for Evoware commands. * In order to use Evoware commands in Roboliq, you'll need to calls these * functions in your robot configuration file. * @module */ import _ from 'lodash'; import commandHelper from 'roboliq-processor/dist/commandHelper.js'; import expect from 'roboliq-processor/dist/expect.js'; import yaml from 'yamljs'; /** * Create an instruction for Evoware execute an external command. * @static * @param {string} agentName - Agent identifier * @param {string} path - path to command to execute * @param {array} args - array of arguments to pass * @param {boolean} wait - true if evoware should wait for the command to complete execution * @return {object} an object representing an Evoware 'Execute' instruction. */ function makeEvowareExecute(agentName, path, args, wait) { return { command: &quot;evoware._execute&quot;, agent: agentName, path, args, wait }; } /** * Create an instruction for Evoware FACTS. * @static * @param {object} parsed - parsed object of command parameters * @param {object} data - protocol data * @param {string} variable [description] * @param {any} [value] - optional value; if value is a function, it will be called with the parameters (parsed, data). * @param {string} labwareName - labware used in this command * @return {object} an object representing an Evoware 'FACTS' instruction. */ function makeEvowareFacts(parsed, data, variable, value, labwareName) { const equipmentId = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); const result2 = { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_&quot;+variable }; const value2 = (_.isFunction(value)) ? value(parsed, data) : value; return _.merge(result2, {factsValue: value2, labware: labwareName}); } /** * Create the predictates to be added to Roboliq's robot * configuration for Evoware's site/model relationships. * * Expect spec of this form: * ``{siteModel: string, sites: [string], labwareModels: [string]}`` * @static */ function makeSiteModelPredicates(spec) { return _.flatten([ {isSiteModel: {model: spec.siteModel}}, _.map(spec.sites, site =&gt; ({siteModel: {site, siteModel: spec.siteModel}})), _.map(spec.labwareModels, labwareModel =&gt; ({stackable: {below: spec.siteModel, above: labwareModel}})) ]); } /** * Create the predictates to be added to Roboliq's robot * configuration for Evoware's RoMa relationships. * * Expect specs of this form: * ``{&lt;transporter&gt;: {&lt;program&gt;: [site names]}}`` * @static */ function makeTransporterPredicates(namespaceName, agentName, specs) { let siteCliqueId = 1; const l = []; _.forEach(specs, (programs, equipment) =&gt; { _.forEach(programs, (cliques, program) =&gt; { _.forEach(cliques, (sites) =&gt; { const siteClique = `${namespaceName}.${agentName}.siteClique${siteCliqueId}`; siteCliqueId++; _.forEach(sites, site =&gt; { l.push({&quot;siteCliqueSite&quot;: {siteClique, site}}); }); l.push({ &quot;transporter.canAgentEquipmentProgramSites&quot;: { &quot;agent&quot;: agentName, equipment, program, siteClique } }); }); }); }); return l; } module.exports = { makeEvowareExecute, makeEvowareFacts, makeSiteModelPredicates, makeTransporterPredicates, /** * objectToPredicateConverters for Evoware */ objectToPredicateConverters: { &quot;EvowareRobot&quot;: function(name) { return [{ &quot;isAgent&quot;: { &quot;agent&quot;: name } }]; } }, /** * Returns the schemas for Evoware commands and objects. * @return {object} map from name to schema */ getSchemas: () =&gt; yaml.load(__dirname+&quot;/../schemas/commands/evoware.yaml&quot;), /** * Return command handlers for low-level evoware instructions. * @return {object} map from instruction name to handler. */ getCommandHandlers: () =&gt; ({ &quot;evoware._execute&quot;: function(params, parsed, data) {}, &quot;evoware._facts&quot;: function(params, parsed, data) {}, &quot;evoware._raw&quot;: function(params, parsed, data) {}, &quot;evoware._subroutine&quot;: function(params, parsed, data) {}, &quot;evoware._userPrompt&quot;: function(params, parsed, data) {}, }), }; × Search results Close "},"equipment_reader-InfiniteM200Pro.js.html":{"id":"equipment_reader-InfiniteM200Pro.js.html","title":"Source: equipment/reader-InfiniteM200Pro.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: equipment/reader-InfiniteM200Pro.js /** * Module for the Tecan InfiniteM200 reader. * @module */ import _ from 'lodash'; import assert from 'assert'; import math from 'mathjs'; import Handlebars from 'handlebars'; import path from 'path'; import commandHelper from 'roboliq-processor/dist/commandHelper.js'; import expect from 'roboliq-processor/dist/expect.js'; import wellsParser from 'roboliq-processor/dist/parsers/wellsParser.js'; import {makeEvowareExecute, makeEvowareFacts} from './evoware.js'; const templateAbsorbance = `&lt;TecanFile xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;tecan.at.schema.documents Main.xsd&quot; fileformat=&quot;Tecan.At.Measurement&quot; fileversion=&quot;2.0&quot; xmlns=&quot;tecan.at.schema.documents&quot;&gt; &lt;FileInfo type=&quot;&quot; instrument=&quot;infinite 200Pro&quot; version=&quot;&quot; createdFrom=&quot;localadmin&quot; createdAt=&quot;{{createdAt}}&quot; createdWith=&quot;Tecan.At.XFluor.ReaderEditor.XFluorReaderEditor&quot; description=&quot;&quot; /&gt; &lt;TecanMeasurement id=&quot;1&quot; class=&quot;Measurement&quot;&gt; &lt;MeasurementManualCycle id=&quot;2&quot; number=&quot;1&quot; type=&quot;Standard&quot;&gt; &lt;CyclePlate id=&quot;3&quot; file=&quot;{{plateFile}}&quot; plateWithCover=&quot;{{plateWithCover}}&quot;&gt; &lt;PlateRange id=&quot;4&quot; range=&quot;{{wells}}&quot; auto=&quot;false&quot;&gt; {{#if doShakeBefore}}&lt;Shaking id=&quot;{{shakeBeforeId}}&quot; mode=&quot;Orbital&quot; time=&quot;{{shakeBeforeTime}}&quot; frequency=&quot;0&quot; amplitude=&quot;{{shakeBeforeAmplitude}}&quot; maxDeviation=&quot;PT0S&quot; settleTime=&quot;PT0S&quot; /&gt;{{/if}} {{#if doSettleBefore}}&lt;WaitTime id=&quot;{{settleBeforeId}}&quot; timeSpan=&quot;{{settleBeforeTime}}&quot; maxDeviation=&quot;PT0S&quot; refTimeID=&quot;0&quot; ignoreInLastCycle=&quot;False&quot; /&gt;{{/if}} {{#if doMeasure}}&lt;MeasurementAbsorbance id=&quot;{{measureId}}&quot; mode=&quot;Normal&quot; type=&quot;&quot; name=&quot;ABS&quot; longname=&quot;&quot; description=&quot;&quot;&gt; &lt;Well id=&quot;6&quot; auto=&quot;true&quot;&gt; &lt;MeasurementReading id=&quot;7&quot; name=&quot;&quot; beamDiameter=&quot;{{beamDiameter}}&quot; beamGridType=&quot;{{beamGridType}}&quot; beamGridSize=&quot;{{beamGridSize}}&quot; beamEdgeDistance=&quot;{{beamEdgeDistance}}&quot;&gt; &lt;ReadingLabel id=&quot;8&quot; name=&quot;Label1&quot; scanType=&quot;{{scanType}}&quot; refID=&quot;0&quot;&gt; &lt;ReadingSettings number=&quot;25&quot; rate=&quot;25000&quot; /&gt; &lt;ReadingTime integrationTime=&quot;0&quot; lagTime=&quot;0&quot; readDelay=&quot;{{readDelay}}&quot; flash=&quot;0&quot; dark=&quot;0&quot; excitationTime=&quot;0&quot; /&gt; &lt;ReadingFilter id=&quot;0&quot; type=&quot;Ex&quot; wavelength=&quot;{{excitationWavelength}}&quot; bandwidth=&quot;{{excitationBandwidth}}&quot; attenuation=&quot;0&quot; usage=&quot;ABS&quot; /&gt; &lt;/ReadingLabel&gt; &lt;/MeasurementReading&gt; &lt;/Well&gt; &lt;/MeasurementAbsorbance&gt;{{/if}} &lt;/PlateRange&gt; &lt;/CyclePlate&gt; &lt;/MeasurementManualCycle&gt; &lt;MeasurementInfo id=&quot;0&quot; description=&quot;&quot;&gt; &lt;ScriptTemplateSettings id=&quot;0&quot;&gt; &lt;ScriptTemplateGeneralSettings id=&quot;0&quot; Title=&quot;&quot; Group=&quot;&quot; Info=&quot;&quot; Image=&quot;&quot; /&gt; &lt;ScriptTemplateDescriptionSettings id=&quot;0&quot; Internal=&quot;&quot; External=&quot;&quot; IsExternal=&quot;False&quot; /&gt; &lt;/ScriptTemplateSettings&gt; &lt;/MeasurementInfo&gt; &lt;/TecanMeasurement&gt; &lt;/TecanFile&gt;`; // TODO: continue working on this with the goal of allowing shaking in the reader const templateShake = `&lt;TecanFile xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;tecan.at.schema.documents Main.xsd&quot; fileformat=&quot;Tecan.At.Measurement&quot; fileversion=&quot;2.0&quot; xmlns=&quot;tecan.at.schema.documents&quot;&gt; &lt;FileInfo type=&quot;&quot; instrument=&quot;infinite 200Pro&quot; version=&quot;&quot; createdFrom=&quot;localadmin&quot; createdAt=&quot;{{createdAt}}&quot; createdWith=&quot;Tecan.At.XFluor.ReaderEditor.XFluorReaderEditor&quot; description=&quot;&quot; /&gt; &lt;TecanMeasurement id=&quot;1&quot; class=&quot;Measurement&quot;&gt; &lt;MeasurementManualCycle id=&quot;2&quot; number=&quot;1&quot; type=&quot;Standard&quot;&gt; &lt;CyclePlate id=&quot;3&quot; file=&quot;{{plateFile}}&quot; plateWithCover=&quot;{{plateWithCover}}&quot;&gt; &lt;PlateRange id=&quot;4&quot; range=&quot;{{wells}}&quot; auto=&quot;false&quot;&gt; {{#items}} &lt;Shaking id=&quot;{{id}}&quot; mode=&quot;Orbital&quot; time=&quot;{{time}}&quot; frequency=&quot;0&quot; amplitude=&quot;{{amplitude}}&quot; maxDeviation=&quot;PT0S&quot; settleTime=&quot;PT0S&quot; /&gt; {{/items}} &lt;/PlateRange&gt; &lt;/CyclePlate&gt; &lt;/MeasurementManualCycle&gt; &lt;MeasurementInfo id=&quot;0&quot; description=&quot;&quot;&gt; &lt;ScriptTemplateSettings id=&quot;0&quot;&gt; &lt;ScriptTemplateGeneralSettings id=&quot;0&quot; Title=&quot;&quot; Group=&quot;&quot; Info=&quot;&quot; Image=&quot;&quot; /&gt; &lt;ScriptTemplateDescriptionSettings id=&quot;0&quot; Internal=&quot;&quot; External=&quot;&quot; IsExternal=&quot;False&quot; /&gt; &lt;/ScriptTemplateSettings&gt; &lt;/MeasurementInfo&gt; &lt;/TecanMeasurement&gt; &lt;/TecanFile&gt;`; function locationRowColToText(row, col) { var colText = col.toString(); return String.fromCharCode(&quot;A&quot;.charCodeAt(0) + row - 1) + colText; } function getTemplateAbsorbanceParams(parsed, data) { const program = parsed.value.program || {}; const output = parsed.value.output || {}; // const labwareModelName = parsed.objectName[&quot;object.model&quot;]; const labwareModelName = parsed.value.object.model; // console.log({labwareModelName}) const labwareModel = _.get(data.objects, labwareModelName); // console.log({labwareModel}) const modelToPlateFile = parsed.value.equipment.modelToPlateFile; // assert(modelToPlateFile, `please define ${parsed.objectName.equipment}.modelToPlateFile`); expect.truthy({paramName: &quot;equipment&quot;}, modelToPlateFile, `please define ${parsed.objectName.equipment}.modelToPlateFile`); const plateFile = modelToPlateFile[labwareModelName]; // assert(plateFile, `please define ${parsed.objectName.equipment}.modelToPlateFile.&quot;${labwareModelName}&quot;`); expect.truthy({paramName: &quot;equipment&quot;}, plateFile, `please define ${parsed.objectName.equipment}.modelToPlateFile.&quot;${labwareModelName}&quot;`); let wells; const wells0 = (program.wells) ? commandHelper.asArray(program.wells) : (output.joinKey) ? commandHelper.getDesignFactor(output.joinKey, data.objects.DATA) : undefined; if (wells0) { // console.log({program}) // Get well list const wells1 = _.flatMap(wells0, s =&gt; wellsParser.parse(s, data.objects)); // console.log({wells0}) const rx = /\\(([^)]*)\\)/; const wells2 = wells1.map(s =&gt; { const match = s.match(rx); return (match) ? match[1] : s; }); // console.log({wells1}) const rowcols = wells2.map(s =&gt; wellsParser.locationTextToRowCol(s)); // console.log({rowcols}) // rowcols.sort(); rowcols.sort((a, b) =&gt; (a[0] == b[0]) ? a[1] - b[1] : a[0] - b[0]); // console.log({rowcols}) if (_.isEmpty(rowcols)) { wells = &quot;&quot;; } else { let prev = rowcols[0]; let indexOnPlatePrev = (prev[0] - 1) * labwareModel.columns + prev[1]; wells = locationRowColToText(prev[0], prev[1])+&quot;:&quot;; for (let i = 1; i &lt; rowcols.length; i++) { const rowcol = rowcols[i]; const indexOnPlate = (rowcol[0] - 1) * labwareModel.columns + rowcol[1]; // If continuity is broken or we've changed rows: // TODO: do something smarter than starting over on each row; // but it can be tricky, because the reader expects square blocks // of wells. if (indexOnPlate !== indexOnPlatePrev + 1 || rowcol[0] != prev[0]) { wells += locationRowColToText(prev[0], prev[1])+&quot;|&quot;+locationRowColToText(rowcol[0], rowcol[1])+&quot;:&quot;; } prev = rowcol; indexOnPlatePrev = indexOnPlate; } wells += locationRowColToText(prev[0], prev[1]); } } // If not specified, read all wells on plate else { wells = &quot;A1:&quot;+locationRowColToText(labwareModel.rows, labwareModel.columns); } // console.log({wells}) let isScan = false; let excitationWavelength; let excitationBandwidth; // This will normally be true if program data was passed to the absorbanceReader command, // but it may be empty if `programFileTemplate` was passed. if (program.excitationWavelength || program.excitationWavelengthMax) { isScan = (program.excitationWavelengthMin &amp;&amp; program.excitationWavelengthMax); if (isScan) { const excitationWavelengthMin = program.excitationWavelengthMin.toNumber(&quot;nm&quot;); const excitationWavelengthStep0 = program.excitationWavelengthStep || math.unit(2, &quot;nm&quot;); const excitationWavelengthStep = excitationWavelengthStep0.toNumber(&quot;nm&quot;); const excitationWavelengthMax0 = program.excitationWavelengthMax.toNumber(&quot;nm&quot;); const stepCount = Math.floor((excitationWavelengthMax0 - excitationWavelengthMin) / excitationWavelengthStep); const excitationWavelengthMax = excitationWavelengthMin + excitationWavelengthStep * stepCount; excitationWavelength = `${excitationWavelengthMin*10}~${excitationWavelengthMax*10}:${excitationWavelengthStep*10}`; } else { // console.log({program}) excitationWavelength = program.excitationWavelength.toNumber(&quot;nm&quot;) * 10; } const excitationBandwidth0 = program.excitationBandwidth || math.unit(9, &quot;nm&quot;); excitationBandwidth = excitationBandwidth0.toNumber(&quot;nm&quot;) * 10; } else { assert(parsed.value.programFileTemplate, &quot;You must supply either `program.excitationWavelength` or `programFileTemplate`&quot;); } const doMeasure = true; let nextId = 5; const shakeBeforeParams = (_.has(program, &quot;shakerProgramBefore.duration&quot;)) ? { doShakeBefore: true, shakeBeforeId: nextId++, shakeBeforeTime: &quot;PT&quot;+program.shakerProgramBefore.duration.toNumber(&quot;s&quot;)+&quot;S&quot;, shakeBeforeAmplitude: 4000 } : {}; const settleBeforeParams = (_.has(program, &quot;shakerProgramBefore.settleDuration&quot;)) ? { doSettleBefore: true, settleBeforeId: nextId++, settleBeforeTime: &quot;PT&quot;+program.shakerProgramBefore.settleDuration.toNumber(&quot;s&quot;)+&quot;S&quot;, shakeBeforeAmplitude: 4000 } : {}; const measureId = (doMeasure) ? nextId++ : null; const params = _.defaults( { //createdAt: moment().format(&quot;YYYY-MM-DDTHH:mm:ss.SSSSSSS&quot;)+&quot;Z&quot;, createdAt: &quot;2016-01-01T00:00:00.0000000Z&quot;, plateFile, plateWithCover: (parsed.value.object.isSealed || parsed.value.object.isCovered) ? &quot;True&quot; : &quot;False&quot;, wells, doMeasure, measureId, beamDiameter: (isScan) ? 0 : 500, beamGridType: &quot;Single&quot;, beamGridSize: (isScan) ? 0 : 1, beamEdgeDistance: (isScan) ? &quot;&quot; : &quot;auto&quot;, scanType: (isScan) ? &quot;ScanEX&quot; : &quot;ScanFixed&quot;, readDelay: (isScan) ? 0 : 10000, excitationWavelength, excitationBandwidth, }, shakeBeforeParams, settleBeforeParams ); // console.log({params, excitationWavelength0, excitationWavelength, excitationBandwidth0, excitationBandwidth}); return params; } /** * @typedef ReaderInfiniteM200ProConfig * @type {object} * @property {!string} evowareId - the Evoware ID of this equipment * @property {!string} evowareCarrier - the carrier that the equipment is on * @property {!string} evowareGrid - the grid that the equipment is on * @property {!number} evowareSite - the evoware site index of the equipment site * @param {!string} site - the equipment's site name (just the base part, without namespace) * @param {!Object.&lt;string, string&gt;} modelToPlateFile - a map from labware model to equipment's plate filename * @example * ``` * evowareId: &quot;ReaderNETwork&quot;, * evowareCarrier: &quot;Infinite M200&quot;, * evowareGrid: 61, * evowareSite: 1, * site: &quot;READER&quot;, * modelToPlateFile: { * &quot;plateModel_96_round_transparent_nunc&quot;: &quot;NUN96ft&quot;, * &quot;plateModel_384_square&quot;: &quot;GRE384fw&quot;, * &quot;EK_384_greiner_flat_bottom&quot;: &quot;GRE384fw&quot;, * &quot;EK_96_well_Greiner_Black&quot;: &quot;GRE96fb_chimney&quot; * } * ``` */ function configure(config, equipmentName, params) { const agent = config.getAgentName(); const equipment = config.getEquipmentName(equipmentName); const site = config.getSiteName(params.site); const objects = {}; // Add equipment _.set(objects, equipment, { type: &quot;Reader&quot;, evowareId: params.evowareId, sitesInternal: [site], modelToPlateFile: _.fromPairs(_.map(_.toPairs(params.modelToPlateFile), ([model0, file]) =&gt; [config.getModelName(model0), file])) }); // Add site _.set(objects, site, { type: &quot;Site&quot;, evowareCarrier: params.evowareCarrier, evowareGrid: params.evowareGrid, evowareSite: params.evowareSite, closed: true }); const predicates = _.flatten([ _.flatten(_.map(Object.keys(params.modelToPlateFile), model0 =&gt; [ { &quot;absorbanceReader.canAgentEquipmentModelSite&quot;: { agent, equipment, model: config.getModelName(model0), site } }, { &quot;fluorescenceReader.canAgentEquipmentModelSite&quot;: { agent, equipment, model: config.getModelName(model0), site } }, ])), /*{ &quot;shaker.canAgentEquipmentSite&quot;: { agent, equipment, site } },*/ ]); predicates.push(...exports.getPredicates(agent, equipment, site)); // console.log({planHandlers: exports.getPlanHandlers(agent, equipment, site)}) const protocol = { schemas: exports.getSchemas(agent, equipment), objects, predicates, planHandlers: exports.getPlanHandlers(agent, equipment, site), commandHandlers: exports.getCommandHandlers(agent, equipment), }; return protocol; } const exports = { getSchemas: (agentName, equipmentName) =&gt; ({ [`equipment.close|${agentName}|${equipmentName}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, }, required: [&quot;agent&quot;, &quot;equipment&quot;] }, [`equipment.open|${agentName}|${equipmentName}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, }, required: [&quot;agent&quot;, &quot;equipment&quot;] }, [`equipment.openSite|${agentName}|${equipmentName}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, site: {description: &quot;Site identifier&quot;, type: &quot;Site&quot;} }, required: [&quot;agent&quot;, &quot;equipment&quot;, &quot;site&quot;] }, [`equipment.run|${agentName}|${equipmentName}`]: { description: &quot;Run measurement on Infinite M200 Pro reader&quot;, properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, measurementType: {description: &quot;Type of measurement, i.e fluorescence or absorbance&quot;, enum: [&quot;fluorescence&quot;, &quot;absorbance&quot;]}, program: { description: &quot;Program definition&quot;, properties: { shakerProgramBefore: { description: &quot;Program for shaker.&quot;, properties: { rpm: {description: &quot;Rotations per minute (RPM)&quot;, type: &quot;number&quot;}, duration: {description: &quot;Duration of shaking&quot;, type: &quot;Duration&quot;}, settleDuration: {description: &quot;Duration to settle after shaking&quot;, type: &quot;Duration&quot;} } }, wells: {description: &quot;Array of wells to read&quot;, type: &quot;Wells&quot;}, excitationWavelength: {description: &quot;Excitation wavelength&quot;, type: &quot;Length&quot;}, excitationBandwidth: {description: &quot;Excitation bandwidth&quot;, type: &quot;Length&quot;}, excitationWavelengthMin: {description: &quot;Minimum excitation wavelength for a scan&quot;, type: &quot;Length&quot;}, excitationWavelengthMax: {description: &quot;Maximum excitation wavelength for a scan&quot;, type: &quot;Length&quot;}, excitationWavelengthStep: {description: &quot;Size of steps for a scan&quot;, type: &quot;Length&quot;} } }, programFileTemplate: {description: &quot;Program template; well information will be substituted into the template automatically.&quot;, type: &quot;File&quot;}, programFile: {description: &quot;Program filename&quot;, type: &quot;File&quot;}, programData: {description: &quot;Program data&quot;}, object: {description: &quot;The labware being measured&quot;, type: &quot;Plate&quot;}, output: { description: &quot;Output definition for where and how to save the measurements&quot;, properties: { joinKey: {description: &quot;The key used to left-join the measurement values with the current DATA&quot;, type: &quot;string&quot;}, writeTo: {description: &quot;Filename to write measurements to as JSON&quot;, type: &quot;string&quot;}, appendTo: {description: &quot;Filename to append measurements to as newline-delimited JSON&quot;, type: &quot;string&quot;}, userValues: {description: &quot;User-specificed values that should be included in the output table&quot;, type: &quot;object&quot;}, simulated: {description: &quot;An expression to evaluate with mathjs&quot;, type: &quot;string&quot;}, units: {description: &quot;Map of factor names to unit type; converts the factor values to plain numbers in the given units.&quot;} } } }, required: [&quot;measurementType&quot;] }, // [`shaker.run|${agentName}|${equipmentName}`]: { // properties: { // agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, // equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, // program: { // description: &quot;Program for shaking&quot;, // properties: { // amplitude: {description: &quot;Amplitude&quot;, enum: [&quot;min&quot;, &quot;low&quot;, &quot;high&quot;, &quot;max&quot;]}, // duration: {description: &quot;Duration of shaking&quot;, type: &quot;Duration&quot;} // }, // required: [&quot;duration&quot;] // } // }, // required: [&quot;agent&quot;, &quot;equipment&quot;, &quot;program&quot;] // }, }), getCommandHandlers: (agentName, equipmentName) =&gt; ({ // Reader [`equipment.close|${agentName}|${equipmentName}`]: function(params, parsed, data) { return {expansion: [makeEvowareFacts(parsed, data, &quot;Close&quot;)]}; }, [`equipment.open|${agentName}|${equipmentName}`]: function(params, parsed, data) { return {expansion: [makeEvowareFacts(parsed, data, &quot;Open&quot;)]}; }, [`equipment.openSite|${agentName}|${equipmentName}`]: function(params, parsed, data) { var carrier = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); var sitesInternal = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;sitesInternal&quot;); var siteIndex = sitesInternal.indexOf(parsed.objectName.site); expect.truthy({paramName: &quot;site&quot;}, siteIndex &gt;= 0, &quot;site must be one of the equipments internal sites: &quot;+sitesInternal.join(&quot;, &quot;)); return {expansion: [makeEvowareFacts(parsed, data, &quot;Open&quot;)]}; }, [`equipment.run|${agentName}|${equipmentName}`]: function(params, parsed, data) { // console.log(&quot;reader-InfiniteM200Pro-equipment.run: &quot;+JSON.stringify(parsed, null, '\\t')); const hasProgram = (parsed.value.program) ? 1 : 0; const hasProgramFile = (parsed.value.programFile) ? 1 : 0; const hasProgramData = (parsed.value.programData) ? 1 : 0; expect.truthy({}, hasProgram + hasProgramFile + hasProgramData &gt;= 1, &quot;either `program`, `programFile` or `programData` must be specified.&quot;); expect.truthy({}, hasProgram + hasProgramFile + hasProgramData &lt;= 1, &quot;only one of `program`, `programFile` or `programData` may be specified.&quot;); let content = (hasProgramData) ? parsed.value.programData.toString('utf8') : (hasProgramFile) ? parsed.value.programFile.toString('utf8') : (!_.isEmpty(parsed.value.programFileTemplate)) ? parsed.value.programFileTemplate.toString('utf8') : undefined; // If program: // if hasProgramFile: take programFile as template and modify it for substituting in wells and whatnot // otherwise use the template // do substitutions if (hasProgram) { // If programFile is not supplied, use the default template: if (_.isUndefined(content)) { assert(parsed.value.measurementType === &quot;absorbance&quot;, &quot;MISSING FUNCTIONALITY: programmer needs to supply template for fluorescence programs&quot;); content = templateAbsorbance; } // Otherwise, modify the programFile/programData to allow for substitutions: else { // substitute the wells into the program file if (!_.isEmpty(parsed.value.program.wells) || !_.isEmpty(parsed.value.output.joinKey)) { content = content.replace(/&lt;PlateRange id=&quot;(\\d+)&quot; range=&quot;[^&quot;]+&quot;/, '&lt;PlateRange id=&quot;$1&quot; range=&quot;{{wells}}&quot;'); } } assert(!_.isEmpty(content), &quot;Program content is empty&quot;); // Substitute in relevant values: const templateParams = getTemplateAbsorbanceParams(parsed, data); const template = Handlebars.compile(content); content = template(templateParams); } var start_i = content.indexOf(&quot;&lt;TecanFile&quot;); if (start_i &lt; 0) start_i = 0; var programData = content.substring(start_i). replace(/[\\r\\n]/g, &quot;&quot;). replace(/&amp;/g, &quot;&amp;amp;&quot;). // &quot;&amp;amp;&quot; is probably not needed, since I didn't find it in the XML files replace(/=/g, &quot;&amp;equal;&quot;). replace(/&quot;/g, &quot;&amp;quote;&quot;). replace(/~/, &quot;&amp;tilde;&quot;). replace(/&gt;[ \\t]+&lt;/g, &quot;&gt;&lt;&quot;); // Save the file to the agent-configured TEMPDIR, if no absolute path is given const writeTo = _.get(parsed.value, &quot;output.writeTo&quot;) || parsed.value.outputFile; const outputFile0 = (writeTo) ? path.join(path.dirname(writeTo), path.basename(writeTo, &quot;.xml&quot;) + &quot;.xml&quot;) : parsed.value.measurementType+&quot;.xml&quot;; const outputFile = (path.win32.isAbsolute(outputFile0)) ? outputFile0 : &quot;%{TEMPDIR}\\\\&quot; + path.win32.basename(outputFile0); const value = outputFile + &quot;|&quot; + programData; const args = [&quot;TecanInfinite&quot;, &quot;%{SCRIPTFILE}&quot;, data.path.join(&quot;.&quot;), outputFile]; const expansion = [ makeEvowareFacts(parsed, data, &quot;Measure&quot;, value, parsed.objectName.object), makeEvowareExecute(parsed.objectName.agent, &quot;%{ROBOLIQ}&quot;, args, true) ]; return { expansion, reports: (_.isEmpty(data.objects.DATA)) ? undefined : { measurementFactors: data.objects.DATA } }; }, // [`shaker.run|${agentName}|${equipmentName}`]: function(params, parsed, data) { }), getPredicates: (agentName, equipmentName, siteName) =&gt; [ // Open READER {&quot;method&quot;: {&quot;description&quot;: `generic.openSite-${siteName}`, &quot;task&quot;: {&quot;generic.openSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [{&quot;same&quot;: {&quot;thing1&quot;: &quot;?site&quot;, &quot;thing2&quot;: siteName}}], &quot;subtasks&quot;: {&quot;ordered&quot;: [{[`${equipmentName}.open`]: {}}]} }}, {&quot;action&quot;: {&quot;description&quot;: `${equipmentName}.open: open the reader`, &quot;task&quot;: {[`${equipmentName}.open`]: {}}, &quot;preconditions&quot;: [], &quot;deletions&quot;: [{&quot;siteIsClosed&quot;: {&quot;site&quot;: siteName}}], &quot;additions&quot;: [] }}, // Close READER {&quot;method&quot;: {&quot;description&quot;: `generic.closeSite-${siteName}`, &quot;task&quot;: {&quot;generic.closeSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [{&quot;same&quot;: {&quot;thing1&quot;: &quot;?site&quot;, &quot;thing2&quot;: siteName}}], &quot;subtasks&quot;: {&quot;ordered&quot;: [{[`${equipmentName}.close`]: {}}]} }}, {&quot;action&quot;: {&quot;description&quot;: `${equipmentName}.close: close the reader`, &quot;task&quot;: {[`${equipmentName}.close`]: {}}, &quot;preconditions&quot;: [], &quot;deletions&quot;: [], &quot;additions&quot;: [ {&quot;siteIsClosed&quot;: {&quot;site&quot;: siteName}} ] }}, ], getPlanHandlers: (agentName, equipmentName, siteName) =&gt; ({ [`${equipmentName}.close`]: function(params, parentParams, data) { return [{ command: &quot;equipment.close&quot;, agent: agentName, equipment: equipmentName }]; }, [`${equipmentName}.open`]: function(params, parentParams, data) { return [{ command: &quot;equipment.openSite&quot;, agent: agentName, equipment: equipmentName, site: siteName }]; }, }) }; module.exports = _.merge({configure}, exports); × Search results Close "},"equipment_shaker-Tecan1.js.html":{"id":"equipment_shaker-Tecan1.js.html","title":"Source: equipment/shaker-Tecan1.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: equipment/shaker-Tecan1.js /** * Module for a 1-site Tecan shaker. * @module */ const _ = require('lodash'); const assert = require('assert'); const math = require('mathjs'); const commandHelper = require('roboliq-processor/dist/commandHelper.js'); const expect = require('roboliq-processor/dist/expect.js'); /** * @typedef ShakerTecan1Params * @type {object} * @property {!string} evowareId - the Evoware ID of this equipment * @property {?string} evowareGrid - the grid that the equipment is on * @param {!string} site - the equipment's site name (just the base part, without namespace) * ``` * evowareId: &quot;HPShaker&quot;, * site: &quot;P3&quot; * ``` */ /** * Configure the Tecan 1-site shaker * @param {ShakerTecan1Params} params - parameters for the configuration * @return {EquipmentConfig} */ function configure(config, equipmentName, params) { const agent = config.getAgentName(); const equipment = config.getEquipmentName(equipmentName); const siteName = config.getSiteName(params.site); const objects = {}; _.set(objects, equipment, { type: &quot;Shaker&quot;, evowareId: params.evowareId }); const predicates = [ { &quot;shaker.canAgentEquipmentSite&quot;: { agent, equipment, site: siteName } }, ]; // console.log(&quot;shaker.predicates: &quot;+JSON.stringify(predicates, null, '\\t')); const schemas = { [`shaker.run|${agent}|${equipment}`]: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: { description: &quot;Program for shaking&quot;, properties: { rpm: {description: &quot;Rotations per minute (RPM)&quot;, type: &quot;number&quot;}, duration: {description: &quot;Duration of shaking&quot;, type: &quot;Duration&quot;} }, required: [&quot;duration&quot;] }, object: {description: &quot;Plate identifier (optional)&quot;, type: &quot;Plate&quot;} }, required: [&quot;agent&quot;, &quot;equipment&quot;, &quot;program&quot;] } }; const commandHandlers = { [`shaker.run|${agent}|${equipment}`]: function(params, parsed, data) { //console.log(&quot;equipment.run|ourlab.mario.evoware|ourlab.mario.shaker: &quot;+JSON.stringify(parsed, null, '\\t')) const equipmentId = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); const rpm = parsed.value.program.rpm || 750; // Construct the shaker program data const shakerNo = 1; // FIXME: Let the user specify mode1, steps1, mode2, steps2, power const mode1 = 2; const steps1 = 0; const mode2 = 1; const steps2 = 0; const freq = (60000000/rpm).toFixed(0); const cycles = Math.floor(rpm * parsed.value.program.duration.toNumber(&quot;minute&quot;)).toFixed(0); const powerPerc = 50; const power = Math.floor(255 * powerPerc / 100).toFixed(0); const s0 = `*27${shakerNo}|${freq}|${mode1}|${steps1}|${mode2}|${steps2}|${cycles}|${power}*27`; // Replace all occurences of '0' with &quot;*30&quot; const s1 = s0.replace(/0/g, &quot;*30&quot;); // Finally, split string into 32 char parts, then rebind them, separated by commas const s2 = _(s1).chunk(32).map(s =&gt; s.join(&quot;&quot;)).join(&quot;,&quot;); return { expansion: [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_HP__Start&quot;, factsValue: s2 }, { command: &quot;timer.sleep&quot;, agent: parsed.objectName.agent, duration: parsed.orig.program.duration }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_HP__Stop&quot;, factsValue: &quot;1&quot; }, ] }; }, }; const protocol = { objects, predicates, schemas, commandHandlers }; return protocol; } module.exports = { configure }; × Search results Close "},"EvowareCarrierFile.js.html":{"id":"EvowareCarrierFile.js.html","title":"Source: EvowareCarrierFile.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: EvowareCarrierFile.js /** * Loads data from an Evoware carrier file. * @module */ import _ from 'lodash'; import assert from 'assert'; //import fs from 'fs'; //import iconv from 'iconv-lite'; import {sprintf} from 'sprintf-js'; import * as EvowareUtils from './EvowareUtils.js'; /** * Tuple for location refered to by carrier+grid+site indexes * @class module:evoware/EvowareCarrierFile.CarrierGridSiteIndex * @property {integer} carrierId - ID for the carrier * @property {integer} gridIndex - 1-based index of grid * @property {integer} siteIndex - 0-based index of site */ export class CarrierGridSiteIndex { constructor(carrierId, gridIndex, siteIndex) { this.carrierId = carrierId; this.gridIndex = gridIndex; this.siteIndex = siteIndex; } } /** * Tuple for location refered to by carrier+site index * @class module:evoware/EvowareCarrierFile.CarrierSiteIndex * @property {integer} carrierId - ID for the carrier * @property {integer} siteIndex - 0-based index of site */ export class CarrierSiteIndex { constructor(carrierId, siteIndex) { this.carrierId = carrierId; this.siteIndex = siteIndex; } } /** * A base type for evoware models, one of Carrier, LabwareModel, or Vector. * @typedef {object} EvowareModel * @property {string} type - the type of model */ /** * A Carrier object * @class module:evoware/EvowareCarrierFile.Carrier * @property {string} type - should be &quot;Carrier&quot; * @property {string} name * @property {integer} id * @property {integer} siteCount * @property {string} [deviceName] * @property {string} [partNo] * @property {array} [vectors] - array of vector names for this carrier */ export class Carrier { constructor(name, id, siteCount, deviceName, partNo) { this.type = &quot;Carrier&quot;; this.name = name; this.id = id; this.siteCount = siteCount; this.deviceName = deviceName; this.partNo = partNo; this.vectors = []; } } /** * An evoware labware model * @class module:evoware/EvowareCarrierFile.LabwareModel * @property {string} type - should be &quot;LabwareModel&quot; * @property {string} name * @property {integer} rows * @property {integer} cols * @property {number} ul - maximum volume of wells * @property {array} sites - list of CarrierSiteIndexes where this labware can be placed. */ export class LabwareModel { constructor(name, rows, cols, ul, sites) { this.type = &quot;LabwareModel&quot;; this.name = name; this.rows = rows; this.cols = cols; this.ul = ul; this.sites = sites; } } /** * A tranporter &quot;vector&quot;, related to movements that the RoMas can make * @class module:evoware/EvowareCarrierFile.Vector * @property {string} type - should be &quot;Vector&quot; * @property {integer} carrierId - which carrier this vector is for * @property {string} clazz - Wide, Narrow, or user-defined * @property {integer} romaId - which RoMa this vector is for */ export class Vector { constructor(carrierId, clazz, romaId) { this.type = &quot;Vector&quot;; this.carrierId = carrierId; this.clazz = clazz; this.romaId = romaId; } } /** * An object representing an evoware carrier file * * @class module:evoware/EvowareCarrierFile.EvowareCarrierData * @property {object} models - map from model name to model data * @property {object} idToName - map of model ID to model name * @property {object} carrierIdToVectors - map of carrier ID to list of Vectors */ export class EvowareCarrierData { constructor(carrierModels, labwareModels) { this.carrierModels = carrierModels; this.labwareModels = labwareModels; this.carrierIdToName = _(carrierModels).map(x =&gt; [x.id, x.name]).fromPairs().value(); this.labwareIdToName = _(labwareModels).map(x =&gt; [x.id, x.name]).fromPairs().value(); } getCarrierByName(carrierName) { return this.carrierModels[carrierName]; } getCarrierById(id) { const name = this.carrierIdToName[id]; return this.carrierModels[name]; } /** * Print debug output: carrier id, carrier name. */ printCarriersById() { const l0 = _(this.carrierModels).map(model =&gt; [model.id, model.name]).value(); const l = _.sortBy(l0, x =&gt; x[0]); //console.log({l}) l.forEach(([id, name]) =&gt; { console.log(sprintf(&quot;%03d\\t%s&quot;, id, name)); }); } } /* case class CarrierSite( carrier: Carrier, iSite: Int ) */ /** * Load an evoware carrier file and return its model data. * @param {string} filename - path to the carrier file * @return {EvowareCarrierData} */ export function load(filename) { const modelList = loadEvowareModels(filename); const data = makeEvowareCarrierData(modelList); //console.log({data}); return data; } /** * Create an EvowareCarrierData object from an array of evoware models. * @param {array} modelList - array of evoware models * @return {EvowareCarrierData} */ function makeEvowareCarrierData(modelList) { // Create maps/lists for the various model types const carrierModels = {}; const labwareModels = {}; const vectors = []; _.forEach(modelList, model =&gt; { if (model.type === &quot;Carrier&quot;) carrierModels[model.name] = model; else if (model.type === &quot;LabwareModel&quot;) labwareModels[model.name] = model; else vectors.push(model); }); // Create map from ID to name const idToName = _(carrierModels).filter(x =&gt; x.type === &quot;Carrier&quot;).map(model =&gt; [model.id, model.name]).fromPairs().value(); // Add vectors to carriers const carrierIdToVectors = _.groupBy(vectors, 'carrierId'); _.forEach(carrierIdToVectors, (vectors, carrierId) =&gt; { const carrierName = idToName[carrierId]; const carrier = carrierModels[carrierName]; carrier.vectors = vectors.map(x =&gt; x.name); }); //console.log({modelList, models, idToName, carrierIdToVectors}) return new EvowareCarrierData( carrierModels, labwareModels ); } /** * Parses the file `Carrier.cfg` into a list of `EvowareModels`. * @param {string} filename - path to the carrier file * @return {array} an array of EvowareModels (e.g. Carriers, Vectors, EvowareLabwareModels) */ function loadEvowareModels(filename) { const models = []; const lines = new EvowareUtils.EvowareSemicolonFile(filename, 4); // Find models in the carrier file while (lines.hasNext()) { const model = parseModel(lines); //console.log({model}) if (!_.isUndefined(model)) models.push(model) //assert(lineIndex2 &gt; lineIndex); //console.log({lineIndex2}) } return models; } /** * Parse the line and return a model, if relevant. * @param {EvowareSemicolonFile} lines - array of lines from the Carrier.cfg * @return {array} an optional model. */ function parseModel(lines) { const [lineKind, l] = lines.nextSplit(); //console.log({lineKind, l}) switch (lineKind) { case 13: return parse13(l, lines); case 15: return parse15(l, lines); case 17: return parse17(l, lines); // NOTE: There are also 23 and 25 lines, but I don't know what they're for. default: return undefined; } } /** * Parse a carrier object; carrier lines begin with &quot;13&quot; * * @param {array} l - array of string representing the elements of the current line * @param {EvowareSemicolonFile} lines - array of lines from the Carrier.cfg * @return {Carrier} a Carrier. */ function parse13(l, lines) { const sName = l[0]; const l1 = l[1].split(&quot;/&quot;); const sId = l1[0]; //val sBarcode = l1(1) const id = parseInt(sId); const nSites = parseInt(l[4]); const deviceNameList = parse998(lines.peekAhead(nSites + 1)); const deviceName = (deviceNameList.length != 1) ? undefined : deviceNameList[0]; const partNoList = parse998(lines.peekAhead(nSites + 3)); const partNo = (partNoList.length != 1) ? undefined : partNoList[0]; lines.skip(nSites + 6); return new Carrier(sName, id, nSites, deviceName, partNo); } /** * Parse a labware object; labware lines begin with &quot;15&quot; * * @param {array} l - array of string representing the elements of the current line * @param {EvowareSemicolonFile} lines - array of lines from the Carrier.cfg * @return {LabwareModel} a new LabwareModel. */ function parse15(l, lines) { const sName = l[0]; const ls2 = l[2].split(&quot;/&quot;); const nCols = parseInt(ls2[0]); const nRows = parseInt(ls2[1]); //const nCompartments = ls2(2).toInt const ls4 = l[4].split(&quot;/&quot;) const zBottom = parseInt(ls4[0]); const zDispense = parseInt(ls4[2]); const nArea = Number(l[5]); // mm^2 const nDepthOfBottom = Number(l[15]); // mm //const nTipsPerWell = l(6).toDouble //const nDepth = l(15).toDouble // mm const nCarriers = parseInt(l[20]); // shape: flat, round, v-shaped (if nDepth == 0, then flat, if &gt; 0 then v-shaped, if &lt; 0 then round // labware can have lid // negative values for rounded bottom, positive for cone, 0 for flat const [nDepthOfCone, nDepthOfRound] = (nDepthOfBottom &gt; 0) ? [nDepthOfBottom, 0.0] : [0.0, -nDepthOfBottom]; const r = Math.sqrt(nArea / Math.PI); // Calculate the volume in microliters const ul = ((zBottom - zDispense) / 10.0 - nDepthOfCone - nDepthOfRound) * nArea + // Volume of a cone: (1/3)*area*height (nDepthOfCone * nArea / 3) + // Volume of a half-sphere: ((4.0 / 6.0) * Math.PI * r * r * r); const lsCarrier = lines.take(nCarriers); const sites = _.flatten(lsCarrier.map(s =&gt; { const ls = parse998(s); // split line, but drop the &quot;998&quot; prefix const idCarrier = parseInt(ls[0]); const sitemask = ls[1]; const [, , site_li] = EvowareUtils.parseEncodedIndexes(sitemask); //console.log({sitemask, site_li}) return site_li.map(site_i =&gt; new CarrierSiteIndex(idCarrier, site_i)); })); lines.skip(10); return new LabwareModel(sName, nRows, nCols, ul, sites); } /** * Parse a vector object; vector lines begin with &quot;17&quot; * * @param {array} l - array of string representing the elements of the current line * @param {EvowareSemicolonFile} lines - array of lines from the Carrier.cfg * @return {Vector} a new Vector, if any */ function parse17(l, lines) { //println(&quot;parse17: &quot;+l.toList) const l0 = l[0].split(&quot;_&quot;); if (l0.length &lt; 3) return undefined; const sClass = l0[1]; const iRoma = parseInt(l0[2]) - 1; const nSteps = parseInt(l[3]); const idCarrier = parseInt(l[4]); const model = (nSteps &gt; 2) ? new Vector(idCarrier, sClass, iRoma) : undefined; lines.skip(nSteps); return model; } /** * Parse a line with the expected lineType=998. Discards the linetype and just returns a list of strings elements. * @param {string} s - the line * @return {array} array of line elements */ function parse998(s) { const [lineType, l] = EvowareUtils.splitSemicolons(s); assert(lineType === 998); return _.initial(l); } × Search results Close "},"EvowareTableFile.js.html":{"id":"EvowareTableFile.js.html","title":"Source: EvowareTableFile.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: EvowareTableFile.js /** * Module to load and save Evoware table files. * * @module */ import _ from 'lodash'; import assert from 'assert'; //import {sprintf} from 'sprintf-js'; import * as EvowareUtils from './EvowareUtils.js'; import * as EvowareCarrierFile from './EvowareCarrierFile.js'; import M from './Medley.js'; /** * Represent a hotel object in an Evoware table file * @class module:evoware/EvowareTableFile.HotelObject * @param {integer} parentCarrierId - carrier ID for the carrier holding this hotel * @param {integer} gridIndex - grid index of the hotel */ export class HotelObject { constructor(parentCarrierId, gridIndex) { this.parentCarrierId = parentCarrierId; this.gridIndex = gridIndex; } } /** * Represent an external object in an Evoware table file * @class module:evoware/EvowareTableFile.ExternalObject * @param {integer} n1 - Value of unknown significance (4 for System, 0 for others?) * @param {integer} n2 - I think this is the on-screen display index * @param {string} carrierName - carrier name for the carrier holding this hotel/object */ export class ExternalObject { constructor(n1, n2, carrierName) { this.n1 = n1; this.n2 = n2; this.carrierName = carrierName; } } /** * Parses an Evoware `.esc` script file, extracting the table setup. * @param {EvowareCarrierData} carrierData * @param {string} filename * @return {object} a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} */ export function load(carrierData, filename) { const lines = new EvowareUtils.EvowareSemicolonFile(filename, 7); lines.next() // TODO: should we check whether this is equal to &quot;--{ RPG }--&quot;? //println(lsLine.takeWhile(_ != &quot;--{ RPG }--&quot;).length) const [, l] = lines.nextSplit(); lines.skip(0); const tableFile = parse14(carrierData, l, lines); //println(&quot;parseFile: &quot;+rest.takeWhile(_ != &quot;--{ RPG }--&quot;)) return tableFile; } /** * Parse a table. * * @param {EvowareCarrierData} carrierData * @param {array} l - array of string representing the elements of the current line * @param {EvowareSemicolonFile} lines - array of lines from the Carrier.cfg * @return {object} a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} */ function parse14(carrierData, l, lines) { //import configFile._ const carrierIdsInternal = parse14_getCarrierIds(_.initial(l)); //console.log(&quot;carrierIdsInternal: &quot;+JSON.stringify(carrierIdsInternal)); const internalObjects = parse14_getLabwareObjects(carrierData, carrierIdsInternal, lines); //console.log(&quot;internalObjects: &quot;+JSON.stringify(internalObjects)); const hotelObjects = parse14_getHotelObjects(lines); const externalObjects = parse14_getExternalObjects(lines); const externalSiteIdToLabwareModelName = parse14_getExternalLabwares(lines); const externalCarrierNameToGridIndexList = parse14_getExternalCarrierGrids(externalObjects, lines); // FIXME: for debug only //const gridToCarrierIdInternal = _(carrierIdsInternal).map((id, index) =&gt; [index.toString(), id]).filter(([, id]) =&gt; id &gt; -1).fromPairs().value(); //console.log(&quot;gridToCarrierIdInternal: &quot;+JSON.stringify(gridToCarrierIdInternal)); // ENDFIX function set(carrierName, gridIndex, siteIndex, propertyName, propertyValue) { const c = _.get(layout, carrierName, {}); if (_.isUndefined(gridIndex)) { M.setMut(c, propertyName, propertyValue); } else { const g = _.get(c, gridIndex, {}); if (_.isUndefined(siteIndex)) { M.setMut(g, propertyName, propertyValue); } else { const s = _.get(g, siteIndex, {}); M.setMut(s, propertyName, propertyValue); M.setMut(g, siteIndex, s); } M.setMut(c, gridIndex, g); } M.setMut(layout, carrierName, c); } // Get list of all carriers on the table const carrierAndGridList = []; // Internal carriers carrierIdsInternal.forEach((carrierId, gridIndex) =&gt; { if (carrierId &gt; -1) { const carrier = carrierData.getCarrierById(carrierId); carrierAndGridList.push([carrier.name, gridIndex, &quot;internal&quot;, true]); } }); // Hotel carriers hotelObjects.forEach(o =&gt; { const carrier = carrierData.getCarrierById(o.parentCarrierId); carrierAndGridList.push([carrier.name, o.gridIndex, &quot;hotel&quot;, true]); }); // External objects externalObjects.forEach((external, i) =&gt; { const [carrierName, gridIndex] = externalCarrierNameToGridIndexList[i]; carrierAndGridList.push([carrierName, gridIndex, &quot;external&quot;, _.pick(external, 'n1', 'n2')]); }); // Sort the list by gridIndex const carrierAndGridList1 = _.sortBy(carrierAndGridList, l =&gt; l[1]); //console.log(JSON.stringify(carrierAndGridList1, null, '\\t')); // Populate the carrier/grid layout information in gridIndex-order const layout = {}; carrierAndGridList1.forEach(([carrierName, gridIndex, propertyName, propertyValue]) =&gt; { set(carrierName, gridIndex, undefined, propertyName, propertyValue); }); // Add to layout the internal site labels and labware internalObjects.forEach(([carrierName, gridIndex, siteIndex, label, labwareModelName]) =&gt; { if (!_.isEmpty(label)) set(carrierName, gridIndex, siteIndex, 'label', label); set(carrierName, gridIndex, siteIndex, 'labwareModelName', labwareModelName); }); // Add to layout the external site labware externalSiteIdToLabwareModelName.forEach(([carrierId, labwareModelName]) =&gt; { const carrier = carrierData.getCarrierById(carrierId); const result = _.find(externalCarrierNameToGridIndexList, ([carrierName,]) =&gt; carrierName === carrier.name); assert(!_.isUndefined(result)); const [, gridIndex] = result; set(carrier.name, gridIndex, 1, 'labwareModelName', labwareModelName); }); return layout; } /** * Extract array where the array index is the grid index and the value is the carrier ID. * This information is on the first line of the table definition. * A -1 value for the carrier ID means that there is no carrier at that grid. * @param {array} l - elements of line * @return {array} array of carrier IDs on this table */ function parse14_getCarrierIds(l) { return l.map(s =&gt; parseInt(s)); } /** * Get array of labwares on the table. * @param {EvowareCarrierData} carrierData * @param {EvowareSemicolonFile} lines - lines of table file * @return {array} an array of tuples (carrier name, gridIndex, siteIndex, site label, labware model name) */ function parse14_getLabwareObjects(carrierData, carrierIdsInternal, lines) { const result = []; carrierIdsInternal.forEach((carrierId, gridIndex) =&gt; { if (carrierId &gt; -1) { const carrier = carrierData.getCarrierById(carrierId); const [n0, l0] = lines.nextSplit(); const [n1, l1] = lines.nextSplit(); //console.log({n0, l0, n1, l1, carrierId, carrierName: carrierData.carrierIdToName[carrierId], carrier}) assert(n0 === 998 &amp;&amp; n1 === 998 &amp;&amp; parseInt(l0[0]) === carrier.siteCount); //println(iGrid+&quot;: &quot;+carrier) _.times(carrier.siteCount, siteIndex =&gt; { const labwareModelName = l0[siteIndex+1]; if (!_.isEmpty(labwareModelName)) { const item = [carrier.name, gridIndex, siteIndex+1, l1[siteIndex], labwareModelName]; result.push(item); } }); } else { lines.skip(1); } }); return result; } /** * Parse the hotel objects * @param {EvowareSemicolonFile} lines - lines of table file * @return {array} an array of HotelObjects */ function parse14_getHotelObjects(lines) { const [n0, l0] = lines.nextSplit(); assert(n0 === 998); const count = parseInt(l0[0]); return _.times(count, () =&gt; { const [n, l] = lines.nextSplit(); assert(n == 998); const id = parseInt(l[0]); const iGrid = parseInt(l[1]); return new HotelObject(id, iGrid); }); } /** * Parse the external objects. * @param {EvowareSemicolonFile} lines - lines of table file * @return {array} an array of external objects */ function parse14_getExternalObjects(lines) { const [n0, l0] = lines.nextSplit(); assert(n0 === 998); const count = parseInt(l0[0]); return _.times(count, () =&gt; { const [n, l] = lines.nextSplit(); assert(n == 998); const n1 = parseInt(l[0]); const n2 = parseInt(l[1]); const carrierName = l[2]; return new ExternalObject(n1, n2, carrierName); }); } /** * Parse labware on external sites * @param {EvowareSemicolonFile} lines - lines of table file * @return {object} list of tuples (carrier ID, labware model name) */ function parse14_getExternalLabwares(lines) { const [n0, l0] = lines.nextSplit(); assert(n0 === 998); const count = parseInt(l0[0]); return _.times(count, i =&gt; { const [n, l] = lines.nextSplit(); assert(n == 998); const carrierId = parseInt(l[0]); const labwareModelName = l[1]; return [carrierId, labwareModelName]; }); } function parse14_getExternalCarrierGrids(externalObjects, lines) { return externalObjects.map(external =&gt; { const [n, l] = lines.nextSplit(); assert(n === 998); //console.log(&quot;carrierName: &quot;+external.carrierName); // we need to force the system liquid to be on grid -1 const gridIndex = (external.carrierName === &quot;System&quot;) ? -1 : parseInt(l[0]); return [external.carrierName, gridIndex]; }); } /** * Create a string representation of an Evoware table layout * @param {EvowareCarrierData} carrierData - data loaded from an evoware carrier file * @param {object} table - a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} * @return {string} string representation of table layout */ export function toStrings(carrierData, table) { const l1 = [ &quot;00000000&quot;, &quot;20000101_000000 No log in &quot;, &quot; &quot;, &quot;No user logged in &quot;, &quot;--{ RES }--&quot;, &quot;V;200&quot;, &quot;--{ CFG }--&quot;, &quot;999;219;32;&quot; ]; const s2 = toString_internalCarriers(carrierData, table); const l3 = toStrings_internalLabware(carrierData, table); const l4 = toStrings_hotels(carrierData, table); const l5 = toStrings_externals(carrierData, table); const l6 = [ &quot;996;0;0;&quot;, &quot;--{ RPG }--&quot; ]; const l = _.flatten([l1, s2, l3, l4, l5, l6]); //console.log(l.join(&quot;\\n&quot;)); return l; } /** * Create a string representation of the internal carriers * @param {EvowareCarrierData} carrierData - data loaded from an evoware carrier file * @param {object} table - a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} * @return {string} string representation of internal carriers */ export function toString_internalCarriers(carrierData, table) { // Get list [[gridIndex, carrier.id]] for internal sites // [[a, b]] const gridToCarrierName_l = _(table).map((c, carrierName) =&gt; { //console.log({c, carrierName}) return _.map(c, (x, gridIndexText) =&gt; { if (x.internal) { try { const gridIndex = parseInt(gridIndexText); return [gridIndex, carrierName]; } catch(e) { // Do nothing } } return undefined; }); }).flatten().compact().value(); const gridToCarrierName_m = _.fromPairs(gridToCarrierName_l); //console.log({gridToCarrierId_l, gridToCarrierId_m}) const l = _.times(99, gridIndex =&gt; { const carrierName = gridToCarrierName_m[gridIndex]; return (_.isEmpty(carrierName)) ? -1 : carrierData.getCarrierByName(carrierName).id; }); return `14;${l.join(&quot;;&quot;)};`; } /** * Create a string representation of the internal labware * @param {EvowareCarrierData} carrierData - data loaded from an evoware carrier file * @param {object} table - a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} * @return {string} string representation of internal labware */ export function toStrings_internalLabware(carrierData, table) { const items0 = []; _.forEach(table, (c, carrierName) =&gt; { _.forEach(c, (g, gridIndexText) =&gt; { if (g.internal === true) { const carrierId = _.get(carrierData.getCarrierByName(carrierName), 'id', -1); items0.push({carrierName, carrierId, gridIndex: parseInt(gridIndexText), g}); } }); }); // Sort by gridIndex const items = _.sortBy(items0, 'gridIndex'); //console.log(&quot;items:&quot;) //console.log(items) const gridIndexToItem = _(items).map(x =&gt; [x.gridIndex, x]).fromPairs().value(); //console.log({gridIndexToItem}) return _.flatten(_.times(99, gridIndex =&gt; { const item = gridIndexToItem[gridIndex]; if (_.isUndefined(item)) { return &quot;998;0;&quot;; } else { const carrier = carrierData.getCarrierByName(item.carrierName); //console.log({item, carrier}) //val sSiteCount = if (carrier.nSites &gt; 0) carrier.nSites.toString else &quot;&quot; const namesAndLabels = _.times(carrier.siteCount, siteIndex =&gt; { //console.log({g: item.g}) const labwareModelName = _.get(item.g, [siteIndex + 1, 'labwareModelName'], &quot;&quot;); const label = _.get(item.g, [siteIndex + 1, 'label'], &quot;&quot;); return {labwareModelName, label}; }) return [ `998;${carrier.siteCount};${_.map(namesAndLabels, x =&gt; x.labwareModelName).join(';')};`, `998;${_.map(namesAndLabels, x =&gt; x.label).join(';')};`, ] } })); } /** * Create a string representation of the hotels * @param {EvowareCarrierData} carrierData - data loaded from an evoware carrier file * @param {object} table - a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} * @return {string} string representation of hotels */ export function toStrings_hotels(carrierData, table) { const hotelItems0 = []; _.forEach(table, (c, carrierName) =&gt; { _.forEach(c, (g, gridIndexText) =&gt; { if (g.hotel === true) { const carrierId = carrierData.getCarrierByName(carrierName).id; hotelItems0.push([carrierId, parseInt(gridIndexText)]); } }); }); //console.log({hotelItems0}); const hotelItems = _.sortBy(hotelItems0, x =&gt; x[1]); return _.flatten([ `998;${hotelItems.length};`, hotelItems.map(([carrierId, gridIndex]) =&gt; `998;${carrierId};${gridIndex};`) ]); } /** * Create a string representation of external carriers * @param {EvowareCarrierData} carrierData - data loaded from an evoware carrier file * @param {object} table - a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} * @return {string} string representation of external carriers */ export function toStrings_externals(carrierData, table) { const items0 = []; _.forEach(table, (c, carrierName) =&gt; { _.forEach(c, (g, gridIndexText) =&gt; { if (g.external) { const carrierId = _.get(carrierData.getCarrierByName(carrierName), 'id', -1); items0.push({carrierName, carrierId, gridIndex: parseInt(gridIndexText), g}); } }); }); // Sort by carrierId const items = _.sortBy(items0, 'carrierId'); // Generate list of external objects and their carriers const l1 = _.flatten([ `998;${items.length};`, items.map(({carrierName, g}) =&gt; `998;${g.external.n1};${g.external.n2};${carrierName};`) ]); // Generate list of labware models const itemsWithLabware = items.filter(item =&gt; _.has(item, &quot;g.1.labwareModelName&quot;)); const l2 = _.flatten([ `998;${itemsWithLabware.length};`, itemsWithLabware.map(({carrierId, g}) =&gt; `998;${carrierId};${_.get(g, &quot;1.labwareModelName&quot;)};`) ]); // Generate grid list const l3 = items.map(({gridIndex}) =&gt; `998;${(gridIndex === -1) ? 1 : gridIndex};`); return _.concat(l1, l2, l3); } × Search results Close "},"EvowareUtils.js.html":{"id":"EvowareUtils.js.html","title":"Source: EvowareUtils.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: EvowareUtils.js /** * A collection of helper utilities for our Evoware compiler. * @module */ import _ from 'lodash'; import fs from 'fs'; import iconv from 'iconv-lite'; /** * Encode an integer as an ASCII character. * Evoware uses this to generate a string representing a list of wells or sites. * @param {number} n - integer to encode as a character * @return {string} a single-character string that represents the number */ export function encode(n) { return String.fromCharCode(&quot;0&quot;.charCodeAt(0) + n); } /** * Decode a character to an integer. */ export function decode(c) { return c.charCodeAt(0) - &quot;0&quot;.charCodeAt(0); } /** * Convert the number to hex. Number should be between 0 and 15. * @param {integer} n - number between 0 and 15 * @return {char} */ export function hex(n) { return n.toString(16).toUpperCase()[0]; } /** * Takes an encoding of indexes on a 2D surface (as found in the file Carrier.cfg) * and * @param {string} encoded - an encoded list of indexes * @return {array} tuple of [rows on surface, columns on surface, selected indexes on surface] */ export function parseEncodedIndexes(encoded) { // HACK: for some reason, there is this strange sequence &quot;ï¿½&quot; that shows // up in some places. It appears to simply indicate 7 bits, e.g. &quot;0&quot;+127, e.g. '¯' encoded = encoded.replace(/ï¿½/g, String.fromCharCode(48+127)); const col_n = decode(encoded.charAt(1)); const row_n = decode(encoded.charAt(3)); const s = encoded.substring(4); //console.log({col_n, row_n, s}) const indexes = _.flatMap(s, (c, c_i) =&gt; { const n = decode(c); //const bit_l = (0 to 7).flatMap(bit_i =&gt; if ((n &amp; (1 &lt;&lt; bit_i)) &gt; 0) Some(bit_i) else None) const bit_l = _.filter(_.times(7, bit_i =&gt; ((n &amp; (1 &lt;&lt; bit_i)) &gt; 0) ? bit_i : undefined), x =&gt; !_.isUndefined(x)); //console.log({c, c_i, n, bit_l}); return bit_l.map(bit_i =&gt; c_i * 7 + bit_i); }); return [col_n, row_n, indexes]; } /** * Split an evoware carrier line into its components. * The first component is an integer that identifies the type of line. * The remaining components are returned as a list of string. * * @param {string} line - a text line from Evoware's carrier file * @return {array} Returns a pair [kind, items], where kind is an integer * identifying the type of line, and items is a string array of the remaining * components of the line. */ export function splitSemicolons(line) { const l = line.split(&quot;;&quot;); const kind = parseInt(l[0]); return [kind, _.tail(l)]; } /** * A class to handle Evoware's semicolon-based file format. * @class module:evoware/EvowareUtils.EvowareSemicolonFile * @param {string} filename - path to semicolon file * @param {number} skip - number of lines to initially skip at the top of the file */ export class EvowareSemicolonFile { constructor(filename, skip) { const raw = fs.readFileSync(filename); const filedata = iconv.decode(raw, &quot;ISO-8859-1&quot;); this.lines = filedata.split(&quot;\\n&quot;); //console.log(&quot;lines:\\n&quot;+lines) //console.log(lines.length); this.lineIndex = skip; } /** * Get the next line * @return {string} next line in semicolon file */ next() { if (this.lineIndex &gt;= this.lines.length) return undefined; const line = this.lines[this.lineIndex]; this.lineIndex++; return line; } /** * Get the next line in the file and split it on semicolons. * @return {array} array of strings resulting from splitting the line at semicolons. */ nextSplit() { const line = this.next(); if (_.isUndefined(line)) return undefined; const result = splitSemicolons(line); return result; } /** * Whether there are any more lines in the file. * @return {boolean} true if there are more lines to read */ hasNext() { return (this.lineIndex &lt; this.lines.length); } /** * Return a line that is `skip` lines ahead of the last line read. * @param {number} skip - number of lines to skip over * @return {string} line in file */ peekAhead(skip) { const i = this.lineIndex + skip; if (i &gt;= this.lines.length) return undefined; const line = this.lines[i]; return line; } /** * Skip `n` lines ahead * @param {number} n - number of lines to skip */ skip(n) { this.lineIndex += n; } /** * Get the next `n` lines from the file. * @param {number} n - number of lines to read. * @return {array} array of strings read. */ take(n) { const l = this.lines.slice(this.lineIndex, this.lineIndex + n); this.lineIndex += n; return l; } } × Search results Close "},"EvowareCompiler.js.html":{"id":"EvowareCompiler.js.html","title":"Source: EvowareCompiler.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: EvowareCompiler.js /** * Module for compiling an instruction list (created by roboliq) to * an Evoware script. * @module */ import _ from 'lodash'; import naturalSort from 'javascript-natural-sort'; import path from 'path'; import M from './Medley.js'; import commandHelper from 'roboliq-processor/dist/commandHelper.js'; import * as EvowareTableFile from './EvowareTableFile.js'; import * as evowareHelper from './commands/evowareHelper.js'; import * as evoware from './commands/evoware.js'; import * as pipetter from './commands/pipetter.js'; import * as system from './commands/system.js'; import * as timer from './commands/timer.js'; import * as transporter from './commands/transporter.js'; const commandHandlers = { &quot;evoware._execute&quot;: evoware._execute, &quot;evoware._facts&quot;: evoware._facts, &quot;evoware._raw&quot;: evoware._raw, &quot;evoware._subroutine&quot;: evoware._subroutine, &quot;evoware._userPrompt&quot;: evoware._userPrompt, &quot;evoware._variable&quot;: evoware._variable, &quot;pipetter._aspirate&quot;: pipetter._aspirate, &quot;pipetter._dispense&quot;: pipetter._dispense, &quot;pipetter._measureVolume&quot;: pipetter._measureVolume, &quot;pipetter._mix&quot;: pipetter._mix, &quot;pipetter._pipette&quot;: pipetter._pipette, &quot;pipetter._washTips&quot;: pipetter._washTips, &quot;system.runtimeExitLoop&quot;: system.runtimeExitLoop, &quot;system.runtimeLoadVariables&quot;: system.runtimeLoadVariables, &quot;system.runtimeSteps&quot;: system.runtimeSteps, &quot;timer._sleep&quot;: timer._sleep, &quot;timer._start&quot;: timer._start, &quot;timer._wait&quot;: timer._wait, &quot;transporter._moveLidFromContainerToSite&quot;: transporter._moveLidFromContainerToSite, &quot;transporter._moveLidFromSiteToContainer&quot;: transporter._moveLidFromSiteToContainer, &quot;transporter._movePlate&quot;: transporter._movePlate }; /** * Compile a protocol for a given evoware setup. * * @param {EvowareCarrierData} carrierData * @param {object} table - table object (see EvowareTableFile.load) * @param {roboliq:Protocol} protocol * @param {array} agents - string array of agent names that this script should generate script(s) for * @param {object} options - an optional map of options; e.g. set timing=false to avoid outputting time-logging instructions * @return {array} an array of {table, lines} items; one item is generated per required table layout. lines is an array of strings. */ export function compile(table, protocol, agents, options = {}) { // console.log(`compile:`) // console.log({options}) options = _.defaults(options, _.get(protocol.config, &quot;evowareCompiler&quot;, {})); // console.log({options}) table = _.cloneDeep(table); const objects = _.cloneDeep(protocol.objects); const evowareVariables = {} const results = compileStep(table, protocol, agents, [], objects, evowareVariables, [], options); let lines = []; if (!_.isEmpty(results)) { // Prepend variables // console.log({evowareVariables}) const variableList = _.reverse(_.sortBy(_.toPairs(evowareVariables), x =&gt; x[0])); // console.log({variableList}) _.forEach(variableList, ([name, value]) =&gt; { // console.log({name, value, line: evowareHelper.createVariableLine(name, value)}) results.unshift({line: evowareHelper.createVariableLine(name, value)}); }); // Prepend token to call 'initRun' results.unshift({line: evowareHelper.createExecuteLine(options.variables.ROBOLIQ, [&quot;initRun&quot;, options.variables.SCRIPTFILE], true)}); // Append token to reset the last moved ROMA results.push(transporter.moveLastRomaHome({objects})); lines = _(results).flattenDeep().map(x =&gt; x.line).compact().value(); if (!_.isEmpty(lines)) { // Prepend token to create the TEMPDIR if (_.some(lines, line =&gt; line.indexOf(options.variables.TEMPDIR) &gt;= 0)) { lines.unshift(evowareHelper.createExecuteLine(&quot;cmd&quot;, [&quot;/c&quot;, &quot;mkdir&quot;, options.variables.TEMPDIR], true)); } // Prepend token to open HTML if (_.get(options, &quot;checkBench&quot;, true)) { lines.unshift(evowareHelper.createUserPromptLine(&quot;Please check the bench setup and then confirm this dialog when you're done&quot;)); lines.unshift(evowareHelper.createExecuteLine(options.variables.BROWSER, [path.win32.dirname(options.variables.SCRIPTFILE)+&quot;\\\\index.html&quot;], false)); } } } return [{table, lines, tokenTree: results}]; } export function compileStep(table, protocol, agents, path, objects, evowareVariables, loopEndStack = [], options = {}) { // console.log(`compileStep: ${path.join(&quot;.&quot;)}`) // console.log({options}) try { const results = compileStepSub(table, protocol, agents, path, objects, evowareVariables, loopEndStack, options); return results; } catch (e) { console.log(&quot;ERROR: &quot;+path.join(&quot;.&quot;)); console.log(JSON.stringify(_.get(protocol.steps, path))) console.log(e) console.log(e.stack) } return []; } function compileStepSub(table, protocol, agents, path, objects, evowareVariables, loopEndStack, options) { // console.log(`compileStepSub: ${path.join(&quot;.&quot;)}`) // console.log({options}) if (_.isUndefined(objects)) { objects = _.cloneDeep(protocol.objects); } const stepId = path.join(&quot;.&quot;); //console.log({steps: protocol.steps}) const step = (_.isEmpty(path)) ? protocol.steps : _.get(protocol.steps, path); // console.log({step}) if (_.isUndefined(step)) return undefined; if (stepId !== &quot;&quot; &amp;&amp; protocol.COMPILER) { // Handle suspending if (protocol.COMPILER.suspendStepId) { const cmp = naturalSort(stepId, protocol.COMPILER.suspendStepId); // console.log({stepId, suspendStepId: protocol.COMPILER.suspendStepId, cmp}) // If we've passed the suspend step, quit compiling if (cmp &gt; 0) { return undefined; } // If we're before the suspend step, skip unless the current step is a parent step else if (cmp &lt; 0 &amp;&amp; !_.startsWith(protocol.COMPILER.suspendStepId, stepId+&quot;.&quot;)) { return undefined; } } // Handle resuming if (protocol.COMPILER.resumeStepId) { const cmp = naturalSort(stepId, protocol.COMPILER.resumeStepId); // console.log({stepId, resumeStepId: protocol.COMPILER.resumeStepId, cmp}) // Skip until we've passed the resume step if (cmp &lt;= 0) { return undefined; } } } const results = []; const commandHandler = commandHandlers[step.command]; let generatedCommandLines = false; let generatedTimingLogs = false; const agentMatch = _.isUndefined(step.agent) || _.includes(agents, step.agent); // If there is no command handler for this step, then handle sub-steps if (_.isUndefined(commandHandler) || !agentMatch) { // Find all sub-steps (properties that start with a digit) var keys = _.filter(_.keys(step), function(key) { var c = key[0]; return (c &gt;= '0' &amp;&amp; c &lt;= '9'); }); // Sort them in &quot;natural&quot; order keys.sort(naturalSort); // console.log({keys}) const isLoop = _.includes([&quot;system.repeat&quot;, &quot;experiment.forEachGroup&quot;, &quot;experiment.forEachRow&quot;], step.command); const loopEndName = `_${stepId}End`; const loopEndStack2 = (isLoop) ? [loopEndName].concat(loopEndStack) : loopEndStack; let needLoopLabel = false; // Try to expand the substeps for (const key of keys) { const result1 = compileStep(table, protocol, agents, path.concat(key), objects, evowareVariables, loopEndStack2, options); // Possibly check whether we need a loop label if (isLoop &amp;&amp; !needLoopLabel) { const result2 = _.flattenDeep(result1); needLoopLabel = _.some(result2, result =&gt; (result.line || &quot;&quot;).indexOf(loopEndName) &gt;= 0); } if (!_.isUndefined(result1)) { results.push(result1); } } if (needLoopLabel) { results.push({line: `Comment(&quot;${loopEndName}&quot;);`}); } } // Else, handle the step's command: else { const data = { objects, //predicates, //planHandlers: protocol.planHandlers, schemas: protocol.schemas, accesses: [], //files: filecache, protocol, path, loopEndStack, evowareVariables }; // Parse command options const schema = protocol.schemas[step.command]; const parsed = (schema) ? commandHelper.parseParams(step, data, schema) : {orig: step}; // Handle the command const result0 = commandHandler(step, parsed, data); // For all returned results: _.forEach(_.compact(result0), result1 =&gt; { // console.log(&quot;result1: &quot;+JSON.stringify(result1)); results.push(result1); if (result1.effects) { _.forEach(result1.effects, (effect, path2) =&gt; { M.setMut(objects, path2, effect); }); } if (!_.isEmpty(result1.tableEffects)) { //console.log(&quot;tableEffects: &quot;+JSON.stringify(result1.tableEffects)) _.forEach(result1.tableEffects, ([path2, value]) =&gt; { //console.log({path2, value}) // TODO: Need to check whether a table change is required because a different labware model is now used at a given site M.setMut(table, path2, value); }); } }); if (_.isEmpty(results)) { return []; } // Check whether command produced any output lines generatedCommandLines = _.find(_.flattenDeep(results), x =&gt; _.has(x, &quot;line&quot;)); // Possibly wrap the instructions in calls to pathToRoboliqRuntimeCli in order to check timing // console.log({options, timing: _.get(options, &quot;timing&quot;, true)}) if (generatedCommandLines &amp;&amp; _.get(options, &quot;timing&quot;, false) === true) { const agent = _.get(objects, step.agent); const exePath = &quot;%{ROBOLIQ}&quot;;//options.variables.ROBOLIQ; // console.log({agent}) results.unshift({line: evowareHelper.createExecuteLine(exePath, [&quot;begin&quot;, &quot;--step&quot;, stepId, &quot;--script&quot;, &quot;%{SCRIPTFILE}&quot;], false)}); results.push({line: evowareHelper.createExecuteLine(exePath, [&quot;end&quot;, &quot;--step&quot;, stepId, &quot;--script&quot;, &quot;%{SCRIPTFILE}&quot;], false)}); generatedTimingLogs = true; } } // Process the protocol's effects const effects = _.get(protocol, [&quot;effects&quot;, stepId]); if (!_.isUndefined(effects)) { _.forEach(effects, (effect, path2) =&gt; { M.setMut(objects, path2, effect); }); } const generatedComment = !_.isEmpty(step.description); if (generatedComment) { const hasInstruction = _.find(_.flattenDeep(results), x =&gt; _.has(x, &quot;line&quot;)); const text = `${stepId}) ${step.description}`; results.unshift({line: `Comment(&quot;${text}&quot;);`}); } // Possibly wrap the instructions in a group const generatedGroup = (generatedTimingLogs) || (!generatedCommandLines &amp;&amp; generatedComment &amp;&amp; results.length &gt; 1); if (generatedGroup) { const text = `Step ${stepId}`; results.unshift({line: `Group(&quot;${text}&quot;);`}); results.push({line: `GroupEnd();`}); } // console.log({stepId, results}) substitutePathVariables(results, options); return results; } function substitutePathVariables(results, options) { // console.log({results, options}) if (!options.variables) return; for (let i = 0; i &lt; results.length; i++) { const result = results[i]; if (_.isArray(result)) { substitutePathVariables(result, options); } else { let line = results[i].line; if (line) { line = line.replace(&quot;%{ROBOLIQ}&quot;, options.variables.ROBOLIQ); line = line.replace(&quot;%{SCRIPTFILE}&quot;, options.variables.SCRIPTFILE); line = line.replace(&quot;%{SCRIPTDIR}&quot;, options.variables.SCRIPTDIR); line = line.replace(&quot;%{TEMPDIR}&quot;, options.variables.TEMPDIR); results[i].line = line; } } } } × Search results Close "},"EvowareConfigSpec.js.html":{"id":"EvowareConfigSpec.js.html","title":"Source: EvowareConfigSpec.js","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Source: EvowareConfigSpec.js /** * Module for converting an EvowareConfigSpec to a general Roboliq configuration protocol. * @module */ const _ = require('lodash'); const assert = require('assert'); const math = require('mathjs'); const commandHelper = require('roboliq-processor/dist/commandHelper.js'); const expect = require('roboliq-processor/dist/expect.js'); const evowareEquipment = require('./equipment/evoware.js'); // For validate(): const Validator = require('jsonschema').Validator; const YAML = require('yamljs'); /** * Convert an EvowareConfigSpec into the format of a Roboliq Protocol. * This function exists, because it is much simpler to write an * EvowareConfigSpec than the equivalent Protocol. * @param {EvowareConfigSpec} spec - specification of an Evoware robot configuration * @param {Object} [data] - (not currently used) protocol data loaded before this configuration * @return {Protocol} - an Evoware robot configuration in the format of a Protocol. */ function makeProtocol(spec, data = {objects: {}, predicates: []}) { // Validate const validation = validate(spec); if (!_.isEmpty(validation.errors)) { return { errors: { EvowareConfigSpec: validation.errors } }; } const namespace = [spec.namespace, spec.name].join(&quot;.&quot;); const agent = [spec.namespace, spec.name, &quot;evoware&quot;].join(&quot;.&quot;); const predicates = []; const output = { roboliq: &quot;v1&quot;, predicates, commandHandlers: evowareEquipment.getCommandHandlers() }; function getAgentName() { return [namespace, &quot;evoware&quot;].join(&quot;.&quot;); } function getEquipmentName(equipmentName) { assert(equipmentName, &quot;equipmentName is undefined&quot;); return [namespace, equipmentName].join(&quot;.&quot;); } function getSiteName(siteName) { assert(siteName, &quot;siteName is undefined&quot;); return [namespace, &quot;site&quot;, siteName].join(&quot;.&quot;); } // Return fully qualified model name - first lookup to see whether the // model is specific to this robot, and if so, use that name. Otherwise // use the model name for lab, as defined by spec.namespace. function getModelName(base) { assert(base, &quot;modelName is undefined&quot;); const model1 = [spec.namespace, spec.name, &quot;model&quot;, base]; const model2 = [spec.namespace, &quot;model&quot;, base]; const isOnlyOnRobot = _.has(output.objects, model1); return (isOnlyOnRobot) ? model1.join(&quot;.&quot;) : model2.join(&quot;.&quot;); } function lookupSyringe(base) { assert(base, &quot;lookupSyringe: base name must be defined&quot;); const id1 = [spec.namespace, spec.name, &quot;liha&quot;, &quot;syringe&quot;, base.toString()]; const id2 = base.toString(); const id = _.has(output.objects, id1) ? id1 : _.has(data.objects, id2) ? id2 : undefined; assert(!_.isUndefined(id), &quot;syringe not found: &quot;+base); return id.join(&quot;.&quot;); } function lookupTipModel(base) { assert(base, &quot;lookupTipModel: base name must be defined&quot;); const id1 = [spec.namespace, spec.name, &quot;liha&quot;, &quot;tipModel&quot;, base]; const id2 = [spec.namespace, &quot;tipModel&quot;, base]; const id3 = base; // console.log({id1, id2, id3, b1: _.has(output.objects, id1), b2: _.has(data.objects, id2), b3: _.has(data.objects, id3)}) const id = _.has(output.objects, id1) ? id1 : _.has(data.objects, id2) ? id2 : _.has(data.objects, id3) ? id3 : undefined; assert(!_.isUndefined(id), &quot;tipModel not found: &quot;+base); return id.join(&quot;.&quot;); } let siteModelCount = 0; function addSiteModelCompatibilities(siteModelCompatibilities, output) { if (_.isUndefined(output.predicates)) output.predicates = []; // Add predicates for siteModelCompatibilities _.forEach(siteModelCompatibilities, compat =&gt; { siteModelCount++; const siteModel = `${namespace}.siteModel${siteModelCount}`; output.predicates.push({isSiteModel: {model: siteModel}}); _.forEach(compat.sites, site =&gt; { output.predicates.push({siteModel: {site: helpers.getSiteName(site), siteModel}}); }); _.forEach(compat.models, labwareModel =&gt; { output.predicates.push({stackable: {below: siteModel, above: helpers.getModelName(labwareModel)}}) }); }); } const helpers = { getAgentName, getEquipmentName, getSiteName, getModelName, lookupSyringe, lookupTipModel, addSiteModelCompatibilities, }; output.schemas = evowareEquipment.getSchemas(); _.set(output, [&quot;roboliq&quot;], &quot;v1&quot;); _.set(output, [&quot;objects&quot;, spec.namespace, &quot;type&quot;], &quot;Namespace&quot;); _.set(output, [&quot;objects&quot;, spec.namespace, &quot;model&quot;, &quot;type&quot;], &quot;Namespace&quot;); _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, &quot;type&quot;], &quot;Namespace&quot;); _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, &quot;evoware&quot;, &quot;type&quot;], &quot;EvowareRobot&quot;); _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, &quot;evoware&quot;, &quot;config&quot;], spec.config); _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, &quot;site&quot;, &quot;type&quot;], &quot;Namespace&quot;); _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, &quot;liha&quot;, &quot;type&quot;], &quot;Pipetter&quot;); // Add 5 timers _.forEach(_.range(5), i =&gt; { const equipment = [spec.namespace, spec.name, `timer${i+1}`].join(&quot;.&quot;); _.set(output.objects, equipment, { type: &quot;Timer&quot;, evowareId: i+1 }); output.predicates.push({ &quot;timer.canAgentEquipment&quot;: {agent, equipment} }); }); // Add bench sites (equipment sites will be added by the equipment modules) _.forEach(spec.sites, (value, key) =&gt; { _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, &quot;site&quot;, key], _.merge({type: &quot;Site&quot;}, value)); }); // Add explicitly defined models to spec.namespace _.forEach(spec.models, (value, key) =&gt; { _.set(output, [&quot;objects&quot;, spec.namespace, &quot;model&quot;, key], value); }); // Add predicates for siteModelCompatibilities addSiteModelCompatibilities(spec.siteModelCompatibilities, output); // Lid and plate stacking _.forEach(spec.lidStacking, lidsModels =&gt; { _.forEach(lidsModels.lids, lid =&gt; { _.forEach(lidsModels.models, model =&gt; { const below = getModelName(model); const above = getModelName(lid); predicates.push({stackable: {below, above}}); }); }); }); handleEquipment(spec, helpers, namespace, agent, output); handleRomas(spec, helpers, namespace, agent, output); handleLiha(spec, helpers, namespace, agent, output); output.objectToPredicateConverters = evowareEquipment.objectToPredicateConverters; if (spec.planAlternativeChoosers) { output.planAlternativeChoosers = spec.planAlternativeChoosers; // console.log({planAlternativeChoosers: output.planAlternativeChoosers}) } // User-defined commandHandlers _.forEach(spec.commandHandlers, (fn, key) =&gt; { output.commandHandlers[key] = fn; }); return output; } /** * Create the predictates to be added to Roboliq's robot * configuration for Evoware's RoMa relationships. * * Expect specs of this form: * ``{&lt;transporter&gt;: {&lt;program&gt;: [site names]}}`` * @param {Object} spec * @param {Roma[]} spec.romas */ function handleRomas(spec, helpers, namespace, agent, output) { let siteCliqueId = 1; _.forEach(spec.romas, (roma, i) =&gt; { // Add the roma object _.set(output, [&quot;objects&quot;, spec.namespace, spec.name, `roma${i+1}`], {type: &quot;Transporter&quot;, evowareRoma: i}); const equipment = [spec.namespace, spec.name, `roma${i+1}`].join(&quot;.&quot;); _.forEach(roma.safeVectorCliques, safeVectorClique =&gt; { const siteClique = `${namespace}.siteClique${siteCliqueId}`; siteCliqueId++; const program = safeVectorClique.vector; // Add the site clique predicates _.forEach(safeVectorClique.clique, base =&gt; { const site = helpers.getSiteName(base); output.predicates.push({&quot;siteCliqueSite&quot;: {siteClique, site}}); }); // Add the transporter predicates output.predicates.push({ &quot;transporter.canAgentEquipmentProgramSites&quot;: { agent, equipment, program, siteClique } }); }); }); } function handleLiha(spec, helpers, namespace, agent, output) { if (!spec.liha) return; const equipment = [spec.namespace, spec.name, &quot;liha&quot;].join(&quot;.&quot;); const tipModelToSyringes = {}; if (_.isPlainObject(spec.liha.tipModels)) { const tipModels = _.mapValues(spec.liha.tipModels, x =&gt; _.merge({type: &quot;TipModel&quot;}, x)); // console.log(tipModels) _.set(output.objects, [spec.namespace, spec.name, &quot;liha&quot;, &quot;tipModel&quot;], tipModels); // console.log({stuff: _.get(output, [&quot;object&quot;, spec.namespace, spec.name, &quot;liha&quot;, &quot;tipModel&quot;])}); } output.schemas[`pipetter.cleanTips|${agent}|${equipment}`] = { description: &quot;Clean the pipetter tips.&quot;, properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: {description: &quot;Program identifier&quot;, type: &quot;string&quot;}, items: { description: &quot;List of which syringes to clean at which intensity&quot;, type: &quot;array&quot;, items: { type: &quot;object&quot;, properties: { syringe: {description: &quot;Syringe identifier&quot;, type: &quot;Syringe&quot;}, intensity: {description: &quot;Intensity of the cleaning&quot;, type: &quot;pipetter.CleaningIntensity&quot;} }, required: [&quot;syringe&quot;, &quot;intensity&quot;] } } }, required: [&quot;agent&quot;, &quot;equipment&quot;, &quot;items&quot;] }; // Add syringes _.set(output.objects, [spec.namespace, spec.name, &quot;liha&quot;, &quot;syringe&quot;], {}); _.forEach(spec.liha.syringes, (syringeSpec, i) =&gt; { // console.log({syringeSpec}) const syringe = [spec.namespace, spec.name, &quot;liha&quot;, &quot;syringe&quot;, (i+1).toString()].join(&quot;.&quot;); const syringeObj = { type: &quot;Syringe&quot;, row: i + 1 }; // console.log({syringeObj}) _.set(output.objects, syringe, syringeObj); // Handle permanent tips if (syringeSpec.tipModelPermanent) { const tipModel = helpers.lookupTipModel(syringeSpec.tipModelPermanent); syringeObj.tipModel = tipModel; syringeObj.tipModelPermanent = tipModel; tipModelToSyringes[tipModel] = (tipModelToSyringes[tipModel] || []).concat([syringe]); } else { assert(false, &quot;roboliq-evoware currently only supports fixed tips; please contact the software developer to add support for disposable tips.&quot;) } }); // Handle tipModelToSyringes mapping for non-permantent tips _.forEach(spec.liha.tipModelToSyringes, (syringes0, tipModel0) =&gt; { const tipModel = helpers.lookupTipModel(syringeSpec.tipModelPermanent); const syringes = syringes0.map(helpers.lookupSyringe); tipModelToSyringes[tipModel] = (tipModelToSyringes[tipModel] || []).concat(syringes); }); // console.log({tipModelToSyringes}) _.set(output.objects, [spec.namespace, spec.name, &quot;liha&quot;, &quot;tipModelToSyringes&quot;], tipModelToSyringes); // Handle washPrograms if (spec.liha.washPrograms) { const washPrograms = _.merge({type: &quot;Namespace&quot;}, _.mapValues(spec.liha.washPrograms, x =&gt; _.merge({type: &quot;EvowareWashProgram&quot;}, x))); _.set(output.objects, [spec.namespace, spec.name, &quot;washProgram&quot;], washPrograms); } // Add system liquid const syringeCount = spec.liha.syringes.length; assert(syringeCount &lt;= 8, &quot;roboliq-evoware has only been configured to handle 8-syringe LiHas; please contact the software developer to accommodate your needs.&quot;); _.set(output.objects, [spec.namespace, spec.name, &quot;systemLiquidLabwareModel&quot;], { &quot;type&quot;: &quot;PlateModel&quot;, &quot;description&quot;: &quot;dummy labware model representing the system liquid source&quot;, &quot;rows&quot;: syringeCount, &quot;columns&quot;: 1, &quot;evowareName&quot;: &quot;SystemLiquid&quot; }); _.set(output.objects, [spec.namespace, spec.name, &quot;systemLiquid&quot;], { &quot;type&quot;: &quot;Liquid&quot;, &quot;wells&quot;: _.map(_.range(syringeCount), i =&gt; `${spec.namespace}.${spec.name}.systemLiquidLabware(${String.fromCharCode(65 + i)}01)`) }); _.set(output.objects, [spec.namespace, spec.name, &quot;systemLiquidLabware&quot;], { &quot;type&quot;: &quot;Plate&quot;, &quot;description&quot;: &quot;dummy labware representing the system liquid source&quot;, &quot;model&quot;: `${namespace}.systemLiquidLabwareModel`, &quot;location&quot;: helpers.getSiteName(&quot;SYSTEM&quot;), &quot;contents&quot;: [&quot;Infinity l&quot;, &quot;systemLiquid&quot;] }); // Equipment predicates output.predicates.push({ &quot;pipetter.canAgentEquipment&quot;: { agent, equipment } }); // Syringe predicates _.forEach(spec.liha.syringes, (syringeSpec, i) =&gt; { output.predicates.push({ &quot;pipetter.canAgentEquipmentSyringe&quot;: { agent, equipment, syringe: `ourlab.mario.liha.syringe.${i+1}` } }) }); // Site predicates _.forEach(spec.liha.sites, site0 =&gt; { const site = helpers.getSiteName(site0); output.predicates.push({ &quot;pipetter.canAgentEquipmentSite&quot;: { agent, equipment, site } }); }); // Command handler for `pipetter.cleanTips` output.commandHandlers[`pipetter.cleanTips|${agent}|${equipment}`] = makeCleanTipsHandler(namespace); } function makeCleanTipsHandler(namespace) { return function cleanTips(params, parsed, data) { //console.log(&quot;pipetter.cleanTips|ourlab.mario.evoware|ourlab.mario.liha&quot;) //console.log(JSON.stringify(parsed, null, ' ')) const cleaningIntensities = data.schemas[&quot;pipetter.CleaningIntensity&quot;].enum; const syringeNameToItems = _.map(parsed.value.items, (item, index) =&gt; [parsed.objectName[`items.${index}.syringe`], item]); //console.log(syringeNameToItems); const expansionList = []; const sub = function(syringeNames, volume) { const syringeNameToItems2 = _.filter(syringeNameToItems, ([syringeName, ]) =&gt; _.includes(syringeNames, syringeName) ); //console.log({syringeNameToItems2}) if (!_.isEmpty(syringeNameToItems2)) { const value = _.max(_.map(syringeNameToItems2, ([, item]) =&gt; cleaningIntensities.indexOf(item.intensity))); if (value &gt;= 0) { const intensity = cleaningIntensities[value]; const syringes = _.map(syringeNameToItems2, ([syringeName, ]) =&gt; syringeName); expansionList.push({ command: &quot;pipetter._washTips&quot;, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment, program: `${namespace}.washProgram.${intensity}_${volume}`, intensity: intensity, syringes: syringeNames }); } } } // Get list of syringes on the liha const syringesName = `${namespace}.liha.syringe`; const syringesObj = _.get(data.objects, syringesName); assert(syringesObj, &quot;didn't find LiHa syringes &quot;+syringesName); // Lists of [syringeName, tipModelName, programCode] const l = _.map(syringesObj, (syringeObj, syringeName0) =&gt; { const syringeName = `${namespace}.liha.syringe.${syringeName0}`; // console.log({syringeObj}) const tipModelName = syringeObj.tipModel; const tipModelObj = _.get(data.objects, tipModelName); assert(tipModelObj, &quot;didn't find tipModel &quot;+tipModelName); return [syringeName, tipModelName, tipModelObj.programCode]; }); // console.log({l}) // Group by program code, and call `sub()` const m = _.groupBy(l, x =&gt; x[2]); _.forEach(m, (l, programCode) =&gt; { sub(l.map(x =&gt; x[0]), programCode); }) return {expansion: expansionList}; }; } function handleEquipment(spec, helpers, namespace, agent, output) { _.forEach(spec.equipment, (value, key) =&gt; { // console.log({key}) const module = require(__dirname+&quot;/equipment/&quot;+value.module); const protocol = module.configure(helpers, key, value.params); // console.log(key+&quot;: &quot;+JSON.stringify(protocol, null, '\\t')) // console.log(key+&quot;.objects: &quot;+JSON.stringify(protocol.objects, null, '\\t')) _.merge(output, _.omit(protocol, &quot;predicates&quot;)); // console.log(&quot;output.objects: &quot;+JSON.stringify(output.objects, null, '\\t')) if (!_.isEmpty(protocol.predicates)) output.predicates.push(...protocol.predicates); }); } /* function test() { const evowareSpec = require('/Users/ellisw/src/roboliq/config/bsse-mario-new.js'); const orig = require('/Users/ellisw/src/roboliq/config/bsse-mario.js'); const protocol = process(evowareSpec); // console.log(JSON.stringify(protocol, null, '\\t')); const diff = require('deep-diff'); // console.log(&quot;isSiteModel predicates: &quot;+JSON.stringify(_.filter(protocol.predicates, x =&gt; Object.keys(x)[0] == &quot;isSiteModel&quot;))); // console.log(&quot;siteCliqueSite predicates: &quot;+JSON.stringify(_.filter(protocol.predicates, x =&gt; Object.keys(x)[0] == &quot;siteCliqueSite&quot;), null, '\\t')); protocol.predicates = _.fromPairs(_.sortBy(protocol.predicates.map(x =&gt; [JSON.stringify(x), x]), x =&gt; x[0])); orig.predicates = _.fromPairs(_.sortBy(orig.predicates.map(x =&gt; [JSON.stringify(x), x]), x =&gt; x[0])); const diffs = diff(_.omit(orig, &quot;objectToPredicateConverters&quot;), _.omit(protocol, &quot;objectToPredicateConverters&quot;)); const diffs2 = _.filter(diffs, d =&gt; ( (d.kind == &quot;E&quot; &amp;&amp; d.path[0] == &quot;commandHandlers&quot;) ? false : (d.kind == &quot;E&quot; &amp;&amp; d.path[0] == &quot;planHandlers&quot;) ? false : true )); console.log(JSON.stringify(diffs2, null, '\\t')); } */ /** * Validates a EvowareConfigSpec against the JSON schema. * @param {EvowareConfigSpec} evowareSpec - evoware config spec * @return {object} - returns the validation results from the npm package `jsonschema` */ function validate(evowareSpec) { const v = new Validator(); const schemas = YAML.load(__dirname+&quot;/schemas/EvowareConfigSpec.yaml&quot;); // console.log(JSON.stringify(schemas, null, '\\t')); _.forEach(schemas, (schema, name) =&gt; { const id = &quot;/&quot;+name; v.addSchema(_.merge({id}, schema), id); }); // console.log(JSON.stringify(evowareSpec, null, '\\t')); // console.log(evowareSpec); // See: http://json-schema.org/example2.html // See: https://spacetelescope.github.io/understanding-json-schema/structuring.html // TODO: raise error on unknown type // TODO: add some extra types, such as `function`, see // https://www.npmjs.com/package/jsonschema // https://www.npmjs.com/package/jsonschema-extra const result = v.validate(evowareSpec, schemas.EvowareConfigSpec); // console.log(result); return result; } module.exports = { makeProtocol, validate }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Modules Classes Carrier CarrierGridSiteIndex CarrierSiteIndex EvowareCarrierData LabwareModel Vector ExternalObject HotelObject EvowareSemicolonFile × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Classes Classes Carrier CarrierGridSiteIndex CarrierSiteIndex EvowareCarrierData LabwareModel Vector ExternalObject HotelObject EvowareSemicolonFile × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile This documentation was generated with JSDoc. It contains programmer documentation about the functions used in the Evoware compiler backend for Roboliq. Other documentation can be found here: Manual -- the Roboliq manual Protocol -- reference documentation for the commands and type available in Roboliq protocols Processor API -- programmer documentation for Roboliq's protocol processor × Search results Close "},"module-commands_evoware.html":{"id":"module-commands_evoware.html","title":"Module: commands/evoware","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: commands/evoware Handles instructions which are specifically for controlling evoware. Source: commands/evoware.js, line 1 × Search results Close "},"module-commands_evowareHelper.html":{"id":"module-commands_evowareHelper.html","title":"Module: commands/evowareHelper","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: commands/evowareHelper Helper functions for evoware command handlers. Source: commands/evowareHelper.js, line 1 Methods &lt;static&gt; createExecuteLine(path, args, wait, exitCodeVariableName) Create the Evoware token to execute an external command. Parameters: Name Type Description path string path to command to execute args array array of arguments to pass wait boolean true if evoware should wait for the command to complete execution exitCodeVariableName string optional name of Source: commands/evowareHelper.js, line 16 Returns: a string representing an Evoware 'Execute' token. Type string &lt;static&gt; createFactsLine(equipment, variableName, value) Create an Evoware FACTS token. Parameters: Name Type Description equipment string equipment ID for the FACTS command variableName string variable name for the FACTS command value string optional value of the variable Source: commands/evowareHelper.js, line 28 Returns: a string representing an Evoware 'FACTS' token. Type string &lt;static&gt; createIfLine(variable, test, value, target) Create an 'If' token. Parameters: Name Type Description variable string name of the variable to test test string one of &quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&gt;&quot; value string | number value to compare to target string target to jump to: an Evoware &quot;Comment&quot; token Source: commands/evowareHelper.js, line 47 Returns: line for an &quot;If&quot; token Type string &lt;static&gt; createStartScriptLine(path) Create the Evoware 'StartScript' token. Parameters: Name Type Description path string path to the script to start Source: commands/evowareHelper.js, line 59 Returns: line for a &quot;StartScript&quot; token Type string &lt;static&gt; createUserPromptLine(text, beep, autoclose) Create the Evoware token to prompt the user. Parameters: Name Type Description text string text to show the user beep numeric 0: none, 1: beep once, 2: beep three times, 3: beep every 3 seconds autoclose numeric number of second to leave the prompt open before autoclosing it and continuing operation (-1 means no autoclose) Source: commands/evowareHelper.js, line 69 &lt;static&gt; createVariableLine(text, beep, autoclose) Create the Evoware token to prompt the user. Parameters: Name Type Description text string text to show the user beep numeric 0: none, 1: beep once, 2: beep three times, 3: beep every 3 seconds autoclose numeric number of second to leave the prompt open before autoclosing it and continuing operation (-1 means no autoclose) Source: commands/evowareHelper.js, line 79 &lt;static&gt; quote(s) Put double-quotes around a string, if it doesn't already have them. Parameters: Name Type Description s string any input string Source: commands/evowareHelper.js, line 90 Returns: string with outer double-quotes. Type string &lt;static&gt; stripQuotes(s) If a string is surrounded by double-quotes, remove them. Parameters: Name Type Description s string a string, possible with outer double-quotes. Source: commands/evowareHelper.js, line 99 Returns: string with outer double-quotes removed. Type string × Search results Close "},"module-commands_pipetter.html":{"id":"module-commands_pipetter.html","title":"Module: commands/pipetter","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: commands/pipetter Handles pipetter instructions. Source: commands/pipetter.js, line 1 Methods &lt;inner&gt; encodeSyringes(syringes) Generate a bitmap encoding of syringes to use Parameters: Name Type Description syringes array array of syringes to use Source: commands/pipetter.js, line 511 Returns: an bitmask encoding of the syringes Type integer &lt;inner&gt; encodeSyringesByRow(rows) Generate a bitmap encoding of syringes to use Parameters: Name Type Description rows array array of syringe rows (base value is 1) Source: commands/pipetter.js, line 520 Returns: an bitmask encoding of the syringes Type integer &lt;inner&gt; encodeWells() Encode a list of wells on a plate as an evoware bitmask Source: commands/pipetter.js, line 528 &lt;inner&gt; groupItems(parsed, data) Returns an array of groupings of the pipette items. Each group has these properties: groupType -- either &quot;source&quot; or &quot;destination&quot;, depending on whether this group is for aspiration or dispense tuples -- an array of objects with these properties: item -- the original pipette item syringeName -- roboliq name of the syringe to use syringe -- syringe object syringeRow -- row of syringe on the LiHa source -- source properties {labwareName, labware, labwareModel, site, siteName, row, col} destination -- destination properties {labwareName, labware, labwareModel, site, siteName, row, col} syringeSpacing Parameters: Name Type Description parsed object parsed command parameters data object protocol data Source: commands/pipetter.js, line 167 Returns: an array of groupings of the pipette items Type array &lt;inner&gt; makeVolumes(tuples, volumePropertyName, volumeDefault) Return Array of size 12 with volumes for each syringe (in ul), taking the values from the 'tuples' items. For each item, the volume is queried using the volumePropertyName. If the volume is missing, volumeDefault should be provided. Parameters: Name Type Description tuples array volumePropertyName string volumeDefault mathjs.Unit Source: commands/pipetter.js, line 441 Returns: An array of volumes (in ul) Type array × Search results Close "},"module-commands_transporter.html":{"id":"module-commands_transporter.html","title":"Module: commands/transporter","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: commands/transporter Handles transporter instructions and supplies some additional control functions for moving the ROMAs. Source: commands/transporter.js, line 1 Methods &lt;static&gt; _moveLidFromContainerToSite(params, parsed, data) Handle the transporter._moveLidFromContainerToSite instruction. Parameters: Name Type Description params object original paramters parsed object parsed parameters data object protocol data Source: commands/transporter.js, line 43 Returns: an array of objects that describe output, effects, and table effects Type array &lt;static&gt; _moveLidFromSiteToContainer(params, parsed, data) Handle the transporter._moveLidFromSiteToContainer instruction. Parameters: Name Type Description params object original paramters parsed object parsed parameters data object protocol data Source: commands/transporter.js, line 71 Returns: an array of objects that describe output, effects, and table effects Type array &lt;static&gt; _movePlate(params, parsed, data [, lidHandling0]) Handle the transporter._movePlate instruction. Parameters: Name Type Argument Description params object original paramters parsed object parsed parameters data object protocol data lidHandling0 object &lt;optional&gt; an optional option to define lid handling - this is only used by the _moveLidFromContainerToSite and _moveLidFromSiteToContainer handlers. Properties Name Type Argument Description lid string &lt;optional&gt; name of the lid action string &lt;optional&gt; should either be &quot;remove&quot; or &quot;cover&quot; location string &lt;optional&gt; the site where the lid should be moved from or to destination string &lt;optional&gt; the site where the lid should be after the transfer Source: commands/transporter.js, line 104 Returns: an array of objects that describe output, effects, and table effects Type array &lt;static&gt; moveLastRomaHome(data) Move the last-moved ROMA back to its home position. Parameters: Name Type Description data object protocol data Source: commands/transporter.js, line 211 Returns: an array of objects that describe output, effects, and table effects Type array &lt;inner&gt; getRomaMoveLine(romaIndex, action) Move a ROMA Parameters: Name Type Description romaIndex number index of roma action number 0=open gripper, 1=close gripper, 2=move home, 3=move relative, Source: commands/transporter.js, line 20 Returns: string representation of ROMA command Type string × Search results Close "},"module-equipment_centrifuge4.html":{"id":"module-equipment_centrifuge4.html","title":"Module: equipment/centrifuge4","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: equipment/centrifuge4 Module for a generic 4-site centrifuge. Source: equipment/centrifuge4.js, line 1 Methods &lt;inner&gt; configure(params) Configure a generic centrifuge Parameters: Name Type Description params CentrifugeParams parameters for the configuration Source: equipment/centrifuge4.js, line 57 Returns: Type EquipmentConfig Type Definitions CentrifugeParams Type: object Properties: Name Type Description evowareId string the Evoware ID of this equipment evowareCarrier string the carrier that the equipment is on evowareGrid string the grid that the equipment is on Source: equipment/centrifuge4.js, line 12 Example ``` { evowareId: &quot;Centrifuge&quot;, evowareCarrier: &quot;Centrifuge&quot;, evowareGrid: 54, sites: { CENTRIFUGE_1: { evowareSite: 1 }, CENTRIFUGE_2: { evowareSite: 2 }, CENTRIFUGE_3: { evowareSite: 1 }, CENTRIFUGE_4: { evowareSite: 2 } }, siteModelCompatibilities: [ { sites: [&quot;CENTRIFUGE_1&quot;, &quot;CENTRIFUGE_2&quot;, &quot;CENTRIFUGE_3&quot;, &quot;CENTRIFUGE_4&quot;], models: [&quot;plateModel_384_square&quot;, &quot;plateModel_96_round_transparent_nunc&quot;] }, { sites: [&quot;CENTRIFUGE_2&quot;, &quot;CENTRIFUGE_4&quot;], models: [&quot;plateModel_96_dwp&quot;] }, ] } CentrifugeSitesToModels Type: object Properties: Name Type Description sites Array.&lt;string&gt; array of site names (just the base part, without namespace) models Array.&lt;string&gt; array of model names (just the base part, without namespace) Source: equipment/centrifuge4.js, line 45 × Search results Close "},"module-equipment_evoware.html":{"id":"module-equipment_evoware.html","title":"Module: equipment/evoware","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: equipment/evoware Module for Evoware commands. In order to use Evoware commands in Roboliq, you'll need to calls these functions in your robot configuration file. Source: equipment/evoware.js, line 1 Members &lt;static&gt; objectToPredicateConverters objectToPredicateConverters for Evoware Source: equipment/evoware.js, line 112 Methods &lt;static&gt; getCommandHandlers() Return command handlers for low-level evoware instructions. Source: equipment/evoware.js, line 126 Returns: map from instruction name to handler. Type object &lt;static&gt; getSchemas() Returns the schemas for Evoware commands and objects. Source: equipment/evoware.js, line 121 Returns: map from name to schema Type object &lt;static&gt; makeEvowareExecute(agentName, path, args, wait) Create an instruction for Evoware execute an external command. Parameters: Name Type Description agentName string Agent identifier path string path to command to execute args array array of arguments to pass wait boolean true if evoware should wait for the command to complete execution Source: equipment/evoware.js, line 22 Returns: an object representing an Evoware 'Execute' instruction. Type object &lt;static&gt; makeEvowareFacts(parsed, data, variable [, value], labwareName) Create an instruction for Evoware FACTS. Parameters: Name Type Argument Description parsed object parsed object of command parameters data object protocol data variable string [description] value any &lt;optional&gt; optional value; if value is a function, it will be called with the parameters (parsed, data). labwareName string labware used in this command Source: equipment/evoware.js, line 40 Returns: an object representing an Evoware 'FACTS' instruction. Type object &lt;static&gt; makeSiteModelPredicates() Create the predictates to be added to Roboliq's robot configuration for Evoware's site/model relationships. Expect spec of this form: {siteModel: string, sites: [string], labwareModels: [string]} Source: equipment/evoware.js, line 62 &lt;static&gt; makeTransporterPredicates() Create the predictates to be added to Roboliq's robot configuration for Evoware's RoMa relationships. Expect specs of this form: {&lt;transporter&gt;: {&lt;program&gt;: [site names]}} Source: equipment/evoware.js, line 78 × Search results Close "},"module-equipment_reader-InfiniteM200Pro.html":{"id":"module-equipment_reader-InfiniteM200Pro.html","title":"Module: equipment/reader-InfiniteM200Pro","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: equipment/reader-InfiniteM200Pro Module for the Tecan InfiniteM200 reader. Source: equipment/reader-InfiniteM200Pro.js, line 1 Type Definitions ReaderInfiniteM200ProConfig Type: object Properties: Name Type Description evowareId string the Evoware ID of this equipment evowareCarrier string the carrier that the equipment is on evowareGrid string the grid that the equipment is on evowareSite number the evoware site index of the equipment site Source: equipment/reader-InfiniteM200Pro.js, line 214 Example ``` evowareId: &quot;ReaderNETwork&quot;, evowareCarrier: &quot;Infinite M200&quot;, evowareGrid: 61, evowareSite: 1, site: &quot;READER&quot;, modelToPlateFile: { &quot;plateModel_96_round_transparent_nunc&quot;: &quot;NUN96ft&quot;, &quot;plateModel_384_square&quot;: &quot;GRE384fw&quot;, &quot;EK_384_greiner_flat_bottom&quot;: &quot;GRE384fw&quot;, &quot;EK_96_well_Greiner_Black&quot;: &quot;GRE96fb_chimney&quot; } ``` × Search results Close "},"module-equipment_shaker-Tecan1.html":{"id":"module-equipment_shaker-Tecan1.html","title":"Module: equipment/shaker-Tecan1","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: equipment/shaker-Tecan1 Module for a 1-site Tecan shaker. Source: equipment/shaker-Tecan1.js, line 1 Methods &lt;inner&gt; configure(params) Configure the Tecan 1-site shaker Parameters: Name Type Description params ShakerTecan1Params parameters for the configuration Source: equipment/shaker-Tecan1.js, line 27 Returns: Type EquipmentConfig Type Definitions ShakerTecan1Params Type: object Properties: Name Type Argument Description evowareId string the Evoware ID of this equipment evowareGrid string &lt;nullable&gt; the grid that the equipment is on Source: equipment/shaker-Tecan1.js, line 11 × Search results Close "},"module-evoware_EvowareCarrierFile.Carrier.html":{"id":"module-evoware_EvowareCarrierFile.Carrier.html","title":"Class: Carrier","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: Carrier Carrier new Carrier() A Carrier object Properties: Name Type Argument Description type string should be &quot;Carrier&quot; name string id integer siteCount integer deviceName string &lt;optional&gt; partNo string &lt;optional&gt; vectors array &lt;optional&gt; array of vector names for this carrier Source: EvowareCarrierFile.js, line 50 × Search results Close "},"module-evoware_EvowareCarrierFile.CarrierGridSiteIndex.html":{"id":"module-evoware_EvowareCarrierFile.CarrierGridSiteIndex.html","title":"Class: CarrierGridSiteIndex","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: CarrierGridSiteIndex CarrierGridSiteIndex new CarrierGridSiteIndex() Tuple for location refered to by carrier+grid+site indexes Properties: Name Type Description carrierId integer ID for the carrier gridIndex integer 1-based index of grid siteIndex integer 0-based index of site Source: EvowareCarrierFile.js, line 14 × Search results Close "},"module-evoware_EvowareCarrierFile.CarrierSiteIndex.html":{"id":"module-evoware_EvowareCarrierFile.CarrierSiteIndex.html","title":"Class: CarrierSiteIndex","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: CarrierSiteIndex CarrierSiteIndex new CarrierSiteIndex() Tuple for location refered to by carrier+site index Properties: Name Type Description carrierId integer ID for the carrier siteIndex integer 0-based index of site Source: EvowareCarrierFile.js, line 30 × Search results Close "},"module-evoware_EvowareCarrierFile.EvowareCarrierData.html":{"id":"module-evoware_EvowareCarrierFile.EvowareCarrierData.html","title":"Class: EvowareCarrierData","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: EvowareCarrierData EvowareCarrierData new EvowareCarrierData() An object representing an evoware carrier file Properties: Name Type Description models object map from model name to model data idToName object map of model ID to model name carrierIdToVectors object map of carrier ID to list of Vectors Source: EvowareCarrierFile.js, line 113 × Search results Close "},"module-evoware_EvowareCarrierFile.LabwareModel.html":{"id":"module-evoware_EvowareCarrierFile.LabwareModel.html","title":"Class: LabwareModel","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: LabwareModel LabwareModel new LabwareModel() An evoware labware model Properties: Name Type Description type string should be &quot;LabwareModel&quot; name string rows integer cols integer ul number maximum volume of wells sites array list of CarrierSiteIndexes where this labware can be placed. Source: EvowareCarrierFile.js, line 73 × Search results Close "},"module-evoware_EvowareCarrierFile.Vector.html":{"id":"module-evoware_EvowareCarrierFile.Vector.html","title":"Class: Vector","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: Vector Vector new Vector() A tranporter &quot;vector&quot;, related to movements that the RoMas can make Properties: Name Type Description type string should be &quot;Vector&quot; carrierId integer which carrier this vector is for clazz string Wide, Narrow, or user-defined romaId integer which RoMa this vector is for Source: EvowareCarrierFile.js, line 95 × Search results Close "},"module-evoware_EvowareTableFile.ExternalObject.html":{"id":"module-evoware_EvowareTableFile.ExternalObject.html","title":"Class: ExternalObject","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: ExternalObject ExternalObject new ExternalObject(n1, n2, carrierName) Represent an external object in an Evoware table file Parameters: Name Type Description n1 integer Value of unknown significance (4 for System, 0 for others?) n2 integer I think this is the on-screen display index carrierName string carrier name for the carrier holding this hotel/object Source: EvowareTableFile.js, line 27 × Search results Close "},"module-evoware_EvowareTableFile.HotelObject.html":{"id":"module-evoware_EvowareTableFile.HotelObject.html","title":"Class: HotelObject","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: HotelObject HotelObject new HotelObject(parentCarrierId, gridIndex) Represent a hotel object in an Evoware table file Parameters: Name Type Description parentCarrierId integer carrier ID for the carrier holding this hotel gridIndex integer grid index of the hotel Source: EvowareTableFile.js, line 14 × Search results Close "},"module-evoware_EvowareUtils.EvowareSemicolonFile.html":{"id":"module-evoware_EvowareUtils.EvowareSemicolonFile.html","title":"Class: EvowareSemicolonFile","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Class: EvowareSemicolonFile EvowareSemicolonFile new EvowareSemicolonFile(filename, skip) A class to handle Evoware's semicolon-based file format. Parameters: Name Type Description filename string path to semicolon file skip number number of lines to initially skip at the top of the file Source: EvowareUtils.js, line 77 × Search results Close "},"module-EvowareCarrierFile.html":{"id":"module-EvowareCarrierFile.html","title":"Module: EvowareCarrierFile","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: EvowareCarrierFile Loads data from an Evoware carrier file. Source: EvowareCarrierFile.js, line 1 Methods &lt;static&gt; load(filename) Load an evoware carrier file and return its model data. Parameters: Name Type Description filename string path to the carrier file Source: EvowareCarrierFile.js, line 164 Returns: Type EvowareCarrierData &lt;inner&gt; loadEvowareModels(filename) Parses the file Carrier.cfg into a list of EvowareModels. Parameters: Name Type Description filename string path to the carrier file Source: EvowareCarrierFile.js, line 208 Returns: an array of EvowareModels (e.g. Carriers, Vectors, EvowareLabwareModels) Type array &lt;inner&gt; makeEvowareCarrierData(modelList) Create an EvowareCarrierData object from an array of evoware models. Parameters: Name Type Description modelList array array of evoware models Source: EvowareCarrierFile.js, line 176 Returns: Type EvowareCarrierData &lt;inner&gt; parse13(l, lines) Parse a carrier object; carrier lines begin with &quot;13&quot; Parameters: Name Type Description l array array of string representing the elements of the current line lines EvowareSemicolonFile array of lines from the Carrier.cfg Source: EvowareCarrierFile.js, line 250 Returns: a Carrier. Type Carrier &lt;inner&gt; parse15(l, lines) Parse a labware object; labware lines begin with &quot;15&quot; Parameters: Name Type Description l array array of string representing the elements of the current line lines EvowareSemicolonFile array of lines from the Carrier.cfg Source: EvowareCarrierFile.js, line 272 Returns: a new LabwareModel. Type LabwareModel &lt;inner&gt; parse17(l, lines) Parse a vector object; vector lines begin with &quot;17&quot; Parameters: Name Type Description l array array of string representing the elements of the current line lines EvowareSemicolonFile array of lines from the Carrier.cfg Source: EvowareCarrierFile.js, line 322 Returns: a new Vector, if any Type Vector &lt;inner&gt; parse998(s) Parse a line with the expected lineType=998. Discards the linetype and just returns a list of strings elements. Parameters: Name Type Description s string the line Source: EvowareCarrierFile.js, line 342 Returns: array of line elements Type array &lt;inner&gt; parseModel(lines) Parse the line and return a model, if relevant. Parameters: Name Type Description lines EvowareSemicolonFile array of lines from the Carrier.cfg Source: EvowareCarrierFile.js, line 231 Returns: an optional model. Type array Type Definitions EvowareModel A base type for evoware models, one of Carrier, LabwareModel, or Vector. Type: object Properties: Name Type Description type string the type of model Source: EvowareCarrierFile.js, line 44 × Search results Close "},"module-EvowareCompiler.html":{"id":"module-EvowareCompiler.html","title":"Module: EvowareCompiler","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: EvowareCompiler Module for compiling an instruction list (created by roboliq) to an Evoware script. Source: EvowareCompiler.js, line 1 Methods &lt;static&gt; compile(carrierData, table, protocol, agents, options) Compile a protocol for a given evoware setup. Parameters: Name Type Description carrierData EvowareCarrierData table object table object (see EvowareTableFile.load) protocol roboliq:Protocol agents array string array of agent names that this script should generate script(s) for options object an optional map of options; e.g. set timing=false to avoid outputting time-logging instructions Source: EvowareCompiler.js, line 53 Returns: an array of {table, lines} items; one item is generated per required table layout. lines is an array of strings. Type array × Search results Close "},"module-EvowareConfigSpec.html":{"id":"module-EvowareConfigSpec.html","title":"Module: EvowareConfigSpec","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: EvowareConfigSpec Module for converting an EvowareConfigSpec to a general Roboliq configuration protocol. Source: EvowareConfigSpec.js, line 1 Methods &lt;inner&gt; handleRomas(spec) Create the predictates to be added to Roboliq's robot configuration for Evoware's RoMa relationships. Expect specs of this form: {&lt;transporter&gt;: {&lt;program&gt;: [site names]}} Parameters: Name Type Description spec Object Properties Name Type Description romas Array.&lt;Roma&gt; Source: EvowareConfigSpec.js, line 189 &lt;inner&gt; makeProtocol(spec [, data]) Convert an EvowareConfigSpec into the format of a Roboliq Protocol. This function exists, because it is much simpler to write an EvowareConfigSpec than the equivalent Protocol. Parameters: Name Type Argument Description spec EvowareConfigSpec specification of an Evoware robot configuration data Object &lt;optional&gt; (not currently used) protocol data loaded before this configuration Source: EvowareConfigSpec.js, line 24 Returns: an Evoware robot configuration in the format of a Protocol. Type Protocol &lt;inner&gt; validate(evowareSpec) Validates a EvowareConfigSpec against the JSON schema. Parameters: Name Type Description evowareSpec EvowareConfigSpec evoware config spec Source: EvowareConfigSpec.js, line 447 Returns: returns the validation results from the npm package jsonschema Type object × Search results Close "},"module-EvowareTableFile.html":{"id":"module-EvowareTableFile.html","title":"Module: EvowareTableFile","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: EvowareTableFile Module to load and save Evoware table files. Source: EvowareTableFile.js, line 1 Methods &lt;static&gt; load(carrierData, filename) Parses an Evoware .esc script file, extracting the table setup. Parameters: Name Type Description carrierData EvowareCarrierData filename string Source: EvowareTableFile.js, line 48 Returns: a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Type object &lt;static&gt; toString_internalCarriers(carrierData, table) Create a string representation of the internal carriers Parameters: Name Type Description carrierData EvowareCarrierData data loaded from an evoware carrier file table object a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Source: EvowareTableFile.js, line 295 Returns: string representation of internal carriers Type string &lt;static&gt; toStrings(carrierData, table) Create a string representation of an Evoware table layout Parameters: Name Type Description carrierData EvowareCarrierData data loaded from an evoware carrier file table object a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Source: EvowareTableFile.js, line 265 Returns: string representation of table layout Type string &lt;static&gt; toStrings_externals(carrierData, table) Create a string representation of external carriers Parameters: Name Type Description carrierData EvowareCarrierData data loaded from an evoware carrier file table object a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Source: EvowareTableFile.js, line 399 Returns: string representation of external carriers Type string &lt;static&gt; toStrings_hotels(carrierData, table) Create a string representation of the hotels Parameters: Name Type Description carrierData EvowareCarrierData data loaded from an evoware carrier file table object a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Source: EvowareTableFile.js, line 375 Returns: string representation of hotels Type string &lt;static&gt; toStrings_internalLabware(carrierData, table) Create a string representation of the internal labware Parameters: Name Type Description carrierData EvowareCarrierData data loaded from an evoware carrier file table object a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Source: EvowareTableFile.js, line 329 Returns: string representation of internal labware Type string &lt;inner&gt; parse14(carrierData, l, lines) Parse a table. Parameters: Name Type Description carrierData EvowareCarrierData l array array of string representing the elements of the current line lines EvowareSemicolonFile array of lines from the Carrier.cfg Source: EvowareTableFile.js, line 67 Returns: a table layout, keys are carrier names, sub-keys are gridIndexes or properties, sub-sub-keys are siteIndexes or property, and sub-sub-sub-keys {label, labwareModelName} Type object &lt;inner&gt; parse14_getCarrierIds(l) Extract array where the array index is the grid index and the value is the carrier ID. This information is on the first line of the table definition. A -1 value for the carrier ID means that there is no carrier at that grid. Parameters: Name Type Description l array elements of line Source: EvowareTableFile.js, line 158 Returns: array of carrier IDs on this table Type array &lt;inner&gt; parse14_getExternalLabwares(lines) Parse labware on external sites Parameters: Name Type Description lines EvowareSemicolonFile lines of table file Source: EvowareTableFile.js, line 235 Returns: list of tuples (carrier ID, labware model name) Type object &lt;inner&gt; parse14_getExternalObjects(lines) Parse the external objects. Parameters: Name Type Description lines EvowareSemicolonFile lines of table file Source: EvowareTableFile.js, line 216 Returns: an array of external objects Type array &lt;inner&gt; parse14_getHotelObjects(lines) Parse the hotel objects Parameters: Name Type Description lines EvowareSemicolonFile lines of table file Source: EvowareTableFile.js, line 198 Returns: an array of HotelObjects Type array &lt;inner&gt; parse14_getLabwareObjects(carrierData, lines) Get array of labwares on the table. Parameters: Name Type Description carrierData EvowareCarrierData lines EvowareSemicolonFile lines of table file Source: EvowareTableFile.js, line 168 Returns: an array of tuples (carrier name, gridIndex, siteIndex, site label, labware model name) Type array × Search results Close "},"module-EvowareUtils.html":{"id":"module-EvowareUtils.html","title":"Module: EvowareUtils","body":" roboliq-evoware Modules commands/evowarecommands/evowareHelpercommands/pipettercommands/transporterequipment/centrifuge4equipment/evowareequipment/reader-InfiniteM200Proequipment/shaker-Tecan1EvowareCarrierFileEvowareCompilerEvowareConfigSpecEvowareTableFileEvowareUtils Classes evoware/EvowareCarrierFile.Carrierevoware/EvowareCarrierFile.CarrierGridSiteIndexevoware/EvowareCarrierFile.CarrierSiteIndexevoware/EvowareCarrierFile.EvowareCarrierDataevoware/EvowareCarrierFile.LabwareModelevoware/EvowareCarrierFile.Vectorevoware/EvowareTableFile.ExternalObjectevoware/EvowareTableFile.HotelObjectevoware/EvowareUtils.EvowareSemicolonFile Module: EvowareUtils A collection of helper utilities for our Evoware compiler. Source: EvowareUtils.js, line 1 Methods &lt;static&gt; decode() Decode a character to an integer. Source: EvowareUtils.js, line 23 &lt;static&gt; encode(n) Encode an integer as an ASCII character. Evoware uses this to generate a string representing a list of wells or sites. Parameters: Name Type Description n number integer to encode as a character Source: EvowareUtils.js, line 16 Returns: a single-character string that represents the number Type string &lt;static&gt; hex(n) Convert the number to hex. Number should be between 0 and 15. Parameters: Name Type Description n integer number between 0 and 15 Source: EvowareUtils.js, line 32 Returns: Type char &lt;static&gt; parseEncodedIndexes(encoded) Takes an encoding of indexes on a 2D surface (as found in the file Carrier.cfg) and Parameters: Name Type Description encoded string an encoded list of indexes Source: EvowareUtils.js, line 42 Returns: tuple of [rows on surface, columns on surface, selected indexes on surface] Type array &lt;static&gt; splitSemicolons(line) Split an evoware carrier line into its components. The first component is an integer that identifies the type of line. The remaining components are returned as a list of string. Parameters: Name Type Description line string a text line from Evoware's carrier file Source: EvowareUtils.js, line 71 Returns: Returns a pair [kind, items], where kind is an integer identifying the type of line, and items is a string array of the remaining components of the line. Type array × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
