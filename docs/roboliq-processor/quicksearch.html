<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"config_ourlab_luigi.js.html":{"id":"config_ourlab_luigi.js.html","title":"Source: config/ourlab_luigi.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: config/ourlab_luigi.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ var _ = require('lodash'); import assert from 'assert'; var math = require('mathjs'); var commandHelper = require('../commandHelper.js'); var expect = require('../expect.js'); import {makeEvowareFacts, makeSiteModelPredicates, makeTransporterPredicates} from '../evoware/equipment/evoware.js'; const Equipment = { evoware: require('../evoware/equipment/evoware.js'), reader: require('../evoware/equipment/reader-InfiniteM200Pro.js'), sealer: require('../evoware/equipment/sealer-Tecan.js'), }; module.exports = { roboliq: &quot;v1&quot;, imports: [&quot;roboliq.js&quot;], objects: { &quot;ourlab&quot;: { &quot;type&quot;: &quot;Namespace&quot;, &quot;luigi&quot;: { &quot;type&quot;: &quot;Namespace&quot;, &quot;culturebox&quot;: { &quot;type&quot;: &quot;Incubator&quot;, &quot;sitesInternal&quot;: [&quot;ourlab.luigi.site.BOX_1&quot;, &quot;ourlab.luigi.site.BOX_2&quot;, &quot;ourlab.luigi.site.BOX_3&quot;, &quot;ourlab.luigi.site.BOX_4&quot;, &quot;ourlab.luigi.site.BOX_5&quot;, &quot;ourlab.luigi.site.BOX_6&quot;, &quot;ourlab.luigi.site.BOX_7&quot;, &quot;ourlab.luigi.site.BOX_8&quot;], &quot;evowareId&quot;: &quot;Kuehner&quot; }, &quot;evoware&quot;: { &quot;type&quot;: &quot;EvowareRobot&quot;, config: { TEMPDIR: &quot;C:\\\\Users\\\\localadmin\\\\Desktop\\\\Ellis\\\\temp&quot;, ROBOLIQ: &quot;wscript C:\\\\Users\\\\localadmin\\\\Documents\\\\Ellis\\\\roboliq\\\\roboliq-runtime-cli\\\\roboliq-runtime-cli.vbs&quot; } }, &quot;reader&quot;: { &quot;type&quot;: &quot;Reader&quot;, &quot;sitesInternal&quot;: [&quot;ourlab.luigi.site.READER&quot;], &quot;evowareId&quot;: &quot;ReaderNETwork&quot;, &quot;modelToPlateFile&quot;: { &quot;ourlab.model.plateModel_96_round_transparent_nunc&quot;: &quot;COR96fc UV transparent&quot; } }, &quot;roma1&quot;: { &quot;type&quot;: &quot;Transporter&quot;, &quot;evowareRoma&quot;: 0 }, &quot;roma2&quot;: { &quot;type&quot;: &quot;Transporter&quot;, &quot;evowareRoma&quot;: 1 }, &quot;liha&quot;: { &quot;type&quot;: &quot;Pipetter&quot;, &quot;syringe&quot;: { &quot;1&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 1 }, &quot;2&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 2 }, &quot;3&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 3 }, &quot;4&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 4 }, &quot;5&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 5 }, &quot;6&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 6 }, &quot;7&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 7 }, &quot;8&quot;: { &quot;type&quot;: &quot;Syringe&quot;, &quot;tipModel&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, &quot;tipModelPermanent&quot;: &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;, row: 8 } }, &quot;tipModel&quot;: { &quot;tipModel2500&quot;: {&quot;type&quot;: &quot;TipModel&quot;, &quot;programCode&quot;: &quot;2500&quot;, &quot;min&quot;: &quot;10ul&quot;, &quot;max&quot;: &quot;2250ul&quot;, &quot;canHandleSeal&quot;: true, &quot;canHandleCells&quot;: true}, }, &quot;tipModelToSyringes&quot;: { &quot;ourlab.luigi.liha.tipModel.tipModel2500&quot;: [&quot;ourlab.luigi.liha.syringe.1&quot;, &quot;ourlab.luigi.liha.syringe.2&quot;, &quot;ourlab.luigi.liha.syringe.3&quot;, &quot;ourlab.luigi.liha.syringe.4&quot;, &quot;ourlab.luigi.liha.syringe.5&quot;, &quot;ourlab.luigi.liha.syringe.6&quot;, &quot;ourlab.luigi.liha.syringe.7&quot;, &quot;ourlab.luigi.liha.syringe.8&quot;] } }, &quot;sealer&quot;: { &quot;type&quot;: &quot;Sealer&quot;, &quot;evowareId&quot;: &quot;RoboSeal&quot; }, &quot;shaker&quot;: { &quot;type&quot;: &quot;Shaker&quot;, &quot;evowareId&quot;: &quot;Shaker&quot; }, &quot;site&quot;: { &quot;type&quot;: &quot;Namespace&quot;, BOX_1: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 2, closed: true }, BOX_2: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 4, closed: true }, BOX_3: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 6, closed: true }, BOX_4: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 8, closed: true }, BOX_5: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 10, closed: true }, BOX_6: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 12, closed: true }, BOX_7: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 14, closed: true }, BOX_8: { type: &quot;Site&quot;, evowareCarrier: &quot;Kuhner Shaker ES-X 2x4x2Pos&quot;, evowareGrid: 50, evowareSite: 16, closed: true }, HOTEL12_1: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 1 }, HOTEL12_2: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 2 }, HOTEL12_3: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 3 }, HOTEL12_4: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 4 }, HOTEL12_5: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 5 }, HOTEL12_6: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 6 }, HOTEL12_7: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 7 }, HOTEL12_8: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 8 }, HOTEL12_9: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 9 }, HOTEL12_10: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 10 }, HOTEL12_11: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 11 }, //HOTEL12_12: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 3x4Pos Grid25to39&quot;, evowareGrid: 25, evowareSite: 12 }, INCUBATOR1_1: { type: &quot;Site&quot;, evowareCarrier: &quot;Incubator1&quot;, evowareGrid: 1, evowareSite: 4, closed: true }, INCUBATOR1_2: { type: &quot;Site&quot;, evowareCarrier: &quot;Incubator1&quot;, evowareGrid: 1, evowareSite: 3, closed: true }, INCUBATOR1_3: { type: &quot;Site&quot;, evowareCarrier: &quot;Incubator1&quot;, evowareGrid: 1, evowareSite: 2, closed: true }, INCUBATOR1_4: { type: &quot;Site&quot;, evowareCarrier: &quot;Incubator1&quot;, evowareGrid: 1, evowareSite: 1, closed: true }, LIGHT: { type: &quot;Site&quot;, evowareCarrier: &quot;Pickolo-Light-Table&quot;, evowareGrid: 29, evowareSite: 1 }, P1: { type: &quot;Site&quot;, evowareCarrier: &quot;MP 2Pos Flat with Downholder&quot;, evowareGrid: 13, evowareSite: 1 }, P2: { type: &quot;Site&quot;, evowareCarrier: &quot;MP 2Pos Flat with Downholder&quot;, evowareGrid: 13, evowareSite: 2 }, P3: { type: &quot;Site&quot;, evowareCarrier: &quot;Downholder DWB&quot;, evowareGrid: 12, evowareSite: 1 }, P4: { type: &quot;Site&quot;, evowareCarrier: &quot;MP 3Pos Flat Grid19&quot;, evowareGrid: 19, evowareSite: 1 }, P5: { type: &quot;Site&quot;, evowareCarrier: &quot;MP 3Pos Flat Grid19&quot;, evowareGrid: 19, evowareSite: 2 }, P6: { type: &quot;Site&quot;, evowareCarrier: &quot;MP 3Pos Flat Grid19&quot;, evowareGrid: 19, evowareSite: 3 }, R1: { type: &quot;Site&quot;, evowareCarrier: &quot;Trough 1500ml StainlessSteel&quot;, evowareGrid: 37, evowareSite: 1 }, R2: { type: &quot;Site&quot;, evowareCarrier: &quot;Trough 3Pos 25+100ml&quot;, evowareGrid: 40, evowareSite: 1 }, R3: { type: &quot;Site&quot;, evowareCarrier: &quot;Trough 3Pos 25+100ml&quot;, evowareGrid: 40, evowareSite: 2 }, R4: { type: &quot;Site&quot;, evowareCarrier: &quot;Trough 3Pos 25+100ml&quot;, evowareGrid: 40, evowareSite: 3 }, READER: { type: &quot;Site&quot;, evowareCarrier: &quot;Infinite 200&quot;, evowareGrid: 6, evowareSite: 1, closed: true }, REGRIP_ABOVE: { type: &quot;Site&quot;, evowareCarrier: &quot;ReGrip above&quot;, evowareGrid: 8, evowareSite: 1, siteIdUnique: &quot;ourlab.luigi.REGRIP&quot; }, REGRIP_BELOW: { type: &quot;Site&quot;, evowareCarrier: &quot;ReGrip below&quot;, evowareGrid: 9, evowareSite: 1, siteIdUnique: &quot;ourlab.luigi.REGRIP&quot; }, ROBOSEAL: { &quot;type&quot;: &quot;Site&quot;, &quot;evowareCarrier&quot;: &quot;RoboSeal&quot;, &quot;evowareGrid&quot;: 45, &quot;evowareSite&quot;: 1 }, SHAKER: { type: &quot;Site&quot;, evowareCarrier: &quot;Te-Shake 1Pos Front&quot;, evowareGrid: 44, evowareSite: 1 }, TRANSFER_1: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 4Pos Transfer Grid 0&quot;, evowareGrid: 7, evowareSite: 1 }, TRANSFER_2: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 4Pos Transfer Grid 0&quot;, evowareGrid: 7, evowareSite: 2 }, TRANSFER_3: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 4Pos Transfer Grid 0&quot;, evowareGrid: 7, evowareSite: 3 }, TRANSFER_4: { type: &quot;Site&quot;, evowareCarrier: &quot;Hotel 4Pos Transfer Grid 0&quot;, evowareGrid: 7, evowareSite: 4 }, &quot;SYSTEM&quot;: { &quot;type&quot;: &quot;Site&quot;, &quot;evowareCarrier&quot;: &quot;System&quot;, &quot;evowareGrid&quot;: -1, &quot;evowareSite&quot;: 0 }, }, &quot;systemLiquidLabwareModel&quot;: { &quot;type&quot;: &quot;PlateModel&quot;, &quot;description&quot;: &quot;dummy labware model representing the system liquid source&quot;, &quot;rows&quot;: 8, &quot;columns&quot;: 1, &quot;evowareName&quot;: &quot;SystemLiquid&quot; }, &quot;systemLiquid&quot;: { &quot;type&quot;: &quot;Liquid&quot;, &quot;wells&quot;: [ &quot;ourlab.luigi.systemLiquidLabware(A01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(B01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(C01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(D01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(E01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(F01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(G01)&quot;, &quot;ourlab.luigi.systemLiquidLabware(H01)&quot; ] }, &quot;systemLiquidLabware&quot;: { &quot;type&quot;: &quot;Plate&quot;, &quot;description&quot;: &quot;dummy labware representing the system liquid source&quot;, &quot;model&quot;: &quot;ourlab.luigi.systemLiquidLabwareModel&quot;, &quot;location&quot;: &quot;ourlab.luigi.site.SYSTEM&quot;, &quot;contents&quot;: [&quot;Infinity l&quot;, &quot;systemLiquid&quot;] }, &quot;timer1&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 1 }, &quot;timer2&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 2 }, &quot;timer3&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 3 }, &quot;timer4&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 4 }, &quot;timer5&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 5 }, &quot;timer6&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 6 }, &quot;timer7&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 7 }, &quot;timer8&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 8 }, &quot;timer9&quot;: { &quot;type&quot;: &quot;Timer&quot;, &quot;evowareId&quot;: 9 }, &quot;washProgram&quot;: { // FIXME: figure out proper wash programs &quot;type&quot;: &quot;Namespace&quot;, &quot;flush_2500&quot;: { &quot;type&quot;: &quot;EvowareWashProgram&quot;, &quot;wasteGrid&quot;: 42, &quot;wasteSite&quot;: 2, &quot;cleanerGrid&quot;: 42, &quot;cleanerSite&quot;: 3, &quot;wasteVolume&quot;: 0.15, &quot;wasteDelay&quot;: 500, &quot;cleanerVolume&quot;: 0.15, &quot;cleanerDelay&quot;: 500, &quot;airgapVolume&quot;: 10, &quot;airgapSpeed&quot;: 70, &quot;retractSpeed&quot;: 30, &quot;fastWash&quot;: true }, &quot;light_2500&quot;: { // FIXME: IS THIS REALLY LIGHT? &quot;type&quot;: &quot;EvowareWashProgram&quot;, &quot;wasteGrid&quot;: 42, &quot;wasteSite&quot;: 2, &quot;cleanerGrid&quot;: 42, &quot;cleanerSite&quot;: 3, &quot;wasteVolume&quot;: 1, &quot;wasteDelay&quot;: 500, &quot;cleanerVolume&quot;: 2, &quot;cleanerDelay&quot;: 500, &quot;airgapVolume&quot;: 10, &quot;airgapSpeed&quot;: 70, &quot;retractSpeed&quot;: 30, &quot;fastWash&quot;: true }, &quot;thorough_2500&quot;: { // FIXME: IS THIS REALLY THOROUGH? &quot;type&quot;: &quot;EvowareWashProgram&quot;, &quot;wasteGrid&quot;: 42, &quot;wasteSite&quot;: 2, &quot;cleanerGrid&quot;: 42, &quot;cleanerSite&quot;: 3, &quot;wasteVolume&quot;: 6, &quot;wasteDelay&quot;: 500, &quot;cleanerVolume&quot;: 8, &quot;cleanerDelay&quot;: 500, &quot;airgapVolume&quot;: 10, &quot;airgapSpeed&quot;: 70, &quot;retractSpeed&quot;: 30, &quot;fastWash&quot;: true }, &quot;decontaminate_2500&quot;: { &quot;type&quot;: &quot;EvowareWashProgram&quot;, &quot;script&quot;: &quot;C:\\\\ProgramData\\\\Tecan\\\\EVOware\\\\database\\\\scripts\\\\Roboliq_Clean_Decontaminate.esc&quot; }, } }, &quot;model&quot;: { &quot;type&quot;: &quot;Namespace&quot;, &quot;plateModel_96_dwp&quot;: { &quot;type&quot;: &quot;PlateModel&quot;, &quot;label&quot;: &quot;96 well deep-well plate&quot;, &quot;rows&quot;: 8, &quot;columns&quot;: 12, &quot;evowareName&quot;: &quot;DM 96-DWB GripUp&quot;, &quot;evowareName_sealed&quot;: &quot;DM 96 DWB GripUp sealed&quot; }, &quot;plateModel_96_dwp_sealed&quot;: { &quot;type&quot;: &quot;PlateModel&quot;, &quot;label&quot;: &quot;96 well deep-well plate (sealed)&quot;, &quot;rows&quot;: 8, &quot;columns&quot;: 12, &quot;evowareName&quot;: &quot;DM 96 DWB GripUp sealed&quot; }, &quot;plateModel_96_round_transparent_nunc&quot;: { &quot;type&quot;: &quot;PlateModel&quot;, &quot;label&quot;: &quot;96 round-well transparent Nunc plate&quot;, &quot;rows&quot;: 8, &quot;columns&quot;: 12, &quot;evowareName&quot;: &quot;Ellis Nunc F96 MicroWell&quot; }, &quot;troughModel_100ml&quot;: { &quot;type&quot;: &quot;PlateModel&quot;, &quot;label&quot;: &quot;Trough 100ml&quot;, &quot;rows&quot;: 8, &quot;columns&quot;: 1, &quot;evowareName&quot;: &quot;Trough 100ml&quot; }, &quot;troughModel_1500ml&quot;: { &quot;type&quot;: &quot;PlateModel&quot;, &quot;label&quot;: &quot;Trough 1500ml Stainless&quot;, &quot;rows&quot;: 8, &quot;columns&quot;: 1, &quot;evowareName&quot;: &quot;Trough 1500ml Stainless&quot; }, } } }, objectToPredicateConverters: _.merge({}, Equipment.evoware.objectToPredicateConverters ), predicates: _.flatten([ // Deepwell plates only makeSiteModelPredicates({ siteModel: &quot;ourlab.luigi.siteModel_DWP&quot;, sites: [ &quot;ourlab.luigi.site.P3&quot;, &quot;ourlab.luigi.site.BOX_1&quot;, &quot;ourlab.luigi.site.BOX_2&quot;, &quot;ourlab.luigi.site.BOX_3&quot;, &quot;ourlab.luigi.site.BOX_4&quot;, &quot;ourlab.luigi.site.BOX_5&quot;, &quot;ourlab.luigi.site.BOX_6&quot;, &quot;ourlab.luigi.site.BOX_7&quot;, &quot;ourlab.luigi.site.BOX_8&quot;, ], labwareModels: [&quot;ourlab.model.plateModel_96_dwp&quot;, &quot;ourlab.model.plateModel_96_dwp_sealed&quot;] }), // Shallow plates only makeSiteModelPredicates({ siteModel: &quot;ourlab.luigi.siteModel_shallow&quot;, sites: [ &quot;ourlab.luigi.site.HOTEL12_1&quot;, &quot;ourlab.luigi.site.HOTEL12_5&quot;, &quot;ourlab.luigi.site.HOTEL12_9&quot;, &quot;ourlab.luigi.site.READER&quot; ], labwareModels: [&quot;ourlab.model.plateModel_96_round_transparent_nunc&quot;] }), // Deepwell blocks + microwell makeSiteModelPredicates({ siteModel: &quot;ourlab.luigi.siteModel1&quot;, sites: [ &quot;ourlab.luigi.site.HOTEL12_2&quot;, &quot;ourlab.luigi.site.HOTEL12_3&quot;, &quot;ourlab.luigi.site.HOTEL12_4&quot;, &quot;ourlab.luigi.site.HOTEL12_6&quot;, &quot;ourlab.luigi.site.HOTEL12_7&quot;, &quot;ourlab.luigi.site.HOTEL12_8&quot;, &quot;ourlab.luigi.site.HOTEL12_9&quot;, &quot;ourlab.luigi.site.HOTEL12_10&quot;, &quot;ourlab.luigi.site.HOTEL12_11&quot;, &quot;ourlab.luigi.site.P1&quot;, &quot;ourlab.luigi.site.P2&quot;, &quot;ourlab.luigi.site.P4&quot;, &quot;ourlab.luigi.site.P5&quot;, &quot;ourlab.luigi.site.P6&quot;, &quot;ourlab.luigi.site.LIGHT&quot;, &quot;ourlab.luigi.site.REGRIP_ABOVE&quot;, &quot;ourlab.luigi.site.REGRIP_BELOW&quot;, &quot;ourlab.luigi.site.ROBOSEAL&quot;, &quot;ourlab.luigi.site.SHAKER&quot;, &quot;ourlab.luigi.site.TRANSFER_1&quot;, &quot;ourlab.luigi.site.TRANSFER_2&quot;, &quot;ourlab.luigi.site.TRANSFER_3&quot;, &quot;ourlab.luigi.site.TRANSFER_4&quot;, ], labwareModels: [&quot;ourlab.model.plateModel_96_dwp&quot;, &quot;ourlab.model.plateModel_96_dwp_sealed&quot;, &quot;ourlab.model.plateModel_96_round_transparent_nunc&quot;] }), makeTransporterPredicates(&quot;ourlab.luigi&quot;, &quot;ourlab.luigi.evoware&quot;, { &quot;ourlab.luigi.roma1&quot;: { Narrow: [ [ &quot;ourlab.luigi.site.REGRIP_ABOVE&quot;, &quot;ourlab.luigi.site.P1&quot;, &quot;ourlab.luigi.site.P2&quot;, &quot;ourlab.luigi.site.P3&quot;, &quot;ourlab.luigi.site.LIGHT&quot; ], [ &quot;ourlab.luigi.site.HOTEL12_1&quot;, &quot;ourlab.luigi.site.HOTEL12_2&quot;, &quot;ourlab.luigi.site.HOTEL12_3&quot;, &quot;ourlab.luigi.site.HOTEL12_4&quot;, &quot;ourlab.luigi.site.HOTEL12_5&quot;, &quot;ourlab.luigi.site.HOTEL12_6&quot;, &quot;ourlab.luigi.site.HOTEL12_7&quot;, &quot;ourlab.luigi.site.HOTEL12_8&quot;, &quot;ourlab.luigi.site.HOTEL12_9&quot;, &quot;ourlab.luigi.site.HOTEL12_10&quot;, &quot;ourlab.luigi.site.HOTEL12_11&quot;, /*&quot;ourlab.luigi.site.HOTEL12_12&quot;*/, &quot;ourlab.luigi.site.P4&quot;, &quot;ourlab.luigi.site.P5&quot;, &quot;ourlab.luigi.site.P6&quot;, &quot;ourlab.luigi.site.REGRIP_BELOW&quot;, &quot;ourlab.luigi.site.TRANSFER_1&quot;, &quot;ourlab.luigi.site.TRANSFER_2&quot;, &quot;ourlab.luigi.site.TRANSFER_3&quot;, &quot;ourlab.luigi.site.TRANSFER_4&quot;, ], [&quot;ourlab.luigi.site.REGRIP_ABOVE&quot;, &quot;ourlab.luigi.site.REGRIP_BELOW&quot;], [&quot;ourlab.luigi.site.P4&quot;, &quot;ourlab.luigi.site.P5&quot;, &quot;ourlab.luigi.site.P6&quot;, &quot;ourlab.luigi.site.READER&quot;, &quot;ourlab.luigi.site.REGRIP_BELOW&quot;], ], }, &quot;ourlab.luigi.roma2&quot;: { Narrow: [ [ &quot;ourlab.luigi.site.BOX_1&quot;, &quot;ourlab.luigi.site.BOX_2&quot;, &quot;ourlab.luigi.site.BOX_3&quot;, &quot;ourlab.luigi.site.BOX_4&quot;, &quot;ourlab.luigi.site.BOX_5&quot;, &quot;ourlab.luigi.site.BOX_6&quot;, &quot;ourlab.luigi.site.BOX_7&quot;, &quot;ourlab.luigi.site.BOX_8&quot;, &quot;ourlab.luigi.site.LIGHT&quot; ], [ &quot;ourlab.luigi.site.P1&quot;, &quot;ourlab.luigi.site.P2&quot;, &quot;ourlab.luigi.site.P4&quot;, &quot;ourlab.luigi.site.P5&quot;, &quot;ourlab.luigi.site.P6&quot;, &quot;ourlab.luigi.site.LIGHT&quot;, &quot;ourlab.luigi.site.ROBOSEAL&quot;, &quot;ourlab.luigi.site.SHAKER&quot;, ], ] } }), {&quot;#for&quot;: { factors: {model: [&quot;plateModel_96_round_transparent_nunc&quot;]}, output: { &quot;absorbanceReader.canAgentEquipmentModelSite&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.reader&quot;, &quot;model&quot;: &quot;ourlab.model.{{model}}&quot;, &quot;site&quot;: &quot;ourlab.luigi.site.READER&quot; } } }}, {&quot;#for&quot;: { factors: {model: [&quot;plateModel_96_round_transparent_nunc&quot;]}, output: { &quot;fluorescenceReader.canAgentEquipmentModelSite&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.reader&quot;, &quot;model&quot;: &quot;ourlab.model.{{model}}&quot;, &quot;site&quot;: &quot;ourlab.luigi.site.READER&quot; } } }}, { &quot;sealer.canAgentEquipmentProgramModelSite&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.sealer&quot;, &quot;program&quot;: &quot;C:\\\\INSTALLFOLDER_NOVEMBER2014_30096901_CH_ETHBS\\\\PLATTENPROGRAMM FUER ROBOSEAL\\\\MTP Riplate SW 2ml.bcf&quot;, &quot;model&quot;: &quot;ourlab.model.plateModel_96_dwp&quot;, &quot;site&quot;: &quot;ourlab.luigi.site.ROBOSEAL&quot; } }, { &quot;sealer.canAgentEquipmentProgramModelSite&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.sealer&quot;, &quot;program&quot;: &quot;C:\\\\INSTALLFOLDER_NOVEMBER2014_30096901_CH_ETHBS\\\\PLATTENPROGRAMM FUER ROBOSEAL\\\\MTP Riplate SW 2ml.bcf&quot;, &quot;model&quot;: &quot;ourlab.model.plateModel_96_dwp_sealed&quot;, &quot;site&quot;: &quot;ourlab.luigi.site.ROBOSEAL&quot; } }, { &quot;shaker.canAgentEquipment&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.culturebox&quot; } }, { &quot;shaker.canAgentEquipment&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.shaker&quot; } }, { &quot;shaker.canAgentEquipmentSite&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.shaker&quot;, &quot;site&quot;: &quot;ourlab.luigi.site.SHAKER&quot; } }, { &quot;pipetter.canAgentEquipment&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.liha&quot; } }, {&quot;#for&quot;: { factors: {site: [&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;, &quot;P5&quot;, &quot;P6&quot;, &quot;LIGHT&quot;, &quot;SYSTEM&quot;, &quot;R1&quot;, &quot;R2&quot;, &quot;R3&quot;, &quot;R4&quot;]}, output: { &quot;pipetter.canAgentEquipmentSite&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.liha&quot;, &quot;site&quot;: &quot;ourlab.luigi.site.{{site}}&quot; } } }}, {&quot;#for&quot;: { factors: {i: [1, 2, 3, 4, 5, 6, 7, 8]}, output: { &quot;pipetter.canAgentEquipmentSyringe&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.liha&quot;, &quot;syringe&quot;: &quot;ourlab.luigi.liha.syringe.{{i}}&quot; } } }}, _.map(_.range(9), i =&gt; ({&quot;timer.canAgentEquipment&quot;: { &quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.timer&quot;+(i+1), }})), _.map([1,2,3,4,5,6,7,8], function(n) { return {&quot;method&quot;: {&quot;description&quot;: &quot;generic.closeSite-BOX_&quot;+n, &quot;task&quot;: {&quot;generic.closeSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [ {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site&quot;, &quot;thing2&quot;: &quot;ourlab.luigi.site.BOX_&quot;+n}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;ourlab.luigi.culturebox.close&quot;: {&quot;agent&quot;: &quot;ourlab.luigi.evoware&quot;, &quot;equipment&quot;: &quot;ourlab.luigi.culturebox&quot;}} ]} }} }), {&quot;action&quot;: {&quot;description&quot;: &quot;ourlab.luigi.culturebox.close: close the culturebox&quot;, &quot;task&quot;: {&quot;ourlab.luigi.culturebox.close&quot;: {&quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot;}}, &quot;preconditions&quot;: [], &quot;deletions&quot;: [], &quot;additions&quot;: [ {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_1&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_2&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_3&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_4&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_5&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_6&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_7&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_8&quot;}} ] }}, _.map([1,2,3,4,5,6,7,8], function(n) { return {&quot;method&quot;: {&quot;description&quot;: &quot;generic.openSite-BOX_&quot;+n, &quot;task&quot;: {&quot;generic.openSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [{&quot;same&quot;: {&quot;thing1&quot;: &quot;?site&quot;, &quot;thing2&quot;: &quot;ourlab.luigi.site.BOX_&quot;+n}}], &quot;subtasks&quot;: {&quot;ordered&quot;: [{&quot;ourlab.luigi.culturebox.stopAndOpen&quot;: {}}]} }}; }), {&quot;action&quot;: {&quot;description&quot;: &quot;ourlab.luigi.culturebox.open: open the culturebox&quot;, &quot;task&quot;: {&quot;ourlab.luigi.culturebox.stopAndOpen&quot;: {}}, &quot;preconditions&quot;: [], &quot;deletions&quot;: [ {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_1&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_2&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_3&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_4&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_5&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_6&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_7&quot;}}, {&quot;siteIsClosed&quot;: {&quot;site&quot;: &quot;ourlab.luigi.site.BOX_8&quot;}} ], &quot;additions&quot;: [] }}, Equipment.reader.getPredicates(&quot;ourlab.luigi.evoware&quot;, &quot;ourlab.luigi.reader&quot;, &quot;ourlab.luigi.site.READER&quot;) ]), schemas: _.merge( { &quot;equipment.close|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, }, required: [&quot;agent&quot;, &quot;equipment&quot;] }, &quot;equipment.open|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, }, required: [&quot;agent&quot;, &quot;equipment&quot;] }, &quot;equipment.run|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: { description: &quot;Program for shaking and incubating&quot;, type: &quot;object&quot;, properties: { rpm: {type: &quot;number&quot;, default: 300}, duration: {type: &quot;Duration&quot;}, temperature: {type: &quot;Temperature&quot;} } } }, required: [&quot;program&quot;] }, &quot;equipment.start|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: { description: &quot;Program for shaking and incubating&quot;, type: &quot;object&quot;, properties: { rpm: {type: &quot;number&quot;, default: 300}, temperature: {type: &quot;Temperature&quot;} } } }, required: [&quot;program&quot;] }, &quot;equipment.stop|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, } }, &quot;shaker.run|ourlab.luigi.evoware|ourlab.luigi.shaker&quot;: { properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: {description: &quot;Program identifier for shaking&quot;, type: &quot;string&quot;} } }, &quot;pipetter.cleanTips|ourlab.luigi.evoware|ourlab.luigi.liha&quot;: { description: &quot;Clean the pipetter tips.&quot;, properties: { agent: {description: &quot;Agent identifier&quot;, type: &quot;Agent&quot;}, equipment: {description: &quot;Equipment identifier&quot;, type: &quot;Equipment&quot;}, program: {description: &quot;Program identifier&quot;, type: &quot;string&quot;}, items: { description: &quot;List of which syringes to clean at which intensity&quot;, type: &quot;array&quot;, items: { type: &quot;object&quot;, properties: { syringe: {description: &quot;Syringe identifier&quot;, type: &quot;Syringe&quot;}, intensity: {description: &quot;Intensity of the cleaning&quot;, type: &quot;pipetter.CleaningIntensity&quot;} }, required: [&quot;syringe&quot;, &quot;intensity&quot;] } } }, required: [&quot;agent&quot;, &quot;equipment&quot;, &quot;items&quot;] } }, Equipment.evoware.getSchemas(), Equipment.reader.getSchemas(&quot;ourlab.luigi.evoware&quot;, &quot;ourlab.luigi.reader&quot;), Equipment.sealer.getSchemas(&quot;ourlab.luigi.evoware&quot;, &quot;ourlab.luigi.sealer&quot;) ), commandHandlers: _.merge( { &quot;equipment.close|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: function(params, parsed, data) { const expansion = [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: &quot;Cover&quot;, factsVariable: &quot;Cover_Close&quot; } ]; return {expansion}; }, &quot;equipment.open|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: function(params, parsed, data) { var effects = _.merge( // Indicate the the equipment is open and not running { [`${parsed.objectName.equipment}.open`]: true, [`${parsed.objectName.equipment}.running`]: false }, // Indicate that the internal sites are open _.fromPairs(_.map(parsed.value.equipment.sitesInternal, site =&gt; [`${site}.closed`, false])) ); // Stop and open const expansion = [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: &quot;Kuehner&quot;, factsVariable: &quot;Kuehner_stop&quot; }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: &quot;Cover&quot;, factsVariable: &quot;Cover_Open&quot; } ]; return {expansion, effects}; }, &quot;equipment.start|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: function(params, parsed, data) { // console.log(&quot;equipment.run|ourlab.luigi.evoware|ourlab.luigi.culturebox:&quot;); console.log({parsed, params}) const equipmentId = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); const parsedProgram = parsed.value.program; //console.log({parsedProgram}); const expansion = [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_start&quot;, factsValue: parsedProgram.rpm }, ]; return {expansion}; }, &quot;equipment.stop|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: function(params, parsed, data) { // console.log(&quot;equipment.run|ourlab.luigi.evoware|ourlab.luigi.culturebox:&quot;); console.log({parsed, params}) const equipmentId = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); const expansion = [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_stop&quot; }, ]; return {expansion}; }, &quot;equipment.run|ourlab.luigi.evoware|ourlab.luigi.culturebox&quot;: function(params, parsed, data) { // console.log(&quot;shaker.run|ourlab.luigi.evoware|ourlab.luigi.culturebox:&quot;); console.log({parsed, params}) const equipmentId = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); const parsedProgram = parsed.value.program; //console.log({parsedProgram}); const expansion = [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_start&quot;, factsValue: parsedProgram.rpm }, { command: &quot;timer.sleep&quot;, agent: parsed.objectName.agent, duration: parsed.orig.program.duration }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_stop&quot; }, ]; return {expansion}; }, // Shaker &quot;equipment.run|ourlab.luigi.evoware|ourlab.luigi.shaker&quot;: function(params, parsed, data) { //console.log(&quot;equipment.run|ourlab.luigi.evoware|ourlab.luigi.shaker: &quot;+JSON.stringify(parsed, null, '\\t')) const equipmentId = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;evowareId&quot;); const rpm = parsed.value.program.rpm || 750; return { expansion: [ { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_Init&quot; }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_SetFrequency&quot;, factsValue: rpm }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_Start&quot;, factsValue: &quot;1&quot; }, { command: &quot;timer.sleep&quot;, agent: parsed.objectName.agent, duration: parsed.orig.program.duration }, { command: &quot;evoware._facts&quot;, agent: parsed.objectName.agent, factsEquipment: equipmentId, factsVariable: equipmentId+&quot;_Stop&quot; }, ] }; }, // Clean tips &quot;pipetter.cleanTips|ourlab.luigi.evoware|ourlab.luigi.liha&quot;: function(params, parsed, data) { // console.log(&quot;pipetter.cleanTips|ourlab.luigi.evoware|ourlab.luigi.liha&quot;) // console.log(JSON.stringify(parsed, null, ' ')) const cleaningIntensities = data.schemas[&quot;pipetter.CleaningIntensity&quot;].enum; const syringeNameToItems = _.map(parsed.value.items, (item, index) =&gt; [parsed.objectName[`items.${index}.syringe`], item]); //console.log(syringeNameToItems); const expansionList = []; const sub = function(syringeNames, volume) { const syringeNameToItems2 = _.filter(syringeNameToItems, ([syringeName, ]) =&gt; _.includes(syringeNames, syringeName) ); //console.log({syringeNameToItems2}) if (!_.isEmpty(syringeNameToItems2)) { const value = _.max(_.map(syringeNameToItems2, ([, item]) =&gt; cleaningIntensities.indexOf(item.intensity))); if (value &gt;= 0) { const intensity = cleaningIntensities[value]; const syringes = _.map(syringeNameToItems2, ([syringeName, ]) =&gt; syringeName); expansionList.push({ command: &quot;pipetter._washTips&quot;, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment, program: `ourlab.luigi.washProgram.${intensity}_${volume}`, intensity: intensity, syringes: syringeNames }); } } } sub(_.map([1, 2, 3, 4, 5, 6, 7, 8], n =&gt; `ourlab.luigi.liha.syringe.${n}`), &quot;2500&quot;); return {expansion: expansionList}; } }, Equipment.evoware.getCommandHandlers(), Equipment.reader.getCommandHandlers(&quot;ourlab.luigi.evoware&quot;, &quot;ourlab.luigi.reader&quot;), Equipment.sealer.getCommandHandlers(&quot;ourlab.luigi.evoware&quot;, &quot;ourlab.luigi.sealer&quot;) ), planHandlers: _.merge( { &quot;ourlab.luigi.culturebox.close&quot;: function(params, parentParams, data) { return [{ command: &quot;equipment.close&quot;, agent: &quot;ourlab.luigi.evoware&quot;, equipment: &quot;ourlab.luigi.culturebox&quot; }]; }, &quot;ourlab.luigi.culturebox.stopAndOpen&quot;: function(params, parentParams, data) { return [{ command: &quot;equipment.open&quot;, agent: &quot;ourlab.luigi.evoware&quot;, equipment: &quot;ourlab.luigi.culturebox&quot; }]; }, }, Equipment.reader.getPlanHandlers(&quot;ourlab.luigi.evoware&quot;, &quot;ourlab.luigi.reader&quot;, &quot;ourlab.luigi.site.READER&quot;) ) } × Search results Close "},"expectCore.js.html":{"id":"expectCore.js.html","title":"Source: expectCore.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: expectCore.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ const _ = require('lodash'); const assert = require('assert'); // NOTE: with Babel 6 set to transpile to ES6, classes which extend Error are // not properly recognized as subclasses -- so &quot;instanceof RoboliqError&quot; won't // work. We need a number of work-arounds because of that. class RoboliqError extends Error { constructor(context = {}, errors, fnIgnore, stack) { super(getErrors(context, errors).join(&quot;; &quot;)); this.isRoboliqError = true; this.name = &quot;RoboliqError&quot;; this.context = _.cloneDeep(context); this.errors = _.isArray(errors) ? errors : [errors]; if (_.isUndefined(stack)) { Error.captureStackTrace(this, fnIgnore || this.constructor.name); //Error.captureStackTrace(this); } else { this.stack = stack; } // console.log(&quot;new RoboliqError: &quot;+this.__proto__) // console.log(this); // console.log(this.stack) } getPrefix() { return getPrefix(this.context); } toString() { return getErrors(context, errors).join(&quot;; &quot;); } static getErrors(e) { return getErrors(e.context, e.errors); } } function getPrefix(context) { const prefixes = []; if (_.isPlainObject(context)) { if (_.isString(context.stepName)) prefixes.push(`steps.${context.stepName}`); if (_.isString(context.objectName)) prefixes.push(`objects.${context.objectName}`); if (_.isString(context.paramName)) prefixes.push(`parameter &quot;${context.paramName}&quot;`); else if (_.isArray(context.paramName)) prefixes.push(`parameters &quot;${context.paramName.join('`, `')}&quot;`); } return (prefixes.length &gt; 0) ? prefixes.join(&quot;, &quot;)+&quot;: &quot; : &quot;&quot;; } function addContext(e, context) { _.mergeWith(e.context, context || {}, (a, b) =&gt; { if (_.isArray(a) &amp;&amp; _.isArray(b)) { return a.concat(b); } }); } function getErrors(context, errors) { errors = _.isArray(errors) ? errors : [errors]; const prefix = getPrefix(context); return _.map(errors || [], s =&gt; prefix+s); } function _context(context, fn) { try { fn(); } catch (e) { // console.log(&quot;_context: &quot;+e.__proto__) // console.log(JSON.stringify(e, null, '\\t')) rethrow(e, context); } } function rethrow(e, context, fnIgnore = rethrow) { if (e instanceof Error) { if (e.isRoboliqError) { // console.log(&quot;rethrow1&quot;) addContext(e, context); throw e; } else { // console.log(&quot;rethrow2&quot;) const error = new RoboliqError(context, [e.message], undefined, e.stack); throw error; } } else if (typeof e === &quot;string&quot;) { throw new RoboliqError({errors: [e]}, fnIgnore); } else { // console.log(&quot;rethrow4&quot;) throw new RoboliqError(context, [e.toString()], fnIgnore); } } /*function getContextPrefix(context) { const prefixes = []; if (!_.isEmpty(context)) { if (_.isString(context.paramName)) prefixes.push(`parameter &quot;${context.paramName}&quot;`); else if (_.isArray(context.paramName)) prefixes.push(`parameters &quot;${context.paramName.join('`, `')}&quot;`); if (_.isString(context.objectName)) prefixes.push(`object &quot;${context.objectName}&quot;`); } return (prefixes.length &gt; 0) ? prefixes.join(&quot;, &quot;)+&quot;: &quot; : &quot;&quot;; }*/ /*function handleError(context, e) { var prefix = getContextPrefix(context); if (!e.trace) { if (e.stack) console.log(e.stack); e.trace = e.stack; } if (e.errors) { e.errors = _.map(e.errors, message =&gt; prefix+message); } else { e.name = &quot;ProcessingError&quot;; e.errors = _.compact([prefix+e.message]); } //console.log({epath: e.path, cpath: context.path}) if (!e.path &amp;&amp; context.path) e.path = context.path; throw e; }*/ function truthy(context, result, message) { assert(message, &quot;you must provide a `message` value&quot;); if (!result) { if (_.isFunction(message)) message = message(); throw new RoboliqError(context, [message], truthy); } } function _try(context, fn) { try { return fn(); } catch (e) { rethrow(e, context, _try); } } function _throw(context, errors) { throw new RoboliqError(context, errors, _throw); } // TODO: get rid of this function after refactoring parameter processing in roboliqDirectives function paramsRequired(params, names) { assert(_.isPlainObject(params)); assert(_.isArray(names)); _.forEach(names, function(name) { truthy({paramName: name}, params.hasOwnProperty(name), &quot;missing required value [CODE 135]&quot;); }); } module.exports = { RoboliqError, context: _context, getPrefix, paramsRequired: paramsRequired, rethrow, throw: _throw, truthy: truthy, try: _try } × Search results Close "},"expect.js.html":{"id":"expect.js.html","title":"Source: expect.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: expect.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ var _ = require('lodash'); var assert = require('assert'); var expect = require('./expectCore.js'); var misc = require('./misc.js'); var wellsParser = require('./parsers/wellsParser.js'); function objectsValue(context, key, objects, effects, prefix) { var value = misc.findObjectsValue(key, objects, effects, undefined, prefix); if (_.isUndefined(value)) { var id = (prefix) ? prefix+&quot;.&quot;+key : key; //console.trace(); expect.throw(_.defaults({objectName: id}, context), &quot;missing value.&quot;); } return value; } function wells(context, value, data) { assert(value); assert(data); assert(data.objects); var destinations = expect.try(context, function () { //console.dir(wellsParser.parse); if (_.isString(value)) return wellsParser.parse(value, data.objects); else return value; }); return destinations; } module.exports = _.merge(expect, { destinationWells: wells, objectsValue: objectsValue, sourceWells: wells, }); × Search results Close "},"commands_scale.js.html":{"id":"commands_scale.js.html","title":"Source: commands/scale.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/scale.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ import _ from 'lodash'; import yaml from 'yamljs'; import commandHelper from '../commandHelper.js'; import expect from '../expect.js'; import misc from '../misc.js'; const objectToPredicateConverters = { &quot;Scale&quot;: function(name, object) { return [{ &quot;isScale&quot;: { &quot;equipment&quot;: name } }]; }, }; const commandHandlers = { &quot;scale.weighLabware&quot;: function(params, parsed, data) { // console.log(JSON.stringify(parsed)); var model = commandHelper.getParsedValue(parsed, data, 'object', 'model'); var location0 = commandHelper.getParsedValue(parsed, data, 'object', 'location'); var predicates = [ {&quot;scale.canAgentEquipmentModelSite&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: model, &quot;site&quot;: parsed.objectName.site }} ]; var [params2, alternatives] = commandHelper.queryLogic(data, predicates, &quot;scale.weighLabware&quot;); // console.log(&quot;params2:\\n&quot;+JSON.stringify(params2, null, ' ')) // console.log(&quot;parsed.value.outputFile: &quot;+JSON.stringify(parsed.value.outputFile)); const destinationAfter = (parsed.value.destinationAfter === &quot;stay&quot;) ? null : _.isUndefined(parsed.objectName.destinationAfter) ? location0 : parsed.objectName.destinationAfter; // Program to pass to sub-command const program = mergeR({}, parsed.orig.program); // Handle deprecated parameter names const output = mergeR({}, parsed.orig.output, { joinKey: _.get(parsed.orig, &quot;program.wellDesignFactor&quot;), userValues: _.get(parsed.orig, &quot;program.userValues&quot;), writeTo: _.get(parsed.orig, &quot;outputFile&quot;), appendTo: _.get(parsed.orig, &quot;outputDataset&quot;), }); // console.log({output}) var expansion = [ (params2.site === location0) ? null : { command: &quot;transporter.movePlate&quot;, object: parsed.objectName.object, destination: params2.site }, _.merge({}, { command: `equipment.run|${params2.agent}|${params2.equipment}`, agent: params2.agent, equipment: params2.equipment, measurementType: &quot;weight&quot;, program: (_.isEmpty(program)) ? undefined : program, object: parsed.objectName.object, output: (_.isEmpty(output)) ? undefined : output }), (destinationAfter === null || destinationAfter === params2.site) ? null : { command: &quot;transporter.movePlate&quot;, object: parsed.objectName.object, destination: destinationAfter } ]; // console.log({expansion1: expansion[0]}) // console.log({expansion1output: expansion[1].output}) const result = {expansion}; if (_.has(parsed.value, [&quot;output&quot;, &quot;simulated&quot;])) { simulatedHelpers.simulatedByLabware(parsed, data, [parsed.objectName.object], result); } // console.log(&quot;RESULTS:\\n&quot;+JSON.stringify(result)) return result; }, }; module.exports = { roboliq: &quot;v1&quot;, objectToPredicateConverters, schemas: yaml.load(__dirname+&quot;/../schemas/scale.yaml&quot;), commandHandlers }; × Search results Close "},"commands_equipment.js.html":{"id":"commands_equipment.js.html","title":"Source: commands/equipment.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/equipment.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Namespace for the ``equipment`` commands. * @namespace equipment * @version v1 */ /** * Equipment commands module. * @module commands/equipment * @return {Protocol} * @version v1 */ var _ = require('lodash'); var jmespath = require('jmespath'); import yaml from 'yamljs'; var commandHelper = require('../commandHelper.js'); var expect = require('../expect.js'); var misc = require('../misc.js'); function closeAll(params, data, effects) { expect.paramsRequired(params, [&quot;equipment&quot;]); var equipmentData = expect.objectsValue({}, params.equipment, data.objects); // Close equipment effects[params.equipment+&quot;.open&quot;] = false; // Indicate that all internal sites are closed _.forEach(equipmentData.sitesInternal, function(site) { effects[site+&quot;.closed&quot;] = true; }); } /** * Handlers for {@link equipment} commands. * @static */ var commandHandlers = { &quot;equipment._run&quot;: function(params, parsed, data) { return {}; }, &quot;equipment.close&quot;: function(params, parsed, data) { var sitesInternal = commandHelper.getParsedValue(parsed, data, &quot;equipment&quot;, &quot;sitesInternal&quot;); var expansion = [{ command: &quot;equipment.close|&quot;+parsed.objectName.agent+&quot;|&quot;+parsed.objectName.equipment, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment }]; var effects = {}; // Close equipment effects[parsed.objectName.equipment+&quot;.open&quot;] = false; // Indicate that the internal sites are closed _.forEach(sitesInternal, function(site) { effects[site+&quot;.closed&quot;] = true; }); return { expansion: expansion, effects: effects }; }, &quot;equipment.open&quot;: function(params, parsed, data) { var expansion = [{ command: &quot;equipment.open|&quot;+parsed.objectName.agent+&quot;|&quot;+parsed.objectName.equipment, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment }]; return { expansion: expansion, effects: {[parsed.objectName.equipment+&quot;.open&quot;]: true} }; }, &quot;equipment.openSite&quot;: function(params, parsed, data) { // console.log(&quot;equipment.openSite:&quot;); console.log(JSON.stringify(parsed, null, '\\t')) var sitesInternal = parsed.value.equipment.sitesInternal; expect.truthy({paramName: &quot;site&quot;}, sitesInternal.indexOf(parsed.objectName.site) &gt;= 0, `site ${parsed.objectName.site} must be in \\`${parsed.objectName.equipment}.sitesInternal\\; \\`${parsed.objectName.equipment}.sitesInternal\\` = ${sitesInternal}`); var expansion = [{ command: &quot;equipment.openSite|&quot;+parsed.objectName.agent+&quot;|&quot;+parsed.objectName.equipment, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment, site: parsed.objectName.site }]; //console.log(JSON.stringify(expansion, null, '\\t')) var effects = {}; // Open equipment effects[parsed.objectName.equipment+&quot;.open&quot;] = true; // Indicate that the given site is open and the other internal sites are closed _.forEach(sitesInternal, function(site) { effects[site+&quot;.closed&quot;] = (site != parsed.objectName.site); }); //console.log(JSON.stringify(effects, null, '\\t')) return { expansion: expansion, effects: effects }; }, &quot;equipment.start&quot;: function(params, parsed, data) { var expansion = [_.defaults({ command: &quot;equipment.start|&quot;+parsed.objectName.agent+&quot;|&quot;+parsed.objectName.equipment, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment }, parsed.orig)]; var effects = { [parsed.objectName.equipment+&quot;.running&quot;]: true }; return { expansion, effects }; }, &quot;equipment.stop&quot;: function(params, parsed, data) { var expansion = [_.defaults({ command: &quot;equipment.stop|&quot;+parsed.objectName.agent+&quot;|&quot;+parsed.objectName.equipment, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment }, parsed.orig)]; var effects = { [parsed.objectName.equipment+&quot;.running&quot;]: false }; return { expansion, effects }; }, }; /** * Plan handler to allow other modules to use `equipment._close` and * `equipment._openSite` as planning actions. * @static */ var planHandlers = { &quot;equipment._close&quot;: function(params, parentParams, data) { return [{ command: &quot;equipment.close&quot;, agent: params.agent, equipment: params.equipment }]; }, &quot;equipment._openSite&quot;: function(params, parentParams, data) { return [{ command: &quot;equipment.openSite&quot;, agent: params.agent, equipment: params.equipment, site: params.site }]; } }; module.exports = { roboliq: &quot;v1&quot;, schemas: yaml.load(__dirname+&quot;/../schemas/equipment.yaml&quot;), commandHandlers, planHandlers }; × Search results Close "},"commands_fluorescenceReader.js.html":{"id":"commands_fluorescenceReader.js.html","title":"Source: commands/fluorescenceReader.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/fluorescenceReader.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Namespace for the ``fluorescenceReader`` commands. * @namespace fluorescenceReader * @version v1 */ /** * Fluorescence Reader commands module. * @module commands/fluorescenceReader * @return {Protocol} * @version v1 */ var _ = require('lodash'); var jmespath = require('jmespath'); import yaml from 'yamljs'; var commandHelper = require('../commandHelper.js'); var expect = require('../expect.js'); import {mergeR} from '../mergeR.js'; var misc = require('../misc.js'); /** * Handlers for {@link fluorescenceReader} commands. * @static */ var commandHandlers = { /** * Measure the fluorescence of a plate. * * @typedef measurePlate * @memberof fluorescenceReader * @property {string} command - &quot;fluorescenceReader.measurePlate&quot; * @property {string} [agent] - Agent identifier * @property {string} [equipment] - Equipment identifier * @property {Object} program - Program object for measurement * @property {string} outputFile - Filename for output * @property {string} object - Plate identifier * @property {string} [site] - Site identifier in reader * @property {string} [destinationAfter] - Site to move the plate to after measurement */ &quot;fluorescenceReader.measurePlate&quot;: function(params, parsed, data) { //console.log(JSON.stringify(parsed)); var model = commandHelper.getParsedValue(parsed, data, 'object', 'model'); var location0 = commandHelper.getParsedValue(parsed, data, 'object', 'location'); var predicates = [ {&quot;fluorescenceReader.canAgentEquipmentModelSite&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: model, &quot;site&quot;: parsed.objectName.site }} ]; var [params2, alternatives] = commandHelper.queryLogic(data, predicates, &quot;fluorescenceReader.canAgentEquipmentModelSite&quot;); //console.log(&quot;params2:\\n&quot;+JSON.stringify(params2, null, ' ')) //console.log(&quot;parsed.value.outputFile: &quot;+JSON.stringify(parsed.value.outputFile)); const destinationAfter = (parsed.value.destinationAfter === &quot;stay&quot;) ? null : _.isUndefined(parsed.objectName.destinationAfter) ? location0 : parsed.objectName.destinationAfter; // Program to pass to sub-command const program = mergeR({}, parsed.orig.program, { wells: (parsed.value.program || {}).wells }); // console.log({program}) // Handle deprecated parameter names const output = mergeR({}, parsed.orig.output, { joinKey: _.get(parsed.orig, &quot;program.wellDesignFactor&quot;), userValues: _.get(parsed.orig, &quot;program.userValues&quot;), writeTo: _.get(parsed.orig, &quot;outputFile&quot;), appendTo: _.get(parsed.orig, &quot;outputDataset&quot;), }); // console.log({output}) var expansion = [ (params2.site === location0) ? null : { command: &quot;transporter.movePlate&quot;, object: parsed.objectName.object, destination: params2.site }, _.merge({}, { command: [&quot;equipment.run&quot;, params2.agent, params2.equipment].join('|'), agent: params2.agent, equipment: params2.equipment, measurementType: &quot;fluorescence&quot;, program: (_.isEmpty(program)) ? undefined : program, programFileTemplate: parsed.value.programFileTemplate, programFile: parsed.value.programFile, programData: parsed.value.programData, object: parsed.objectName.object, output: (_.isEmpty(output)) ? undefined : output }), (destinationAfter === null || destinationAfter === params2.site) ? null : { command: &quot;transporter.movePlate&quot;, object: parsed.objectName.object, destination: destinationAfter } ]; // console.log({expansion1output: expansion[1].output}) const result = {expansion}; if (_.has(parsed.value, [&quot;output&quot;, &quot;simulated&quot;])) { // Wells are chosen as follows: // 1) program.wells // 2) output.joinKey // 3) all wells on labware const wells = (_.has(parsed.value, [&quot;program&quot;, &quot;wells&quot;])) ? commandHelper.asArray(parsed.value.program.wells) : (!_.isUndefined(output.joinKey)) ? commandHelper.getDesignFactor(output.joinKey, data.objects.DATA) : wellsParser.parse(`${parsed.objectName.object}(all)`, data.objects); // console.log({wells}) simulatedHelpers.simulatedByWells(parsed, data, wells, result); } // console.log(&quot;RESULTS:\\n&quot;+JSON.stringify(result)) return result; }, }; module.exports = { roboliq: &quot;v1&quot;, schemas: yaml.load(__dirname+&quot;/../schemas/fluorescenceReader.yaml&quot;), commandHandlers }; × Search results Close "},"parsers_wellsParser0.js.html":{"id":"parsers_wellsParser0.js.html","title":"Source: parsers/wellsParser0.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: parsers/wellsParser0.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ module.exports = (function() { /* * Generated by PEG.js 0.8.0. * * http://pegjs.majda.cz/ */ function peg$subclass(child, parent) { function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); } function SyntaxError(message, expected, found, offset, line, column) { this.message = message; this.expected = expected; this.found = found; this.offset = offset; this.line = line; this.column = column; this.name = &quot;SyntaxError&quot;; } peg$subclass(SyntaxError, Error); function parse(input) { var options = arguments.length &gt; 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart, startOne: peg$parsestartOne }, peg$startRuleFunction = peg$parsestart, peg$c0 = peg$FAILED, peg$c1 = [], peg$c2 = &quot;+&quot;, peg$c3 = { type: &quot;literal&quot;, value: &quot;+&quot;, description: &quot;\\&quot;+\\&quot;&quot; }, peg$c4 = function(x) { return x; }, peg$c5 = function(init, last) { return init.concat.apply([], init).concat(last); }, peg$c6 = &quot;(&quot;, peg$c7 = { type: &quot;literal&quot;, value: &quot;(&quot;, description: &quot;\\&quot;(\\&quot;&quot; }, peg$c8 = &quot;)&quot;, peg$c9 = { type: &quot;literal&quot;, value: &quot;)&quot;, description: &quot;\\&quot;)\\&quot;&quot; }, peg$c10 = function(labware, wellId) { return {labware:labware, wellId: wellId}; }, peg$c11 = /^[ \\t]/, peg$c12 = { type: &quot;class&quot;, value: &quot;[ \\\\t]&quot;, description: &quot;[ \\\\t]&quot; }, peg$c13 = function(labware, clauses) { return clauses.map(function (clause) { return {labware: labware, subject: clause.subject, phrases: clause.phrases}; }); }, peg$c14 = function(source) { return {source: source}; }, peg$c15 = &quot;.&quot;, peg$c16 = { type: &quot;literal&quot;, value: &quot;.&quot;, description: &quot;\\&quot;.\\&quot;&quot; }, peg$c17 = function(init, last) { return init.concat([last]).join('.'); }, peg$c18 = /^[A-Za-z_]/, peg$c19 = { type: &quot;class&quot;, value: &quot;[A-Za-z_]&quot;, description: &quot;[A-Za-z_]&quot; }, peg$c20 = /^[0-9A-Za-z_]/, peg$c21 = { type: &quot;class&quot;, value: &quot;[0-9A-Za-z_]&quot;, description: &quot;[0-9A-Za-z_]&quot; }, peg$c22 = function(first, rest) { return first.toString() + rest.join('').toString(); }, peg$c23 = &quot;,&quot;, peg$c24 = { type: &quot;literal&quot;, value: &quot;,&quot;, description: &quot;\\&quot;,\\&quot;&quot; }, peg$c25 = function(init, last) { return init.concat([last]); }, peg$c26 = null, peg$c27 = function(subject, phrases) { return {subject: subject, phrases: phrases}; }, peg$c28 = &quot;all&quot;, peg$c29 = { type: &quot;literal&quot;, value: &quot;all&quot;, description: &quot;\\&quot;all\\&quot;&quot; }, peg$c30 = /^[A-Z]/, peg$c31 = { type: &quot;class&quot;, value: &quot;[A-Z]&quot;, description: &quot;[A-Z]&quot; }, peg$c32 = function(row, col) { var columnText = col.toString(); if (columnText.length &lt; 2) columnText = &quot;0&quot; + columnText; return row.toString()+columnText; }, peg$c33 = /^[0-9]/, peg$c34 = { type: &quot;class&quot;, value: &quot;[0-9]&quot;, description: &quot;[0-9]&quot; }, peg$c35 = function(digits) { return parseInt(digits.join(&quot;&quot;), 10); }, peg$c36 = &quot;down&quot;, peg$c37 = { type: &quot;literal&quot;, value: &quot;down&quot;, description: &quot;\\&quot;down\\&quot;&quot; }, peg$c38 = &quot;block&quot;, peg$c39 = { type: &quot;literal&quot;, value: &quot;block&quot;, description: &quot;\\&quot;block\\&quot;&quot; }, peg$c40 = &quot;to&quot;, peg$c41 = { type: &quot;literal&quot;, value: &quot;to&quot;, description: &quot;\\&quot;to\\&quot;&quot; }, peg$c42 = function(to) { return [&quot;down-block&quot;, to]; }, peg$c43 = &quot;take&quot;, peg$c44 = { type: &quot;literal&quot;, value: &quot;take&quot;, description: &quot;\\&quot;take\\&quot;&quot; }, peg$c45 = function(n) { return [&quot;down&quot;, n]; }, peg$c46 = function(to) { return [&quot;down-to&quot;, to]; }, peg$c47 = &quot;right&quot;, peg$c48 = { type: &quot;literal&quot;, value: &quot;right&quot;, description: &quot;\\&quot;right\\&quot;&quot; }, peg$c49 = function(to) { return [&quot;right-block&quot;, to]; }, peg$c50 = function(n) { return [&quot;right&quot;, n]; }, peg$c51 = function(to) { return [&quot;right-to&quot;, to]; }, peg$c52 = &quot;random&quot;, peg$c53 = { type: &quot;literal&quot;, value: &quot;random&quot;, description: &quot;\\&quot;random\\&quot;&quot; }, peg$c54 = function(seed) { return ['random', seed]; }, peg$c55 = function() { return ['random']; }, peg$c56 = function(n) { return ['take', n]; }, peg$c57 = &quot;row-jump&quot;, peg$c58 = { type: &quot;literal&quot;, value: &quot;row-jump&quot;, description: &quot;\\&quot;row-jump\\&quot;&quot; }, peg$c59 = function(n) { return ['row-jump', n]; }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result; if (&quot;startRule&quot; in options) { if (!(options.startRule in peg$startRuleFunctions)) { throw new Error(&quot;Can't start parsing from rule \\&quot;&quot; + options.startRule + &quot;\\&quot;.&quot;); } peg$startRuleFunction = peg$startRuleFunctions[options.startRule]; } function text() { return input.substring(peg$reportedPos, peg$currPos); } function offset() { return peg$reportedPos; } function line() { return peg$computePosDetails(peg$reportedPos).line; } function column() { return peg$computePosDetails(peg$reportedPos).column; } function expected(description) { throw peg$buildException( null, [{ type: &quot;other&quot;, description: description }], peg$reportedPos ); } function error(message) { throw peg$buildException(message, null, peg$reportedPos); } function peg$computePosDetails(pos) { function advance(details, startPos, endPos) { var p, ch; for (p = startPos; p &lt; endPos; p++) { ch = input.charAt(p); if (ch === &quot;\\n&quot;) { if (!details.seenCR) { details.line++; } details.column = 1; details.seenCR = false; } else if (ch === &quot;\\r&quot; || ch === &quot;\\u2028&quot; || ch === &quot;\\u2029&quot;) { details.line++; details.column = 1; details.seenCR = true; } else { details.column++; details.seenCR = false; } } } if (peg$cachedPos !== pos) { if (peg$cachedPos &gt; pos) { peg$cachedPos = 0; peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }; } advance(peg$cachedPosDetails, peg$cachedPos, pos); peg$cachedPos = pos; } return peg$cachedPosDetails; } function peg$fail(expected) { if (peg$currPos &lt; peg$maxFailPos) { return; } if (peg$currPos &gt; peg$maxFailPos) { peg$maxFailPos = peg$currPos; peg$maxFailExpected = []; } peg$maxFailExpected.push(expected); } function peg$buildException(message, expected, pos) { function cleanupExpected(expected) { var i = 1; expected.sort(function(a, b) { if (a.description &lt; b.description) { return -1; } else if (a.description &gt; b.description) { return 1; } else { return 0; } }); while (i &lt; expected.length) { if (expected[i - 1] === expected[i]) { expected.splice(i, 1); } else { i++; } } } function buildMessage(expected, found) { function stringEscape(s) { function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); } return s .replace(/\\\\/g, '\\\\\\\\') .replace(/&quot;/g, '\\\\&quot;') .replace(/\\x08/g, '\\\\b') .replace(/\\t/g, '\\\\t') .replace(/\\n/g, '\\\\n') .replace(/\\f/g, '\\\\f') .replace(/\\r/g, '\\\\r') .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); }) .replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function(ch) { return '\\\\x' + hex(ch); }) .replace(/[\\u0180-\\u0FFF]/g, function(ch) { return '\\\\u0' + hex(ch); }) .replace(/[\\u1080-\\uFFFF]/g, function(ch) { return '\\\\u' + hex(ch); }); } var expectedDescs = new Array(expected.length), expectedDesc, foundDesc, i; for (i = 0; i &lt; expected.length; i++) { expectedDescs[i] = expected[i].description; } expectedDesc = expected.length &gt; 1 ? expectedDescs.slice(0, -1).join(&quot;, &quot;) + &quot; or &quot; + expectedDescs[expected.length - 1] : expectedDescs[0]; foundDesc = found ? &quot;\\&quot;&quot; + stringEscape(found) + &quot;\\&quot;&quot; : &quot;end of input&quot;; return &quot;Expected &quot; + expectedDesc + &quot; but &quot; + foundDesc + &quot; found.&quot;; } var posDetails = peg$computePosDetails(pos), found = pos &lt; input.length ? input.charAt(pos) : null; if (expected !== null) { cleanupExpected(expected); } return new SyntaxError( message !== null ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column ); } function peg$parsestart() { var s0, s1, s2, s3, s4, s5, s6; s0 = peg$currPos; s1 = []; s2 = peg$currPos; s3 = peg$parseentity(); if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 43) { s5 = peg$c2; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c3); } } if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { peg$reportedPos = s2; s3 = peg$c4(s3); s2 = s3; } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } while (s2 !== peg$FAILED) { s1.push(s2); s2 = peg$currPos; s3 = peg$parseentity(); if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 43) { s5 = peg$c2; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c3); } } if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { peg$reportedPos = s2; s3 = peg$c4(s3); s2 = s3; } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } if (s1 !== peg$FAILED) { s2 = peg$parseentity(); if (s2 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c5(s1, s2); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } return s0; } function peg$parsestartOne() { var s0, s1, s2, s3, s4, s5, s6, s7; s0 = peg$currPos; s1 = peg$parseident(); if (s1 !== peg$FAILED) { s2 = peg$parsews(); if (s2 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 40) { s3 = peg$c6; peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c7); } } if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { s5 = peg$parsewell(); if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 41) { s7 = peg$c8; peg$currPos++; } else { s7 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c9); } } if (s7 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c10(s1, s5); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$parsesource(); } return s0; } function peg$parsews() { var s0, s1; s0 = []; if (peg$c11.test(input.charAt(peg$currPos))) { s1 = input.charAt(peg$currPos); peg$currPos++; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c12); } } while (s1 !== peg$FAILED) { s0.push(s1); if (peg$c11.test(input.charAt(peg$currPos))) { s1 = input.charAt(peg$currPos); peg$currPos++; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c12); } } } return s0; } function peg$parsespaces() { var s0, s1; s0 = []; if (peg$c11.test(input.charAt(peg$currPos))) { s1 = input.charAt(peg$currPos); peg$currPos++; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c12); } } if (s1 !== peg$FAILED) { while (s1 !== peg$FAILED) { s0.push(s1); if (peg$c11.test(input.charAt(peg$currPos))) { s1 = input.charAt(peg$currPos); peg$currPos++; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c12); } } } } else { s0 = peg$c0; } return s0; } function peg$parseentity() { var s0; s0 = peg$parselabwareClause(); if (s0 === peg$FAILED) { s0 = peg$parsewellClause(); if (s0 === peg$FAILED) { s0 = peg$parsesource(); } } return s0; } function peg$parselabwareClause() { var s0, s1, s2, s3, s4, s5, s6, s7; s0 = peg$currPos; s1 = peg$parseident(); if (s1 !== peg$FAILED) { s2 = peg$parsews(); if (s2 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 40) { s3 = peg$c6; peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c7); } } if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { s5 = peg$parsewellClauses(); if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 41) { s7 = peg$c8; peg$currPos++; } else { s7 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c9); } } if (s7 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c13(s1, s5); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } return s0; } function peg$parsesource() { var s0, s1; s0 = peg$currPos; s1 = peg$parseident(); if (s1 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c14(s1); } s0 = s1; return s0; } function peg$parseident() { var s0, s1, s2, s3, s4, s5, s6; s0 = peg$currPos; s1 = []; s2 = peg$currPos; s3 = peg$parseidentPart(); if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 46) { s5 = peg$c15; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c16); } } if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { peg$reportedPos = s2; s3 = peg$c4(s3); s2 = s3; } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } while (s2 !== peg$FAILED) { s1.push(s2); s2 = peg$currPos; s3 = peg$parseidentPart(); if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 46) { s5 = peg$c15; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c16); } } if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { peg$reportedPos = s2; s3 = peg$c4(s3); s2 = s3; } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } if (s1 !== peg$FAILED) { s2 = peg$parseidentPart(); if (s2 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c17(s1, s2); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } return s0; } function peg$parseidentPart() { var s0, s1, s2, s3; s0 = peg$currPos; if (peg$c18.test(input.charAt(peg$currPos))) { s1 = input.charAt(peg$currPos); peg$currPos++; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c19); } } if (s1 !== peg$FAILED) { s2 = []; if (peg$c20.test(input.charAt(peg$currPos))) { s3 = input.charAt(peg$currPos); peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c21); } } while (s3 !== peg$FAILED) { s2.push(s3); if (peg$c20.test(input.charAt(peg$currPos))) { s3 = input.charAt(peg$currPos); peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c21); } } } if (s2 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c22(s1, s2); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { if (peg$c18.test(input.charAt(peg$currPos))) { s0 = input.charAt(peg$currPos); peg$currPos++; } else { s0 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c19); } } } return s0; } function peg$parsewellClauses() { var s0, s1, s2, s3, s4, s5, s6; s0 = peg$currPos; s1 = []; s2 = peg$currPos; s3 = peg$parsewellClause(); if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 44) { s5 = peg$c23; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c24); } } if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { peg$reportedPos = s2; s3 = peg$c4(s3); s2 = s3; } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } while (s2 !== peg$FAILED) { s1.push(s2); s2 = peg$currPos; s3 = peg$parsewellClause(); if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 44) { s5 = peg$c23; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c24); } } if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { peg$reportedPos = s2; s3 = peg$c4(s3); s2 = s3; } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } else { peg$currPos = s2; s2 = peg$c0; } } if (s1 !== peg$FAILED) { s2 = peg$parsewellClause(); if (s2 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c25(s1, s2); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } return s0; } function peg$parsewellClause() { var s0, s1, s2; s0 = peg$currPos; s1 = peg$parsewellSubject(); if (s1 !== peg$FAILED) { s2 = peg$parsewellPhrases(); if (s2 === peg$FAILED) { s2 = peg$c26; } if (s2 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c27(s1, s2); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } return s0; } function peg$parsewellSubject() { var s0; s0 = peg$parsewell(); if (s0 === peg$FAILED) { if (input.substr(peg$currPos, 3) === peg$c28) { s0 = peg$c28; peg$currPos += 3; } else { s0 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c29); } } } return s0; } function peg$parsewell() { var s0, s1, s2; s0 = peg$currPos; if (peg$c30.test(input.charAt(peg$currPos))) { s1 = input.charAt(peg$currPos); peg$currPos++; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c31); } } if (s1 !== peg$FAILED) { s2 = peg$parseinteger(); if (s2 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c32(s1, s2); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } return s0; } function peg$parseinteger() { var s0, s1, s2; s0 = peg$currPos; s1 = []; if (peg$c33.test(input.charAt(peg$currPos))) { s2 = input.charAt(peg$currPos); peg$currPos++; } else { s2 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c34); } } if (s2 !== peg$FAILED) { while (s2 !== peg$FAILED) { s1.push(s2); if (peg$c33.test(input.charAt(peg$currPos))) { s2 = input.charAt(peg$currPos); peg$currPos++; } else { s2 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c34); } } } } else { s1 = peg$c0; } if (s1 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c35(s1); } s0 = s1; return s0; } function peg$parsewellPhrases() { var s0, s1, s2, s3; s0 = []; s1 = peg$currPos; s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$parsewellPhrase(); if (s3 !== peg$FAILED) { peg$reportedPos = s1; s2 = peg$c4(s3); s1 = s2; } else { peg$currPos = s1; s1 = peg$c0; } } else { peg$currPos = s1; s1 = peg$c0; } while (s1 !== peg$FAILED) { s0.push(s1); s1 = peg$currPos; s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$parsewellPhrase(); if (s3 !== peg$FAILED) { peg$reportedPos = s1; s2 = peg$c4(s3); s1 = s2; } else { peg$currPos = s1; s1 = peg$c0; } } else { peg$currPos = s1; s1 = peg$c0; } } return s0; } function peg$parsewellPhrase() { var s0, s1, s2, s3, s4, s5, s6, s7; s0 = peg$currPos; if (input.substr(peg$currPos, 4) === peg$c36) { s1 = peg$c36; peg$currPos += 4; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c37); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { if (input.substr(peg$currPos, 5) === peg$c38) { s3 = peg$c38; peg$currPos += 5; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c39); } } if (s3 !== peg$FAILED) { s4 = peg$parsespaces(); if (s4 !== peg$FAILED) { s5 = peg$currPos; if (input.substr(peg$currPos, 2) === peg$c40) { s6 = peg$c40; peg$currPos += 2; } else { s6 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c41); } } if (s6 !== peg$FAILED) { s7 = peg$parsespaces(); if (s7 !== peg$FAILED) { s6 = [s6, s7]; s5 = s6; } else { peg$currPos = s5; s5 = peg$c0; } } else { peg$currPos = s5; s5 = peg$c0; } if (s5 === peg$FAILED) { s5 = peg$c26; } if (s5 !== peg$FAILED) { s6 = peg$parsewell(); if (s6 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c42(s6); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 4) === peg$c36) { s1 = peg$c36; peg$currPos += 4; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c37); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$currPos; if (input.substr(peg$currPos, 4) === peg$c43) { s4 = peg$c43; peg$currPos += 4; } else { s4 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c44); } } if (s4 !== peg$FAILED) { s5 = peg$parsespaces(); if (s5 !== peg$FAILED) { s4 = [s4, s5]; s3 = s4; } else { peg$currPos = s3; s3 = peg$c0; } } else { peg$currPos = s3; s3 = peg$c0; } if (s3 === peg$FAILED) { s3 = peg$c26; } if (s3 !== peg$FAILED) { s4 = peg$parseinteger(); if (s4 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c45(s4); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 4) === peg$c36) { s1 = peg$c36; peg$currPos += 4; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c37); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$currPos; if (input.substr(peg$currPos, 2) === peg$c40) { s4 = peg$c40; peg$currPos += 2; } else { s4 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c41); } } if (s4 !== peg$FAILED) { s5 = peg$parsespaces(); if (s5 !== peg$FAILED) { s4 = [s4, s5]; s3 = s4; } else { peg$currPos = s3; s3 = peg$c0; } } else { peg$currPos = s3; s3 = peg$c0; } if (s3 === peg$FAILED) { s3 = peg$c26; } if (s3 !== peg$FAILED) { s4 = peg$parsewell(); if (s4 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c46(s4); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 5) === peg$c47) { s1 = peg$c47; peg$currPos += 5; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c48); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { if (input.substr(peg$currPos, 5) === peg$c38) { s3 = peg$c38; peg$currPos += 5; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c39); } } if (s3 !== peg$FAILED) { s4 = peg$parsespaces(); if (s4 !== peg$FAILED) { s5 = peg$currPos; if (input.substr(peg$currPos, 2) === peg$c40) { s6 = peg$c40; peg$currPos += 2; } else { s6 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c41); } } if (s6 !== peg$FAILED) { s7 = peg$parsespaces(); if (s7 !== peg$FAILED) { s6 = [s6, s7]; s5 = s6; } else { peg$currPos = s5; s5 = peg$c0; } } else { peg$currPos = s5; s5 = peg$c0; } if (s5 === peg$FAILED) { s5 = peg$c26; } if (s5 !== peg$FAILED) { s6 = peg$parsewell(); if (s6 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c49(s6); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 5) === peg$c47) { s1 = peg$c47; peg$currPos += 5; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c48); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$currPos; if (input.substr(peg$currPos, 4) === peg$c43) { s4 = peg$c43; peg$currPos += 4; } else { s4 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c44); } } if (s4 !== peg$FAILED) { s5 = peg$parsespaces(); if (s5 !== peg$FAILED) { s4 = [s4, s5]; s3 = s4; } else { peg$currPos = s3; s3 = peg$c0; } } else { peg$currPos = s3; s3 = peg$c0; } if (s3 === peg$FAILED) { s3 = peg$c26; } if (s3 !== peg$FAILED) { s4 = peg$parseinteger(); if (s4 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c50(s4); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 5) === peg$c47) { s1 = peg$c47; peg$currPos += 5; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c48); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$currPos; if (input.substr(peg$currPos, 2) === peg$c40) { s4 = peg$c40; peg$currPos += 2; } else { s4 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c41); } } if (s4 !== peg$FAILED) { s5 = peg$parsespaces(); if (s5 !== peg$FAILED) { s4 = [s4, s5]; s3 = s4; } else { peg$currPos = s3; s3 = peg$c0; } } else { peg$currPos = s3; s3 = peg$c0; } if (s3 === peg$FAILED) { s3 = peg$c26; } if (s3 !== peg$FAILED) { s4 = peg$parsewell(); if (s4 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c51(s4); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 6) === peg$c52) { s1 = peg$c52; peg$currPos += 6; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c53); } } if (s1 !== peg$FAILED) { s2 = peg$parsews(); if (s2 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 40) { s3 = peg$c6; peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c7); } } if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { s5 = peg$parseinteger(); if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 41) { s7 = peg$c8; peg$currPos++; } else { s7 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c9); } } if (s7 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c54(s5); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 6) === peg$c52) { s1 = peg$c52; peg$currPos += 6; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c53); } } if (s1 !== peg$FAILED) { s2 = peg$parsews(); if (s2 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 40) { s3 = peg$c6; peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c7); } } if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 41) { s5 = peg$c8; peg$currPos++; } else { s5 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c9); } } if (s5 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c55(); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 4) === peg$c43) { s1 = peg$c43; peg$currPos += 4; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c44); } } if (s1 !== peg$FAILED) { s2 = peg$parsespaces(); if (s2 !== peg$FAILED) { s3 = peg$parseinteger(); if (s3 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c56(s3); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } if (s0 === peg$FAILED) { s0 = peg$currPos; if (input.substr(peg$currPos, 8) === peg$c57) { s1 = peg$c57; peg$currPos += 8; } else { s1 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c58); } } if (s1 !== peg$FAILED) { s2 = peg$parsews(); if (s2 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 40) { s3 = peg$c6; peg$currPos++; } else { s3 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c7); } } if (s3 !== peg$FAILED) { s4 = peg$parsews(); if (s4 !== peg$FAILED) { s5 = peg$parseinteger(); if (s5 !== peg$FAILED) { s6 = peg$parsews(); if (s6 !== peg$FAILED) { if (input.charCodeAt(peg$currPos) === 41) { s7 = peg$c8; peg$currPos++; } else { s7 = peg$FAILED; if (peg$silentFails === 0) { peg$fail(peg$c9); } } if (s7 !== peg$FAILED) { peg$reportedPos = s0; s1 = peg$c59(s5); s0 = s1; } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } else { peg$currPos = s0; s0 = peg$c0; } } } } } } } } } } return s0; } peg$result = peg$startRuleFunction(); if (peg$result !== peg$FAILED &amp;&amp; peg$currPos === input.length) { return peg$result; } else { if (peg$result !== peg$FAILED &amp;&amp; peg$currPos &lt; input.length) { peg$fail({ type: &quot;end&quot;, description: &quot;end of input&quot; }); } throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos); } } return { SyntaxError: SyntaxError, parse: parse }; })(); × Search results Close "},"stripUndefined.js.html":{"id":"stripUndefined.js.html","title":"Source: stripUndefined.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: stripUndefined.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ import isArray from 'lodash/isArray'; import isPlainObject from 'lodash/isPlainObject'; /** * Recursively remove any properties that are undefined. * @param {object} obj - objects to remove undefined properties from */ export default function stripUndefined(obj) { for (let key in obj) { const x = obj[key] if (x === undefined) { delete obj[key]; } else if (isArray(x) || isPlainObject(x)) { stripUndefined(x); } } return obj; } × Search results Close "},"commandHelper.js.html":{"id":"commandHelper.js.html","title":"Source: commandHelper.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commandHelper.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * A collection of helper functions for command handlers. * @module commandHelper */ var _ = require('lodash'); var assert = require('assert'); var expect = require('./expect.js'); var jmespath = require('jmespath'); import math from 'mathjs'; import naturalSort from 'javascript-natural-sort'; import tv4 from 'tv4'; const Design = require('./design.js'); import misc from './misc.js'; import roboliqSchemas from './roboliqSchemas.js'; import wellsParser from './parsers/wellsParser.js'; /** * Ensure that the value is an array. * If the value is already an array, return it directly. * If the value is undefined, return an empty array. * Otherwise, return the value wrapped in an array. * * @param {any} x - value * @return {array} an array */ function asArray(x) { if (_.isArray(x)) return x; else if (_.isUndefined(x)) return []; else return [x]; } /** * Create the 'data' object that gets passed into many commandHelper functions. * * TODO: Rather than calling it 'data', we should probably rename it to 'context'. * * @param {Protocol} protocol * @param {object} objects = {} - current objects * @param {object} SCOPE = {} - current SCOPE * @param {array} DATA = [] - current DATA table * @param {array} path = [] - current processing path (usually a step ID, e.g. step 1.2 would be given by `[1, 2]`) * @param {object} files = {} - map of filename to loaded filedata * @return {object} the 'data' object that gets passed into many commandHelper functions */ function createData(protocol, objects = {}, SCOPE = {}, DATA = [], path = [], files = {}, step = {}) { const updatedSCOPEDATA = updateSCOPEDATA(step, {objects: _.defaults({SCOPE, DATA}, objects)}, SCOPE, DATA); // console.log({step, SCOPE: updatedSCOPEDATA.SCOPE, DATA: updatedSCOPEDATA.DATA}) // Process any directives in this step const objects2 = _.clone(objects); // TODO: consider changing this so that DATA and SCOPE are not a part of `objects`, // but are their own separate properties. objects2.DATA = updatedSCOPEDATA.DATA; objects2.SCOPE = _.defaults( { // access the raw objects __objects: objects2, // access the current raw data table __data: updatedSCOPEDATA.DATA, // access raw protocol parameters __parameters: protocol.parameters || {}, // access parameters of the current step __step: step, // access parameters from any step in the current step stack (0 = current step) __stepStack: null }, updatedSCOPEDATA.SCOPE, _.mapValues(protocol.parameters || {}, x =&gt; x.value) ); const context = { objects: objects2, schemas: protocol.schemas, accesses: new Set(), files, protocol, path }; // console.log(&quot;SCOPE:&quot;) // console.log(context.objects.SCOPE); return context; } function getDesignFactor(propertyName, DATA) { return _(DATA).map(propertyName).filter(x =&gt; !_.isUndefined(x)).value(); } /** * Recursively replace $-SCOPE, $$-DATA, and template strings in `x`. * * The recursion has the following exceptions: * - skip objects with any of these properties: `data`, `@DATA`, `@SCOPE` * - skip `steps` properties * - skip directives * * @param {any} x - the variable to perform substitutions on * @param {object} data - protocol data * @return {any} the value with possible substitutions */ function substituteDeep(x, data, SCOPE, DATA, addCommonValuesToScope=true, depth=0) { // console.log(&quot;substituteDeep: &quot;); console.log({x, SCOPE, DATA, x}) let x2 = x; if (_.isString(x)) { /*// DATA substitution if (_.startsWith(x, &quot;$$&quot;)) { if (_.isArray(DATA)) { const propertyName = x.substr(2); x2 = getDesignFactor(propertyName, DATA); assert(x2.length &gt; 0 || DATA.length == 0, `factor ${x} not found in data`); // console.log({x2}) // console.log(&quot;DATA: &quot;+JSON.stringify(DATA, null, '\\t')); // console.log({map: _(DATA).map(propertyName).value()}); } else { assert(false, `invalid factor ${x}, because no data source is currently selected`); } } // Javascript else*/ if (_.startsWith(x, &quot;${&quot;) &amp;&amp; _.endsWith(x, &quot;}&quot;)) { const safeEval = require('safe-eval'); const code = x.substr(2, x.length - 3); const scope = _.defaults({_, math}, SCOPE, data.objects.PARAMS); // console.log({code, scope}) x2 = safeEval(code, scope); // console.log({x2}) } // Mathjs calculation else if (_.startsWith(x, &quot;$(&quot;) &amp;&amp; _.endsWith(x, &quot;)&quot;)) { const expr = x.substr(2, x.length - 3); // console.log({expr}) const context = _.defaults({}, SCOPE, data.objects.PARAMS) // console.log({expr, context}) x2 = calculateWithMathjs(expr, context); // console.log({x2, expr}) } // Mathjs calculation (deprecated) else if (x.length &gt; 2 &amp;&amp; _.startsWith(x, &quot;$`&quot;) &amp;&amp; _.endsWith(x, &quot;`&quot;)) { const expr = x.substr(2, x.length - 3); // console.log({expr}) // process.exit() x2 = Design.calculate(expr, SCOPE); // console.log({x2, expr}) } // Variable substitution else if (_.startsWith(x, &quot;$@&quot;)) { const propertyName = x.substr(2); x2 = _.get(data.objects, [propertyName, &quot;value&quot;], x); } // SCOPE substitution else if (_.startsWith(x, &quot;$&quot;)) { const propertyName = x.substr(1); assert(_.has(SCOPE, propertyName), `${x} not in scope`); x2 = _.get(SCOPE, propertyName, x); } // Template substitution else if (_.startsWith(x, &quot;`&quot;) &amp;&amp; _.endsWith(x, &quot;`&quot;)) { const template = x.substr(1, x.length - 2); const scope = SCOPE; //_.mapKeys(SCOPE, (value, name) =&gt; &quot;$&quot;+name); // console.log({x, template, scope}) x2 = misc.renderTemplate(template, scope, data); // console.log({x2}) } } else if (_.isArray(x)) { x2 = _.map(x, y =&gt; substituteDeep(y, data, SCOPE, DATA, addCommonValuesToScope, depth+1)); } else if (_.isPlainObject(x)) { const updatedSCOPEDATA = updateSCOPEDATA(x, data, SCOPE, DATA, addCommonValuesToScope); // console.log({SCOPE, SCOPE2: updatedSCOPEDATA.SCOPE}) x2 = _.mapValues(x, (value, name) =&gt; { // Skip over @DATA, @SCOPE, directives and 'steps' properties if (_.startsWith(name, &quot;#&quot;) || _.endsWith(name, &quot;()&quot;) || name === &quot;data&quot; || name === &quot;@DATA&quot; || name === &quot;@SCOPE&quot; || name === &quot;steps&quot; || (depth &gt; 0 &amp;&amp; _.startsWith(name, &quot;lazy&quot;))) { //(_.isPlainObject(value) &amp;&amp; value.hasOwnProperty(&quot;command&quot;))) { // console.log(&quot;lazy...&quot;); console.trace(); // FIXME: for debug only return value; } else { return substituteDeep(value, data, updatedSCOPEDATA.SCOPE, updatedSCOPEDATA.DATA, addCommonValuesToScope, depth+1); } }); } return x2; } /** * Calculate `expr` using variables in `context`, with optional `spec` object specifying `units` and/or `decimals` */ function calculateWithMathjs(expr, context, spec={}) { const rx = /([_$a-zA-Z\\xA0-\\uFFFF][._$a-zA-Z0-9\\xA0-\\uFFFF]*)/g; const identifiers = expr.match(rx); const identifierValues = identifiers.map(key =&gt; { const x = _.get(context, key); if (_.isUndefined(x)) return undefined; // console.log({key, x}); if (_.isString(x)) { return calculateWithMathjs_variable(x); } else if (_.isArray(x)) { return x.map(y =&gt; _.isString(y) ? calculateWithMathjs_variable(y) : y); } return x; }); const identifierAndValues = _.zip(identifiers, identifierValues).filter(x =&gt; !_.isUndefined(x[1])); const scope = _.fromPairs(identifierAndValues); // console.log({expr, context, identifiers, identifierValues, scope}) // console.log({expr, scope}) // console.log(&quot;scope:&quot;+JSON.stringify(scope, null, '\\t')) let value = math.eval(expr, scope); // console.log({type: value.type, value}) // We're going to temprarily force value to be an array - this tells us whether we need to convert it back to a single item later. const doUnArray = !_.isArray(value); const values = (doUnArray) ? [value] : value; const processedValues = values.map(value =&gt; { if (_.isString(value) || _.isNumber(value) || _.isBoolean(value)) { return value; } // Get units to use in the end, and the unitless value const {units0, units, unitless} = (() =&gt; { const result = { units0: undefined, units: spec.units, unitless: value }; // If the result has units: if (value.type === &quot;Unit&quot;) { result.units0 = value.formatUnits(); if (_.isUndefined(result.units)) result.units = result.units0; const conversionUnits = (_.isEmpty(result.units)) ? result.units0 : result.units; // If the units dissappeared, e.g. when dividing 30ul/1ul = 30: if (_.isEmpty(conversionUnits)) { // TODO: find a better way to get the unit-less quantity from `value` // console.log({spec}) // console.log({result, conversionUnits}); result.unitless = math.eval(value.format()); } else { result.unitless = value.toNumeric(conversionUnits); } } return result; })(); // console.log(`unitless: ${JSON.stringify(unitless)}`) // Restrict decimal places // console.log({unitless}) const unitlessText = (_.isNumber(spec.decimals)) ? unitless.toFixed(spec.decimals) : _.isNumber(unitless) ? unitless : unitless.toNumber(); // Set units const valueText = (!_.isEmpty(units)) ? unitlessText + &quot; &quot; + units : unitlessText; return valueText; }); return (doUnArray) ? processedValues[0] : processedValues; } function calculateWithMathjs_variable(x) { // console.log({y: x}) if (_.isString(x) &amp;&amp; x.length &gt; 0) { const c0 = x[0]; const c1 = x[x.length - 1]; // console.log({c0, c1}) // If this might be a number with units if ( // If it starts with a digit or sign ((c0 &gt;= &quot;0&quot; &amp;&amp; c0 &lt;= &quot;9&quot;) || (c0 == &quot;+&quot; || c0 == &quot;-&quot;)) &amp;&amp; // and ends with a letter (c1 &gt;= &quot;a&quot; &amp;&amp; c1 &lt;= &quot;z&quot;) ) { try { const result = math.eval(x); // console.log({result}) return result; } catch (e) {} } } return x; } /** * Parse command parameters according to a schema. * * If parsing fails, an exception will be thrown. * * Otherwise, the returned result contains two properties: `value` and `objectName`. * Both properties are maps that reflect the structure of the given schema. * The `value` map contains the parsed values -- object references are replaced * by the actual object (in `data`), quantities are replaced by mathjs objects, * well specifications are replaced by an array of well references, etc. * * The `objectName` map contains any object names that were referenced; * in contrast to the `value` map (which is a tree of properties like `params`), * `objectName` is a flat map, where the keys are string representations of the * object paths (separated by '.'). * Any object names that were looked up will also be added to the `data.accesses` * list. * * @param {object} params - the parameters passed to the command * @param {object} data - protocol data * @param {object} schema - JSON Schema description, with roboliq type extensions * @return {object} the parsed parameters, if successfully parsed. */ function parseParams(params, data, schema) { const substituted = _.merge( _.pick(params, schema.noSubstitution), substituteDeep(_.omit(params, schema.noSubstitution), data, data.objects.SCOPE, data.objects.DATA) ); //console.log(&quot;SCOPE: &quot;+JSON.stringify(data.objects.SCOPE, null, '\\t')) const result = {orig: substituted, value: {}, objectName: {}, unknown: []}; processParamsBySchema(result, [], substituted, schema, data); // Remove any unknowns that aren't in the parameteters (they might be in referenced objects) result.unknown = result.unknown.filter(name =&gt; _.has(params, name)); // Remove unknown list if it's empty if (_.isEmpty(result.unknown)) { delete result.unknown; } return result; } /** * Try to process the given params with the given schema. * * Updates the `result` object. * Updates `data.accesses` if object lookups are performed. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} params - the part of the original parameters refered to by `path` * @param {object} schema - JSON Schema description, with roboliq extensions * @param {object} data - protocol data */ function processParamsBySchema(result, path, params, schema, data) { // console.log(`processParamsBySchema: ${JSON.stringify(params)} ${JSON.stringify(schema)}`) const required_l = schema.required || []; const l0 = _.toPairs(schema.properties); // If no properties are schemafied, return the original parameters if (l0.length === 0) { _.set(result.value, path, params); return result; } // Add unknowns result.unknown.push(..._.difference(_.keys(params), [&quot;description&quot;, &quot;comment&quot;, &quot;command&quot;, &quot;data&quot;, &quot;@DATA&quot;, &quot;@SCOPE&quot;].concat(_.keys(schema.properties))).map(x =&gt; path.concat(x).join(&quot;.&quot;))); // Otherwise, convert the parameters for (const [propertyName, p] of l0) { const type = p.type; const required = _.includes(required_l, propertyName); const defaultValue = p.default; const path1 = path.concat(propertyName); const value0 = _.cloneDeep(_.get(params, propertyName, defaultValue)); if (type === &quot;name&quot;) { // Normally, we don't want to process &quot;name&quot; parameters at all, but we // still need to dereference &quot;$&quot;-scope variables const value1 = (_.startsWith(value0, &quot;$@&quot;)) ? _.get(data.objects, value0.substring(2), value0) : (_.startsWith(value0, &quot;$&quot;)) ? _.get(data.objects.SCOPE, value0.substring(1), value0) : value0; if (!_.isUndefined(value1)) { _.set(result.value, path1, value1); } // If not optional, require the variable's presence: if (required) { //console.log({propertyName, type, info, params}) expect.truthy({paramName: propertyName}, !_.isUndefined(value1), &quot;missing required value [CODE 95]&quot;); } } else if (_.startsWith(type, &quot;nameOf &quot;)) { const type1 = type.substr(7); const value1 = lookupValue0(result, path1, value0, data); expect.truthy({paramName: path1.join(&quot;.&quot;)}, value1.type === type1, `expect the name of an object of type ${type1}: ${JSON.stringify(value1)}`); _.set(result.value, path1, result.objectName[path1.join(&quot;.&quot;)]); // console.log(&quot;nameOf result: &quot;+JSON.stringify(result)); } else { const value1 = _.clone(lookupValue0(result, path1, value0, data)); if (!_.isUndefined(value1) &amp;&amp; !_.isNull(value1)) { processValue0BySchema(result, path1, value1, p, data, propertyName); } // If not optional, require the variable's presence: else if (required) { // console.log({propertyName, type, result, path, params, schema}) expect.truthy({paramName: path1.join(&quot;.&quot;)}, false, &quot;missing required value [CODE 106]&quot;); } } } return result; } /** * Try to convert value0 (a &quot;raw&quot; value, no yet looked up) to the given type. * * - If schema is undefined, return value. * * - If schema.enum: return processValue0AsEnum() * * - If schema.type is undefined but there are schema.properties, assume schema.type = &quot;object&quot;. * * - If type is undefined or empty, return value. * * - If type is an array, try processing for each element of the array * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {any} value0 - the value to process * @param {object} schema - JSON Schema description, with roboliq extensions * @param {object} data - protocol data */ function processValue0BySchema(result, path, value0, schema, data) { // console.log(`processValue0BySchema(${path.join('.')}, ${JSON.stringify(value0)})`) //const valuePre = _.cloneDeep(value0); if (_.isUndefined(schema)) { _.set(result.value, path, value0); } else if (schema.hasOwnProperty('enum')) { return processValue0AsEnum(result, path, value0, schema, data); } else { const type = (_.isUndefined(schema.type) &amp;&amp; !_.isEmpty(schema.properties)) ? &quot;object&quot; : schema.type; if (_.isEmpty(type)) { _.set(result.value, path, value0); } else if (_.isString(type)) { processValue0BySchemaType(result, path, value0, schema, type, data); } // Otherwise, we should have an array of types else { // Try each type alternative: const types = _.flatten([schema.type]); return processValue0OnTypes(result, path, value0, schema, types, data); } } /*if (!_.isEqual(value0, valuePre)) { console.log(&quot;VALUE CHANGED&quot;); throw &quot;error&quot;; }*/ } /** * Try to process the value as an enum. * @param {object} result - result structure for values and objectNames * @param {array} path - path in params * @param {any} value0 - the value to process * @param {object} schema - schema * @param {object} data - protocol data */ function processValue0AsEnum(result, path, value0, schema, data) { const value1 = lookupValue0(result, path, value0, data); expect.truthy({paramName: path.join(&quot;.&quot;)}, _.includes(schema.enum, value1), &quot;expected one of &quot;+schema.enum+&quot;: &quot;+JSON.stringify(value0)); _.set(result.value, path, value1); } /** * A sub-function of processValue0BySchema(). * Try to process the value as a named type. * @param {object} result - result structure for values and objectNames * @param {array} path - path in params * @param {any} value0 - the value to process * @param {object} schema - schema * @param {object} data - protocol data */ function processValue0BySchemaType(result, path, value0, schema, type, data) { // console.log(`processValue0BySchemaType(${path.join('.')}, ${value0}, ${type})`) if (type === &quot;name&quot;) { _.set(result.value, path, value0); return; } else if (_.startsWith(type, &quot;nameOf &quot;)) { // REFACTOR: this duplicates code in processValue0BySchema() const type1 = type.substr(7); const value1 = lookupValue0(result, path, value0, data); expect.truthy({paramName: path.join(&quot;.&quot;)}, value1.type === type1, `expect the name of an object of type ${type1}: ${JSON.stringify(value1)}`); _.set(result.value, path, result.objectName[path.join(&quot;.&quot;)]); // console.log(&quot;nameOf result : &quot;+JSON.stringify(result)); return; } const value = _.cloneDeep(lookupValue0(result, path, value0, data)); // By default, set result.value@path = value _.set(result.value, path, value); const name = path.join(&quot;.&quot;); switch (type) { case &quot;array&quot;: return processValueAsArray(result, path, value, schema.items, data); case &quot;boolean&quot;: return processOneOfBasicType(result, path, value, _.isBoolean, &quot;boolean&quot;); case &quot;integer&quot;: return processOneOfBasicType(result, path, value, _.isInteger, &quot;integer&quot;); case &quot;markdown&quot;: return processString(result, path, value, data); case &quot;number&quot;: return processOneOfBasicType(result, path, value, _.isNumber, &quot;number&quot;); case &quot;null&quot;: return processOneOfBasicType(result, path, value, _.isNull, &quot;null&quot;); case &quot;string&quot;: return processString(result, path, value, data); case &quot;object&quot;: return processParamsBySchema(result, path, value, schema, data); case &quot;Agent&quot;: // TODO: need to check a list of which types are Agent types expect.truthy({paramName: name}, _.isPlainObject(value), &quot;expected object: &quot;+value); return; case &quot;Any&quot;: return; case &quot;Duration&quot;: return processDuration(result, path, value, data); case &quot;Equipment&quot;: // TODO: need to check a list of which types are Equipment types expect.truthy({paramName: name}, _.isPlainObject(value), &quot;expected object: &quot;+value); return; case &quot;Labware&quot;: return processValue0OnTypes(result, path, value0, schema, [&quot;Lid&quot;, &quot;Plate&quot;, &quot;Trough&quot;, &quot;Tube&quot;], data); case &quot;Length&quot;: return processLength(result, path, value, data); case &quot;Lid&quot;: return processObjectOfType(result, path, value, data, type); case &quot;Plate&quot;: return processObjectOfType(result, path, value, data, type); case &quot;Plates&quot;: return processOneOrArray(result, path, value, data, (result, path, x) =&gt; processObjectOfType(result, path, x, data, &quot;Plate&quot;, false)); case &quot;Site&quot;: return processObjectOfType(result, path, value, data, type); case &quot;SiteOrStay&quot;: return processSiteOrStay(result, path, value, data); case &quot;Source&quot;: return processSource(result, path, value, data); case &quot;Sources&quot;: return processSources(result, path, value, data); case &quot;String&quot;: return processString(result, path, value, data); case &quot;Temperature&quot;: return processTemperature(result, path, value, data); case &quot;Temperatures&quot;: return processOneOrArray(result, path, value, data, (result, path, x) =&gt; processTemperature(result, path, x, data)); case &quot;Volume&quot;: return processVolume(result, path, value, data); case &quot;Volumes&quot;: return processOneOrArray(result, path, value, data, (result, path, x) =&gt; processVolume(result, path, x, data)); case &quot;Well&quot;: return processWell(result, path, value, data); case &quot;Wells&quot;: return processWells(result, path, value, data); case &quot;File&quot;: var filename = value; var filedata = data.files[filename]; if (_.isUndefined(filedata)) filedata = defaultValue; if (_.isUndefined(filedata) &amp;&amp; _.isUndefined(filename)) return; expect.truthy({paramName: name, objectName: filename}, !_.isUndefined(filedata), &quot;file not loaded: &quot;+filename); //console.log({filedata}) result.objectName[path.join('.')] = filename; _.set(result.value, path, filedata); return; default: { if (data.schemas.hasOwnProperty(type)) { const schema = data.schemas[type]; // console.log({type, schema}) processValue0BySchema(result, path, value, schema, data); // console.log(&quot;result: &quot;+JSON.stringify(result, null, '\\t')) return; } else { const schema = roboliqSchemas[type]; if (!schema) console.log(&quot;known types: &quot;+_.keys(data.schemas).concat(_.keys(roboliqSchemas))) expect.truthy({paramName: name}, schema, &quot;unknown type: &quot;+JSON.stringify(type)); const isValid = tv4.validate(value, schema); expect.truthy({paramName: name}, isValid, tv4.toString()); return; } } } } /** * A sub-function of processValue0BySchema(). * Try to process the value as a named type. * @param {object} result - result structure for values and objectNames * @param {array} path - path in params * @param {any} value0 - the value to process * @param {object} schema - schema * @param {array} types - a list of types to try * @param {object} data - protocol data */ function processValue0OnTypes(result, path, value0, schema, types, data) { // console.log({types}) let es = []; for (const t of types) { try { // console.log({t, path, value0}) return processValue0BySchemaType(result, path, value0, schema, t, data); } catch (e) { es.push(e); } } if (!_.isEmpty(es)) // throw es[0]; throw es.join(&quot;; &quot;); } /** * Try to process a value as an array. * @param {object} result - result structure for values and objectNames * @param {array} path - path in params * @param {any} value0 - the value to process * @param {object} schema - schema of the array items * @param {object} data - protocol data */ function processValueAsArray(result, path, list0, schema, data) { //console.log(`processValueAsArray(${path}, ${list0})`) // FIXME: for debug only // if (!_.isArray(list0)) { // console.trace(); // process.exit(); // } // ENDFIX expect.truthy({paramName: path.join(&quot;.&quot;)}, _.isArray(list0), &quot;expected an array: &quot;+list0); //console.log({t2}) list0.forEach((x, index) =&gt; { //return processValueByType(x, t2, data, `${name}[${index}]`); processValue0BySchema(result, path.concat(index), x, schema, data); //console.log({x, t2, x2}) //return x2; }); //console.log({list1}) //return list1; } /** * Try to get a value from data.objects with the given name. * @param {object} data - Data object with 'objects' property * @param {array|string} path - Name of the object value to lookup * @param {any} dflt - default value to return * @return {Any} The value at the given path, if any */ function g(data, path, dflt) { const name = (_.isArray(path)) ? path.join('.') : path; if (_.isSet(data.accesses)) data.accesses.add(name); else data.accesses = new Set([name]); return _.get(data.objects, path, dflt); } /** * Try to lookup value0 in objects set. * This function is recursive - if the value refers to a variable, * the variables value will also be dereferenced. * When a variable is looked up, its also added to result.objectName[path]. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} data - protocol data * @param {any} value0 - The value from the user. * @return {any} A new value, if value0 referred to something in data.objects. */ function lookupValue0(result, path, value0, data) { if (_.isString(value0) &amp;&amp; !_.startsWith(value0, '&quot;')) { const deref = dereferenceVariable(data, value0); if (deref) { result.objectName[path.join(&quot;.&quot;)] = deref.objectName; // FIXME: for debug only // if (path.join(&quot;.&quot;) === &quot;plates2.0&quot;) { // console.trace(); // const process = require('process'); // process.exit(); // } // ENDFIX return deref.value; } } return value0; } /** * Recursively lookup variable by name or path and return the final value. * @param {object} data - protocol data * @param {string} name - name or path of object to lookup in `data.objects` * @return {any} result of the lookup, if successful; otherwise undefined. */ function dereferenceVariable(data, name) { const result = {}; // Query DATA if (_.startsWith(name, &quot;$$&quot;)) { if (_.isArray(data.objects.DATA)) { const propertyName = name.substr(2); result.value = getDesignFactor(propertyName, data.objects.DATA); //console.log(&quot;data.objects.DATA: &quot;+JSON.stringify(data.objects.DATA, null, '\\t')); //console.log({map: _(data.objects.DATA).map(propertyName).value()}); const accessName = &quot;DATA.&quot;+propertyName; if (_.isSet(data.accesses)) data.accesses.add(accessName); else data.accesses = new Set([accessName]); } } else { // Handle Variable reference if (_.startsWith(name, &quot;$@&quot;)) { // console.log({name}) name = name.substr(2); } // Handle SCOPE abbreviation else if (_.startsWith(name, &quot;$&quot;)) { name = &quot;SCOPE.&quot;+name.substr(1); } while (_.has(data.objects, name)) { const value = g(data, name); // console.log({value}) if (!_.startsWith(name, &quot;SCOPE.&quot;) &amp;&amp; !_.startsWith(name, &quot;DATA.&quot;)) { result.objectName = name; } //console.log({name, value}) if (value.type === &quot;Variable&quot; || value.type === &quot;Data&quot;) { result.value = value.value; name = value.value; } else { result.value = value; break; } } } return (_.isEmpty(result)) ? undefined : result; } /** * Accept either a single value whose type is checked with fnCheck(), or * an array with each element equal to the first - in that case, * set the result value to the first element of the array. * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {any} value - the value to process * @param {Function} fnCheck - a function that returns true if the value has the correct type * @param {string} expectedTypeName - name of the expected type, for constructing the error message if fnCheck fails */ function processOneOfBasicType(result, path, value, fnCheck, expectedTypeName) { if (fnCheck(value)) { return; } if (_.isArray(value)) { const one = value[0]; // console.log(&quot;processOneOfBasicType:&quot;); console.log({value, one, ok: _.map(value, x =&gt; _.isEqual(x, one))}) if (_.every(value, x =&gt; _.isEqual(x, one))) { _.set(result.value, path, one); return; } } expect.truthy({paramName: path.join(&quot;.&quot;)}, false, &quot;expected &quot;+expectedTypeName+&quot;: &quot;+value); return; } /** * If value is an array and every element of the array is the same, * return the first value of the array. Otherwise just return the value. * @param {any} value - value to inspect */ function getCommon(value) { if (_.isArray(value) &amp;&amp; value.length &gt; 0 &amp;&amp; _.every(value, x =&gt; _.isEqual(x, value[0]))) { return value[0]; } return value; } /** * Try to call fn on value0. If that works, return the value is made into * a singleton array. Otherwise try to process value0 as an array. * fn should accept parameters (result, path, value0) and set the value in * result.value at the given path. * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object */ function processOneOrArray(result, path, value0, data, fn) { // console.log(&quot;processOneOrArray:&quot;) // console.log({path, value0}) // Try to process value0 as a single value, then turn it into an array try { const path1 = path.concat(0); _.unset(result.value, path, undefined); fn(result, path1, value0); // If we reach this point, then value0 was able to be processed as an object, // so use it as a singleton array. // const value1 = _.get(result.value, path); // _.set(result.value, path1, value1); if (result.objectName.hasOwnProperty(path.join(&quot;.&quot;))) { result.objectName[path1.join(&quot;.&quot;)] = result.objectName[path.join(&quot;.&quot;)]; delete result.objectName[path.join(&quot;.&quot;)]; } // console.log(JSON.stringify(result)); // console.log(JSON.stringify(_.get(result.value, path))); // const x = _.get(result.value, path2); // console.log({path2, x: JSON.stringify(x)}) // _.set(result.value, path2, x); // console.log(JSON.stringify(result, null, '\\t')) return; } catch (e) { // console.log(e) } expect.truthy({paramName: path.join('.')}, _.isArray(value0), &quot;expected an array: &quot;+JSON.stringify(value0)); value0.forEach((x0, i) =&gt; { const path1 = path.concat(i) const x1 = _.cloneDeep(lookupValue0(result, path1, x0, data)); _.set(result.value, path1, x1); fn(result, path1, x1); }); } /** * Try to process a value as a length. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processLength(result, path, value0, data) { let x = getCommon(value0); if (_.isString(x)) { x = math.eval(x); } //console.log({function: &quot;processLength&quot;, path, x}) expect.truthy({paramName: path.join('.')}, math.unit('m').equalBase(x), &quot;expected a volume with meter units (m, mm, nm, etc.): &quot;+JSON.stringify(value0)); _.set(result.value, path, x); } /** * Try to process a value as a string. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} params - the part of the original parameters refered to by `path` * @param {object} data - protocol data */ function processString(result, path, value0, data) { // Follow de-references: var references = []; var objectName = undefined; let value1 = getCommon(value0); while (_.isString(value1) &amp;&amp; _.startsWith(value1, &quot;${&quot;) &amp;&amp; references.indexOf(value1) &lt; 0) { references.push(value1); objectName = value1.substring(2, value1.length - 1); if (_.has(data.objects, objectName)) { var type2 = g(data, objectName+&quot;.type&quot;); if (type2 === &quot;Variable&quot;) { value1 = g(data, objectName+&quot;.value&quot;); } else { value1 = g(data, objectName); } } } if (!_.isNull(value1)) _.set(result.value, path, value1.toString()); } /** * Tries to process and object with the given type, * whereby this simply means checking that the value * is a plain object with a property `type` whose value * is the given type. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data * @param {string} type - type of object expected * @param {boolean} allowArray - false if we should not look into an array for an object */ function processObjectOfType(result, path, value0, data, type, allowArray = true) { // console.log(&quot;processObjectOfType:&quot;) // console.log({result, path, value0, type}) let x = value0; if (allowArray &amp;&amp; _.isArray(value0) &amp;&amp; value0.length &gt; 0 &amp;&amp; _.every(value0, x =&gt; _.isEqual(x, value0[0]))) { x = _.cloneDeep(lookupValue0(result, path, value0[0], data)); } const paramName = path.join(&quot;.&quot;); expect.truthy({paramName}, _.isPlainObject(x), `expected an object of type ${type}: `+JSON.stringify(value0)); expect.truthy({paramName}, _.get(x, 'type') === type, `expected an object of type ${type}: `+JSON.stringify(value0)); _.set(result.value, path, x); } /** * Try to process a value as the keyword &quot;stay&quot; or as a Site reference. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processSiteOrStay(result, path, value0, data) { const x = getCommon(value0); if (x === &quot;stay&quot;) { // do nothing, leave the value as &quot;stay&quot; } else { processObjectOfType(result, path, x, data, &quot;Site&quot;); } } /** * Try to process a value as a source reference. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processSource(result, path, value0, data) { const x = getCommon(value0); // console.log(`processSource: ${JSON.stringify(path)}, ${JSON.stringify(x)}`) const l = processSources(result, path, x, data); expect.truthy({paramName: path.join('.')}, _.isArray(l) &amp;&amp; l.length === 1, &quot;expected a single liquid source: &quot;+JSON.stringify(x)); _.set(result.value, path, l[0]); } /** * Try to process a value as an array of source references. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processSources(result, path, x, data) { //console.log({before: x, paramName}) if (_.isString(x)) { x = wellsParser.parse(x, data.objects); //console.log({x}) expect.truthy({paramName: path.join('.')}, _.isArray(x), &quot;expected a liquid source: &quot;+JSON.stringify(x)); //x = [x]; } else if (_.isPlainObject(x) &amp;&amp; x.type === 'Liquid') { x = [x.wells]; } else if (_.isArray(x)) { x = x.map((x2, index) =&gt; { const path2 = path.concat(index) return expect.try({paramName: path2.join('.')}, () =&gt; { // console.log({x2}) if (_.isPlainObject(x2) &amp;&amp; x2.type === 'Liquid') { return [x.wells]; } else { const result2 = {value: {}, objectName: {}}; // console.log({result2, path2, x2}) processSource(result2, path2, x2, data); // console.log(`result2: ${JSON.stringify(result2)}`) return _.get(result2.value, path2); } }); }); } // console.log({x}) _.set(result.value, path, x); return x; } /** * Try to process a value as a temperature. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processTemperature(result, path, value0, data) { let x = getCommon(value0); if (_.isString(x)) { x = math.eval(x); } //console.log({function: &quot;processVolume&quot;, path, x}) expect.truthy({paramName: path.join('.')}, math.unit('degC').equalBase(x), &quot;expected a temperature with units degC, degF, or K: &quot;+JSON.stringify(value0)); _.set(result.value, path, x); //console.log(&quot;set in result.value&quot;) } /** * Try to process a value as a volume. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processVolume(result, path, value0, data) { let x = getCommon(value0); if (_.isString(x)) { x = math.eval(x); } //console.log({function: &quot;processVolume&quot;, path, x}) expect.truthy({paramName: path.join('.')}, math.unit('l').equalBase(x), &quot;expected a volume with liter units (l, ul, etc.): &quot;+JSON.stringify(value0)); _.set(result.value, path, x); //console.log(&quot;set in result.value&quot;) } /** * Try to process a value as a well reference. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processWell(result, path, value0, data) { let x = getCommon(value0); if (_.isString(x)) { //console.log(&quot;processWell:&quot;) //console.log({result, path, x}) x = wellsParser.parse(x, data.objects); } expect.truthy({paramName: path.join('.')}, _.isArray(x) &amp;&amp; x.length === 1, &quot;expected a single well indicator: &quot;+JSON.stringify(value0)); _.set(result.value, path, x[0]); } /** * Try to process a value as an array of wells. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x - the value to process * @param {object} data - protocol data */ function processWells(result, path, x, data) { if (_.isString(x)) { x = wellsParser.parse(x, data.objects); } expect.truthy({paramName: path.join('.')}, _.isArray(x), &quot;expected a list of wells: &quot;+JSON.stringify(x)); _.set(result.value, path, x); } /** * Try to process a value as a time duration. * * @param {object} result - the resulting object to return, containing objectName and value representations of params. * @param {array} path - path in the original params object * @param {object} x0 - the value to process * @param {object} data - protocol data */ function processDuration(result, path, value0, data) { let x = getCommon(value0); if (_.isNumber(x)) { x = math.unit(x, 's'); } else if (_.isString(x)) { x = math.eval(x); } //console.log({a: math.unit('s'), value: x, x0}) expect.truthy({paramName: path.join('.')}, math.unit('s').equalBase(x), &quot;expected a value with time units (s, second, seconds, minute, minutes, h, hour, hours, day, days): &quot;+JSON.stringify(value0)); _.set(result.value, path, x); } /** * Get a property value from an object in the parsed parameters. * If no value could be found (and no default was given) then an exception * will be thrown. * * @param {object} parsed - the parsed parameters object, as passed into a command handler * @param {object} data - protocol data * @param {string} paramName - parameter name (which should reference an object) * @param {string} propertyName - name of the object's property to retrieve * @param {any} defaultValue - default value if property not found * @return {any} the property value */ function getParsedValue(parsed, data, paramName, propertyName, defaultValue) { const value = _.get(parsed.value[paramName], propertyName, defaultValue); const objectName = parsed.objectName[paramName]; //console.log({parsed, x: parsed[paramName], paramName, propertyName}) if (!_.isUndefined(value)) { const objectName1 = (objectName) ? objectName+&quot;.&quot;+propertyName : paramName+&quot;/&quot;+propertyName; //console.trace(); expect.truthy({objectName1}, !_.isUndefined(value), &quot;missing value&quot;); return value; } else { expect.truthy({paramName: paramName}, !_.isUndefined(defaultValue), &quot;missing parameter value&quot;); return defaultValue; } } /** * Query the logic database with the given predicates and return the values * of interest. * @param {Object} data Command data * @param {Array} predicates Array of llpl predicates * @param {String} queryExtract A jmespath query string to extract values of interest from the llpl result list * @return {Array} Array of objects holding valid values */ function queryLogicGeneral(data, predicates, queryExtract) { var llpl = require('./HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); fixPredicateUndefines(predicates); var query = {&quot;and&quot;: predicates}; var resultList = llpl.query(query); //console.log(&quot;resultList:\\n&quot;+JSON.stringify(resultList, null, ' ')); if (_.isEmpty(resultList)) { var predicates2 = []; _.forEach(predicates, function(p, index) { var p2 = _.mapValues(p, function(value, name) { return &quot;?&quot;+name; }); predicates2.push(p2); var query2 = {&quot;and&quot;: predicates2}; var resultList2 = llpl.query(query); expect.truthy({}, !_.isEmpty(resultList2), &quot;logical query found no result for predicate &quot;+(index+1)+&quot; in: &quot;+JSON.stringify(query)); }); } if (queryExtract) { var alternatives = jmespath.search(resultList, queryExtract); return alternatives; } else { return resultList; } } /** * Query the logic database with the given predicates. If solutions are found, * choose one of the alternatives. * * @param {Object} data Command data * @param {Array} predicates Array of llpl predicates * @param {String} predicateName Name of the predicate we're interested in * @return {Array} - an array where the first item is the chosen solution, and the second item includes all alternatives. If no solution was found, then both items will be undefined. */ function queryLogic(data, predicates, predicateName) { const resultList = queryLogicGeneral(data, predicates, undefined); if (_.isEmpty(resultList)) { return [undefined, undefined]; } const queryExtract = `[].and[].&quot;${predicateName}&quot;` const alternatives = jmespath.search(resultList, queryExtract); assert(!_.isEmpty(alternatives), `${predicateName} not found in resultList ${JSON.stringify(resultList)} for predicates ${JSON.stringify(predicates)}`); // Pick a plan let chosen = alternatives[0]; if (data.planAlternativeChoosers.hasOwnProperty(predicateName)) { chosen = data.planAlternativeChoosers[predicateName](alternatives, data); // console.log({chosen}) } return [chosen, alternatives]; } /** * Helper function for queryLogic() that replaces undefined property values with * the name of the property prefixed by '?'. * @param {Array} predicates Array of llpl predicates */ function fixPredicateUndefines(predicate) { if (_.isArray(predicate)) { _.forEach(predicate, function(p) { fixPredicateUndefines(p); }); } else if (_.isPlainObject(predicate)) { _.forEach(predicate, function(value, name) { if (_.isUndefined(value)) predicate[name] = &quot;?&quot;+name; else if (_.isPlainObject(value)) { fixPredicateUndefines(value); } }) } } /** * Lookup nested paths. * * @example * This example will first lookup `object` in `params`, * then lookup the result in `data.objects`, * then get the value of `model`, * then lookup it value for `evowareName`: * * ``` * [[&quot;@object&quot;, &quot;model&quot;], &quot;evowareName&quot;] * ``` * * @param {array} path [description] * @param {object} params [description] * @param {object} data [description] * @return {any} [description] */ function lookupPath(path, params, data) { //console.log({path, params, data}) let prev; _.forEach(path, elem =&gt; { //console.log({elem}) let current = elem; if (_.isArray(elem)) current = lookupPath(elem, params, data); else { assert(_.isString(current)); if (_.startsWith(current, &quot;@&quot;)) { //console.log({current, tail: current.substring(1)}) current = current.substring(1); //console.log({current}) assert(_.has(params, current)); current = _.get(params, current); } } //console.log({prev, current}) if (_.isUndefined(prev)) { if (_.isString(current)) { const result = {value: {}, objectName: {}}; const path2 = []; // FIXME: figure out a sensible path in case of errors current = lookupValue0(result, path2, current, data); } prev = current; } else { assert(_.isString(current)); assert(_.has(prev, current)); prev = _.get(prev, current); } }); return prev; } function lookupPaths(paths, params, data) { return _.mapValues(paths, path =&gt; lookupPath(path, params, data)); } /** * Parse input spec and return object with the same properties as the spec, * but with values looked up. */ function parseInputSpec(inputSpec, parsed, data) { return _.mapValues(inputSpec, (item, key) =&gt; { return lookupInputPath(item, parsed, data); }); } /** * Lookup nested paths. * * @example * * * &quot;object&quot;: gets parameter value. * * &quot;?object&quot;: optionally gets parameter value. * * &quot;object*&quot;: looks up object. * * &quot;object*location&quot;: looks up object, gets `location` property. * * &quot;object*location*&quot;: looks up object, gets `location` property, looks up location. * * &quot;object*location*type&quot;: looks up object, looks up its `location` property, gets type property. * * &quot;something**&quot;: double de-reference * * &quot;object*(someName)&quot;: looks up object, gets someName value, gets object's property with that value. (this is not currently implemented) * * @param {array} path [description] * @param {object} parsed [description] * @param {object} data [description] * @return {any} [description] */ function lookupInputPath(path, parsed, data) { // console.log(&quot;lookupInputPath:&quot;); console.log({path, parsed}) assert(_.isString(path) &amp;&amp; !_.isEmpty(path)); // Check whether success is required let required = true; if (path[0] == &quot;?&quot;) { required = false; path = path.substring(1); } const elems = _.filter(path.split(/([*])/), s =&gt; !_.isEmpty(s)); // console.log({elems}); let current; try { for (let i = 0; i &lt; elems.length; i++) { const elem = elems[i]; if (elem == &quot;*&quot;) { assert(_.isString(current), &quot;cannot dereference: &quot;+JSON.stringify({path, i, elem, current})); current = lookupInputPath_dereference(current, data); } else { if (_.isUndefined(current)) { current = parsed.objectName[elem] || parsed.orig[elem]; } else { current = _.get(current, elem); } } assert(current, `${elem} not found in path ${path}`); } } catch (e) { if (!required) return undefined; throw e; } return current; } function lookupInputPath_dereference(current, data) { const result = {value: {}, objectName: {}}; const path2 = []; // FIXME: figure out a sensible path in case of errors const current2 = lookupValue0(result, path2, current, data); return current2; } /** * Return array of step keys in order. * Any keys that begin with a number will be included, * and they will be sorted in natural order. * * @param {object|array} o - an object or array of steps * @return {array} an ordered array of keys that represent steps */ function getStepKeys(steps) { if (_.isPlainObject(steps)) { // Find all sub-steps (properties that start with a digit) const rx = /^[0-9]/; const keys = _.keys(steps).filter(x =&gt; rx.test(x)); // Sort them in &quot;natural&quot; order keys.sort(naturalSort); return keys; } else if (_.isArray(steps)) { return _.range(steps.length); } else { return []; } } /** * Return an object that conforms to the expected format for steps. * * @param {array|object} steps - input in format of an array of steps, a single step, or propertly formatted steps. * @return {object} an object with only numeric keys, representing a sequence of steps. */ function stepify(steps) { if (_.isPlainObject(steps)) { const rx = /^[0-9]/; const hasOnlyStepKeys = _.keys(steps).every(x =&gt; rx.test(x)); if (hasOnlyStepKeys) { return steps; } else { return {&quot;1&quot;: steps}; } } else if (_.isArray(steps)) { steps = _.compact(_.flattenDeep(steps)); return _.zipObject(_.range(1, steps.length+1), steps); } else { assert(false, &quot;expected an array or a plain object: &quot;+JSON.stringify(steps)); } } /** * Process '@DATA', '@SCOPE', and 'data' properties for a step, * The returned data table will be the first to exist of '@DATA', 'DATA', and 'objects.DATA' * The returned scope will be the merger of data.objects.SCOPE, SCOPE, '@SCOPE', and common DATA values. * and return updated {DATA, SCOPE}. */ function updateSCOPEDATA(step, data, SCOPE = undefined, DATA = undefined, addCommonValuesToScope=true) { // console.log(&quot;updateSCOPEDATA&quot;); // console.log(JSON.stringify(step)); // FIXME: Debug only // if (step.value) { // assert(false); // } // ENDFIX // console.log(&quot;data2: &quot;+JSON.stringify(data)); // console.log({SCOPE}) const overwriteCommon = !_.isEmpty(DATA); DATA = (step.hasOwnProperty(&quot;@DATA&quot;)) ? step[&quot;@DATA&quot;] : (!_.isUndefined(DATA)) ? DATA : data.objects.DATA || []; // console.log({DATA}) // Handle `data` parameter by loading Design data SCOPE and possibly // repeating the command for each group or each row if (step.hasOwnProperty(&quot;data&quot;)) { const dataInfo = misc.handleDirectiveDeep(step.data, data); // console.log({dataInfo}) let table = DATA; if (_.isString(dataInfo) || dataInfo.source) { const dataId = _.isString(dataInfo) ? dataInfo : dataInfo.source; const source = _.get(data.objects, dataId); // console.log({source}) // console.log(&quot;data.objects:&quot;) // console.log(data.objects) assert(source, `Data source not found: ${dataId}`); if (_.isArray(source)) { table = source; } else if (source.type === &quot;Data&quot;) { if (!_.isUndefined(source.value)) { table = source.value; } else { const design = substituteDeep(source, data, SCOPE, DATA); table = Design.flattenDesign(design); } } else { assert(false, &quot;unrecognized data source: &quot;+JSON.stringify(dataId)+&quot; -&gt; &quot;+JSON.stringify(source)); } } else if (_.isPlainObject(dataInfo.design)) { const design = substituteDeep(dataInfo.design, data, SCOPE, DATA); // console.log({design0: dataInfo.design, design1: design}) table = Design.flattenDesign({design}); // console.log({table}) } if (_.isPlainObject(dataInfo)) { const SCOPE2 = _.defaults({}, SCOPE, data.SCOPE); const query = _.clone(dataInfo); if (query.where) { query.where = substituteDeep(query.where, data, SCOPE, DATA); } // console.log({dataInfo, table}) // console.log({SCOPE2}); table = _.flatten(Design.query(table, query, SCOPE2)); // console.log({dataInfo, table}) } DATA = table; } //console.log(&quot;DATAs: &quot;+JSON.stringify(DATAs, null, '\\t')); const always = { // access the raw objects __objects: data.objects, // access the current raw data table __data: DATA, // access raw protocol parameters __parameters: _.get(data, [&quot;protocol&quot;, &quot;parameters&quot;], {}), // access parameters from any step in the current step stack (0 = current step) // __stepStack: null, }; if (step.hasOwnProperty(&quot;command&quot;)) { // access parameters of the current step always.__step = step; } // console.log({isEmpty: _.isEmpty(DATA)}) const columns = (!overwriteCommon || _.isEmpty(DATA)) ? {} : _.fromPairs(_.map(_.keys(DATA[0]), key =&gt; [key, _.map(DATA, key)])); // console.log({DATA, columns, strange: _.map(DATA, &quot;n&quot;)}); const common = overwriteCommon ? _.mapKeys( (addCommonValuesToScope) ? Design.getCommonValues(DATA) : {}, (value, key) =&gt; key + &quot;_ONE&quot; ) : {}; const ATSCOPE = (step.hasOwnProperty(&quot;@SCOPE&quot;)) ? step[&quot;@SCOPE&quot;] : {}; SCOPE = _.defaults(always, columns, common, ATSCOPE, SCOPE, data.objects.SCOPE); return {DATA, SCOPE}; } function copyItemsWithDefaults(items, defaults) { // console.log(&quot;copyItemsWithDefaults: &quot;+JSON.stringify(items)+&quot;, &quot;+JSON.stringify(defaults)) if (_.isArray(items)) { items = _.cloneDeep(items); } // Create a new array with the appropriate size else { const defaultCounts = _.mapValues(defaults, (value) =&gt; (_.isArray(value)) ? value.length : 1); let counts = _.uniq(_.values(defaultCounts)); counts.sort(); let size; if (counts.length === 1) { size = counts[0]; } else { counts = _.filter(counts, n =&gt; n != 1); assert(counts.length === 1, &quot;unequal array sizes: &quot;+JSON.stringify({items, defaults})); size = counts[0]; } items = _.map(_.range(size), () =&gt; ({})); } for (let i = 0; i &lt; items.length; i++) { const item = items[i]; _.forEach(defaults, (value, name) =&gt; { if (_.isUndefined(item[name]) &amp;&amp; !_.isUndefined(value)) { if (_.isArray(value)) { if (value.length === 1) { item[name] = value[0]; } else { assert(i &lt; value.length, &quot;value array not long enough for target: &quot;+JSON.stringify({name, i, value, target: items})); item[name] = value[i]; } } else { item[name] = value; } } }); } return items; } function splitItemsAndDefaults(items, keysToSkip) { // console.log(&quot;splitItemsAndDefaults: &quot;+JSON.stringify(items)+&quot;, &quot;+JSON.stringify(keysToSkip)) let defaults = {}; if (_.size(items) &gt; 1) { defaults = Design.getCommonValues(items); if (_.isArray(keysToSkip) &amp;&amp; !_.isEmpty(keysToSkip)) { defaults = _.omit(defaults, keysToSkip); } // console.log({defaults}) if (_.size(defaults) &gt; 0) { const keysToOmit = _.keys(defaults); items = _.map(items, item =&gt; _.omit(item, keysToOmit)); } } return {items, defaults}; } /* function setDefaultInArrayOfObjects(name, value, l) { assert(_.isArray(l), &quot;expected and array: &quot;+JSON.stringify(l)); for (let i = 0; i &lt; l.length; i++) { const item = l[i]; if (_.isUndefined(item[name])) { if (_.isArray(value)) { assert(i &lt; value.length, &quot;value array not long enough for target: &quot;+JSON.stringify({value, target: l})); item[name] = value[i]; } else { item[name] = value; } } } } */ module.exports = { asArray, copyItemsWithDefaults, createData, getDesignFactor, _dereferenceVariable: dereferenceVariable, _g: g, // getCommonValues: Design.getCommonValues, getParsedValue, getStepKeys, lookupPath, lookupPaths, parseInputSpec, _lookupInputPath: lookupInputPath, parseParams, queryLogic, // setDefaultInArrayOfObjects, splitItemsAndDefaults, stepify, substituteDeep, updateSCOPEDATA, } × Search results Close "},"commands_absorbanceReader.js.html":{"id":"commands_absorbanceReader.js.html","title":"Source: commands/absorbanceReader.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/absorbanceReader.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Absorbance Reader commands module. * @module commands/absorbanceReader * @return {Protocol} * @version v1 */ var _ = require('lodash'); var jmespath = require('jmespath'); import math from 'mathjs'; import yaml from 'yamljs'; var commandHelper = require('../commandHelper.js'); const Design = require('../design.js'); var expect = require('../expect.js'); import {mergeR} from '../mergeR.js'; var misc = require('../misc.js'); import * as simulatedHelpers from './simulatedHelpers.js'; import wellsParser from '../parsers/wellsParser.js'; /** * Handlers for {@link absorbanceReader} commands. * @static */ var commandHandlers = { &quot;absorbanceReader.measurePlate&quot;: function(params, parsed, data) { // console.log(JSON.stringify(parsed)); var model = commandHelper.getParsedValue(parsed, data, 'object', 'model'); var location0 = commandHelper.getParsedValue(parsed, data, 'object', 'location'); var predicates = [ {&quot;absorbanceReader.canAgentEquipmentModelSite&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: model, &quot;site&quot;: parsed.objectName.site }} ]; var [params2, alternatives] = commandHelper.queryLogic(data, predicates, &quot;absorbanceReader.canAgentEquipmentModelSite&quot;); // console.log(&quot;params2:\\n&quot;+JSON.stringify(params2, null, ' ')) // console.log(&quot;parsed.value.outputFile: &quot;+JSON.stringify(parsed.value.outputFile)); const destinationAfter = (parsed.value.destinationAfter === &quot;stay&quot;) ? null : _.isUndefined(parsed.objectName.destinationAfter) ? location0 : parsed.objectName.destinationAfter; // Program to pass to sub-command const program = mergeR({}, parsed.orig.program, { wells: (parsed.value.program || {}).wells }); // Handle deprecated parameter names const output = mergeR({}, parsed.orig.output, { joinKey: _.get(parsed.orig, &quot;program.wellDesignFactor&quot;), userValues: _.get(parsed.orig, &quot;program.userValues&quot;), writeTo: _.get(parsed.orig, &quot;outputFile&quot;), appendTo: _.get(parsed.orig, &quot;outputDataset&quot;), }); // console.log({output}) var expansion = [ (params2.site === location0) ? null : { command: &quot;transporter.movePlate&quot;, object: parsed.objectName.object, destination: params2.site }, _.merge({}, { command: [&quot;equipment.run&quot;, params2.agent, params2.equipment].join('|'), agent: params2.agent, equipment: params2.equipment, measurementType: &quot;absorbance&quot;, program: (_.isEmpty(program)) ? undefined : program, programFileTemplate: parsed.value.programFileTemplate, programFile: parsed.value.programFile, programData: parsed.value.programData, object: parsed.objectName.object, output: (_.isEmpty(output)) ? undefined : output }), (destinationAfter === null || destinationAfter === params2.site) ? null : { command: &quot;transporter.movePlate&quot;, object: parsed.objectName.object, destination: destinationAfter } ]; // console.log({expansion1: expansion[0]}) // console.log({expansion1output: expansion[1].output}) const result = {expansion}; if (_.has(parsed.value, [&quot;output&quot;, &quot;simulated&quot;])) { // Wells are chosen as follows: // 1) program.wells // 2) output.joinKey // 3) all wells on labware const wells = (_.has(parsed.value, [&quot;program&quot;, &quot;wells&quot;])) ? commandHelper.asArray(parsed.value.program.wells) : (!_.isUndefined(output.joinKey)) ? commandHelper.getDesignFactor(output.joinKey, data.objects.DATA) : wellsParser.parse(`${parsed.objectName.object}(all)`, data.objects); // console.log({wells}) simulatedHelpers.simulatedByWells(parsed, data, wells, result); } // console.log(&quot;RESULTS:\\n&quot;+JSON.stringify(result)) return result; }, }; module.exports = { roboliq: &quot;v1&quot;, schemas: yaml.load(__dirname+&quot;/../schemas/absorbanceReader.yaml&quot;), commandHandlers }; × Search results Close "},"commands_centrifuge.js.html":{"id":"commands_centrifuge.js.html","title":"Source: commands/centrifuge.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/centrifuge.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Centrifuge commands module (see {@tutorial Commands#centrifuge} or [command specification](tutorial-Commands.html#centrifuge)). * * THIS SECTION IS FOR TESTING ONLY: * {@link loadEvowareCarrierData} * {@link module:commandHelper} * {@link module:commands/centrifuge} * END OF SECTION * * See {@link roboliq#Protocol}. * @module commands/centrifuge * @return {Protocol} * @version v1 */ var _ = require('lodash'); var jmespath = require('jmespath'); import yaml from 'yamljs'; var commandHelper = require('../commandHelper.js'); var expect = require('../expect.js'); var misc = require('../misc.js'); /** * Create predicates for objects of type = &quot;Centrifuge&quot; * @static */ var objectToPredicateConverters = { &quot;Centrifuge&quot;: function(name, object) { return [{ &quot;isCentrifuge&quot;: { &quot;equipment&quot;: name } }]; }, }; function centrifuge2(params, parsed, data) { var llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); //console.log(JSON.stringify(parsed, null, '\\t')) var agent = parsed.objectName.agent || &quot;?agent&quot;; var equipment = parsed.objectName.equipment || &quot;?equipment&quot;; var object1 = parsed.value.object1; var object2 = parsed.value.object2; var query0 = { &quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot;, &quot;model&quot;: &quot;?model&quot;, &quot;site1&quot;: &quot;?site1&quot;, &quot;site2&quot;: &quot;?site2&quot; } }; var query = _.merge({}, query0, {&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: object1.model, &quot;site1&quot;: parsed.objectName.site1, &quot;site2&quot;: parsed.objectName.site2 }} ); var resultList = llpl.query(query); var alternatives = jmespath.search(resultList, '[].&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;'); if (_.isEmpty(resultList)) { var resultList2 = llpl.query(query0); if (_.isEmpty(resultList2)) { return { errors: [&quot;missing equipment data (please add predicates `centrifuge.canAgentEquipmentModelSite1Site`)&quot;] }; } else { return { errors: [&quot;missing equipment configuration for &quot; + JSON.stringify(query)] }; } } // Pick a plan let chosen = undefined; if (data.planAlternativeChoosers.hasOwnProperty(&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;)) { chosen = data.planAlternativeChoosers[&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;](alternatives, data); // console.log({chosen}) } const params2 = chosen || alternatives[0]; const destination1 = (parsed.value.destinationAfter1 === &quot;stay&quot;) ? params2.site1 : _.isUndefined(parsed.objectName.destinationAfter1) ? object1.location : parsed.objectName.destinationAfter1; const destination2 = (parsed.value.destinationAfter2 === &quot;stay&quot;) ? params2.site2 : _.isUndefined(parsed.objectName.destinationAfter2) ? object2.location : parsed.objectName.destinationAfter2; var expansion = [ (object1.location === params2.site1) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site1 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object1, &quot;destination&quot;: params2.site1 } ], (object2.location === params2.site2) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site2 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object2, &quot;destination&quot;: params2.site2 } ], { command: &quot;equipment.close&quot;, agent: params2.agent, equipment: params2.equipment }, { command: [&quot;equipment.run&quot;, params2.agent, params2.equipment].join('|'), agent: params2.agent, equipment: params2.equipment, program: parsed.objectName.program || parsed.value.program }, // Move object1 back (destination1 === params2.site1) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site1 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object1, &quot;destination&quot;: destination1 } ], // Move object2 back (destination2 === params2.site2) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site2 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object2, &quot;destination&quot;: destination2 } ], // Close the centrifuge (destination1 === params2.site1 &amp;&amp; destination2 === params2.site2) ? null : { command: &quot;equipment.close&quot;, agent: params2.agent, equipment: params2.equipment }, ]; const warnings = (object1.model != object2.model) ? [&quot;[W#CENT0001] object1 and object2 are of different labware models; this may be problematic for centrifugation.&quot;] : []; //console.log(&quot;centrifuge2 expansion:&quot;) //console.log(JSON.stringify(expansion, null, '\\t')) return { expansion, alternatives, warnings }; } function insertPlates2(params, parsed, data) { // console.log(&quot;insertPlates2: &quot;+JSON.stringify(parsed, null, '\\t')); var llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); if (!parsed.value.object1 &amp;&amp; !parsed.value.object2) { // do nothing return {}; } var agent = parsed.objectName.agent || &quot;?agent&quot;; var equipment = parsed.objectName.equipment || &quot;?equipment&quot;; var object1 = parsed.value.object1; var object2 = parsed.value.object2; const model = (object1) ? object1.model : object2.model; var query0 = { &quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot;, &quot;model&quot;: &quot;?model&quot;, &quot;site1&quot;: &quot;?site1&quot;, &quot;site2&quot;: &quot;?site2&quot; } }; var query = _.merge({}, query0, {&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: model, &quot;site1&quot;: parsed.objectName.site1, &quot;site2&quot;: parsed.objectName.site2 }} ); var resultList = llpl.query(query); var alternatives = jmespath.search(resultList, '[].&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;'); if (_.isEmpty(resultList)) { var resultList2 = llpl.query(query0); if (_.isEmpty(resultList2)) { return { errors: [&quot;missing equipment data (please add predicates `centrifuge.canAgentEquipmentModelSite1Site`)&quot;] }; } else { return { errors: [&quot;missing equipment configuration for &quot; + JSON.stringify(query)] }; } } // Pick a plan let chosen = undefined; if (data.planAlternativeChoosers.hasOwnProperty(&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;)) { chosen = data.planAlternativeChoosers[&quot;centrifuge.canAgentEquipmentModelSite1Site2&quot;](alternatives, data); // console.log({chosen}) } const params2 = chosen || alternatives[0]; var expansion = [ (!object1 || object1.location === params2.site1) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site1 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object1, &quot;destination&quot;: params2.site1 } ], (!object2 || object2.location === params2.site2) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site2 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object2, &quot;destination&quot;: params2.site2 } ], ]; const warnings = (parsed.input.object1Model &amp;&amp; parsed.input.object2Model &amp;&amp; parsed.input.object1Model != parsed.input.object2Model) ? [&quot;[W#CENT0001] object1 and object2 are of different labware models; this may be problematic for centrifugation.&quot;] : []; return { expansion, alternatives, warnings }; } insertPlates2.inputSpec = { agent: &quot;?agent&quot;, equipment: &quot;?equipment&quot;, object1: &quot;?object1&quot;, object2: &quot;?object2&quot;, object1Model: &quot;?object1*model&quot;, object2Model: &quot;?object2*model&quot;, site1: &quot;?site1&quot;, site2: &quot;?site2&quot; }; /** * Handlers for {@link centrifuge} commands. * @static */ var commandHandlers = { &quot;centrifuge.centrifuge2&quot;: centrifuge2, &quot;centrifuge.insertPlates2&quot;: insertPlates2 }; module.exports = { roboliq: &quot;v1&quot;, objectToPredicateConverters, schemas: yaml.load(__dirname+&quot;/../schemas/centrifuge.yaml&quot;), commandHandlers }; × Search results Close "},"commands_incubator.js.html":{"id":"commands_incubator.js.html","title":"Source: commands/incubator.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/incubator.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Incubator commands module (see {@tutorial Commands#incubator} or [command specification](tutorial-Commands.html#incubator)). * * See {@link roboliq#Protocol}. * @module commands/incubator * @return {Protocol} * @version v1 */ var _ = require('lodash'); var jmespath = require('jmespath'); import yaml from 'yamljs'; var commandHelper = require('../commandHelper.js'); var expect = require('../expect.js'); var misc = require('../misc.js'); /** * Create predicates for objects of type = &quot;Incubator&quot; * @static */ var objectToPredicateConverters = { &quot;Incubator&quot;: function(name, object) { return [{ &quot;isIncubator&quot;: { &quot;equipment&quot;: name } }]; }, }; /* function closeAll(parsed, data, effects) { // Close equipment effects[parsed.objectName.equipment+&quot;.open&quot;] = false; // Indicate that all internal sites are closed _.forEach(parsed.value.equipment.sitesInternal, function(site) { effects[site+&quot;.closed&quot;] = true; }); } */ /** * Handlers for {@link incubator} commands. * @static */ var commandHandlers = { &quot;incubator.incubatePlates&quot;: function(params, parsed, data) { var llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); //console.log(JSON.stringify(parsed, null, '\\t')) var agent = parsed.objectName.agent || &quot;?agent&quot;; var equipment = parsed.objectName.equipment || &quot;?equipment&quot;; var object1 = parsed.value.object1; var object2 = parsed.value.object2; if (object1.model != object2.model) return {errors: [&quot;object1 and object2 must have the same model for centrifugation.&quot;]}; var query0 = { &quot;incubator.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot;, &quot;model&quot;: &quot;?model&quot;, &quot;site1&quot;: &quot;?site1&quot;, &quot;site2&quot;: &quot;?site2&quot; } }; var query = _.merge({}, query0, {&quot;incubator.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: object1.model, &quot;site1&quot;: parsed.objectName.site1, &quot;site2&quot;: parsed.objectName.site2 }} ); var resultList = llpl.query(query); var alternatives = jmespath.search(resultList, '[].&quot;incubator.canAgentEquipmentModelSite1Site2&quot;'); if (_.isEmpty(resultList)) { var resultList2 = llpl.query(query0); if (_.isEmpty(resultList2)) { return { errors: [&quot;missing equipment data (please add predicates `incubator.canAgentEquipmentModelSite1Site`)&quot;] }; } else { return { errors: [&quot;missing equipment configuration for &quot; + JSON.stringify(query)] }; } } // Find any parameters which can only take one specific value var params2 = alternatives[0]; //console.log(&quot;alternatives[0]:\\n&quot;+JSON.stringify(params2)) const destination1 = (parsed.value.destinationAfter1 === &quot;stay&quot;) ? params2.site1 : _.isUndefined(parsed.objectName.destinationAfter1) ? object1.location : parsed.objectName.destinationAfter1; const destination2 = (parsed.value.destinationAfter2 === &quot;stay&quot;) ? params2.site2 : _.isUndefined(parsed.objectName.destinationAfter2) ? object2.location : parsed.objectName.destinationAfter2; var expansion = [ (object1.location === params2.site1) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site1 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object1, &quot;destination&quot;: params2.site1 } ], (object2.location === params2.site2) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site2 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object2, &quot;destination&quot;: params2.site2 } ], { command: [&quot;equipment.run&quot;, params2.agent, params2.equipment].join('|'), agent: params2.agent, equipment: params2.equipment, program: parsed.objectName.program || parsed.value.program }, // Move object1 back (destination1 === params2.site1) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site1 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object1, &quot;destination&quot;: destination1 } ], // Move object2 back (destination2 === params2.site2) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site2 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object2, &quot;destination&quot;: destination2 } ], // Close the incubator (destination1 === params2.site1 &amp;&amp; destination2 === params2.site2) ? null : { command: &quot;equipment.close&quot;, agent: params2.agent, equipment: params2.equipment }, ]; //console.log(&quot;incubator2 expansion:&quot;) //console.log(JSON.stringify(expansion, null, '\\t')) return { expansion: expansion, alternatives: alternatives }; }, &quot;incubator.insertPlates&quot;: function(params, parsed, data) { var llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); if (!parsed.value.object1 &amp;&amp; !parsed.value.object2) { // do nothing return {}; } var agent = parsed.objectName.agent || &quot;?agent&quot;; var equipment = parsed.objectName.equipment || &quot;?equipment&quot;; var object1 = parsed.value.object1; var object2 = parsed.value.object2; if (object1 &amp;&amp; object2 &amp;&amp; object1.model !== object2.model) return {errors: [&quot;object1 and object2 must have the same model for centrifugation.&quot;]}; const model = (object1) ? object1.model : object2.model; expect.truthy({}, model, &quot;object1 or object2 must have a `model` value&quot;); var query0 = { &quot;incubator.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot;, &quot;model&quot;: &quot;?model&quot;, &quot;site1&quot;: &quot;?site1&quot;, &quot;site2&quot;: &quot;?site2&quot; } }; var query = _.merge({}, query0, {&quot;incubator.canAgentEquipmentModelSite1Site2&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, &quot;model&quot;: model, &quot;site1&quot;: parsed.objectName.site1, &quot;site2&quot;: parsed.objectName.site2 }} ); var resultList = llpl.query(query); var alternatives = jmespath.search(resultList, '[].&quot;incubator.canAgentEquipmentModelSite1Site2&quot;'); if (_.isEmpty(resultList)) { var resultList2 = llpl.query(query0); if (_.isEmpty(resultList2)) { return { errors: [&quot;missing equipment data (please add predicates `incubator.canAgentEquipmentModelSite1Site`)&quot;] }; } else { return { errors: [&quot;missing equipment configuration for &quot; + JSON.stringify(query)] }; } } // Find any parameters which can only take one specific value var params2 = alternatives[0]; //console.log(&quot;alternatives[0]:\\n&quot;+JSON.stringify(params2)) var expansion = [ (!object1 || object1.location === params2.site1) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site1 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object1, &quot;destination&quot;: params2.site1 } ], (!object2 || object2.location === params2.site2) ? null : [ { command: &quot;equipment.openSite&quot;, agent: params2.agent, equipment: params2.equipment, site: params2.site2 }, { &quot;command&quot;: &quot;transporter.movePlate&quot;, &quot;object&quot;: parsed.objectName.object2, &quot;destination&quot;: params2.site2 } ], ]; return { expansion: expansion, alternatives: alternatives }; }, &quot;incubator.run&quot;: function(params, parsed, data) { var llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); //console.log(JSON.stringify(parsed, null, '\\t')) var agent = parsed.objectName.agent || &quot;?agent&quot;; var equipment = parsed.objectName.equipment || &quot;?equipment&quot;; var object1 = parsed.value.object1; var object2 = parsed.value.object2; if (object1.model != object2.model) return {errors: [&quot;object1 and object2 must have the same model for centrifugation.&quot;]}; var query0 = { &quot;incubator.canAgentEquipment&quot;: { &quot;agent&quot;: &quot;?agent&quot;, &quot;equipment&quot;: &quot;?equipment&quot; } }; var query = _.merge({}, query0, {&quot;incubator.canAgentEquipment&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment }} ); var resultList = llpl.query(query); var alternatives = jmespath.search(resultList, '[].&quot;incubator.canAgentEquipment&quot;'); if (_.isEmpty(resultList)) { var resultList2 = llpl.query(query0); if (_.isEmpty(resultList2)) { return { errors: [&quot;missing equipment data (please add predicates `incubator.canAgentEquipment`)&quot;] }; } else { return { errors: [&quot;missing equipment configuration for &quot; + JSON.stringify(query)] }; } } // Find any parameters which can only take one specific value var params2 = alternatives[0]; //console.log(&quot;alternatives[0]:\\n&quot;+JSON.stringify(params2)) var expansion = [ { command: [&quot;equipment.run&quot;, params2.agent, params2.equipment].join('|'), agent: params2.agent, equipment: params2.equipment, program: parsed.objectName.program || parsed.value.program }, ]; //console.log(&quot;incubator2 expansion:&quot;) //console.log(JSON.stringify(expansion, null, '\\t')) return { expansion: expansion, alternatives: alternatives }; }, }; module.exports = { roboliq: &quot;v1&quot;, objectToPredicateConverters, schemas: yaml.load(__dirname+&quot;/../schemas/incubator.yaml&quot;), commandHandlers }; × Search results Close "},"commands_pipetter.js.html":{"id":"commands_pipetter.js.html","title":"Source: commands/pipetter.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/pipetter.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Namespace for the ``pipetter`` commands. * @namespace pipetter * @version v1 */ /** * Pipetter commands module. * @module commands/pipetter * @return {Protocol} * @version v1 */ const _ = require('lodash'); const assert = require('assert'); const math = require('mathjs'); import yaml from 'yamljs'; const commandHelper = require('../commandHelper.js'); const expect = require('../expect.js'); const misc = require('../misc.js'); const groupingMethods = require('./pipetter/groupingMethods.js'); const pipetterUtils = require('./pipetter/pipetterUtils.js'); import * as simulatedHelpers from './simulatedHelpers.js'; const sourceMethods = require('./pipetter/sourceMethods.js'); const wellsParser = require('../parsers/wellsParser.js'); import * as WellContents from '../WellContents.js'; const intensityToValue = { &quot;none&quot;: 0, &quot;flush&quot;: 1, &quot;light&quot;: 2, &quot;thorough&quot;: 3, &quot;decontaminate&quot;: 4 }; const valueToIntensity = [&quot;none&quot;, &quot;flush&quot;, &quot;light&quot;, &quot;thorough&quot;, &quot;decontaminate&quot;]; /** * Takes a labware name and a well and returns a fully specified well. * If the wells is undefined, return undefined. * @param {string} [labwareName] - name of labware for wells that don't have specified labware. * @param {array} [well] - well identifier, with or without labware explicitly specified. * @return {array} fully specified well (e.g. on labware). */ function getLabwareWell(labwareName, well) { if (_.isString(well) &amp;&amp; _.isString(labwareName) &amp;&amp; !_.isEmpty(labwareName)) { return (_.includes(well, &quot;(&quot;)) ? well : `${labwareName}(${well})`; } return well; } /** * Takes a labware name and a list of wells and returns a list of wells. * If the list of wells is empty or undefined, an empty array is returned. * @param {string} [labwareName] - name of labware for wells that don't have specified labware. * @param {array} [wells] - list of wells, with or without labware explicitly specified. * @return {array} a list of wells on labware. */ function getLabwareWellList(labwareName, wells) { const wells1 = wells || []; assert(_.isArray(wells1)); const wells2 = (_.isString(labwareName) &amp;&amp; !_.isEmpty(labwareName)) ? _.map(wells1, w =&gt; (_.includes(w, &quot;(&quot;)) ? w : `${labwareName}(${w})`) : wells1; return wells2; } function pipette(params, parsed, data, options={}) { const llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); // console.log(&quot;pipette: &quot;+JSON.stringify(parsed, null, '\\t')) // let items = (_.isUndefined(parsed.value.items)) // ? [] // : _.flatten(parsed.value.items); //console.log(&quot;items: &quot;+JSON.stringify(items)); let agent = parsed.objectName.agent || &quot;?agent&quot;; let equipmentName = parsed.objectName.equipment || &quot;?equipment&quot;; //const tipModels = params.tipModels; //const syringes = params.syringes; // const sourcesTop = getLabwareWellList(parsed.objectName.sourceLabware, parsed.value.sources); // //console.log({sourcesTop}) // const destinationsTop = getLabwareWellList(parsed.objectName.destinationLabware, parsed.value.destinations); // const wellsTop = getLabwareWellList(parsed.objectName.wellsLabware, parsed.value.wells); // const volumesTop = parsed.value.volumes || []; // const syringesTop = (parsed.value.syringes || []).map((x, i) =&gt; { // const syringe = parsed.value.syringes[i]; // if (_.isNumber(syringe)) // return syringe; // else // return _.get(parsed.objectName, `syringes.${i}`, syringe); // }); //console.log({sourceLabware}) const items0 = (parsed.value.items) ? _.flatten(parsed.value.items) : undefined; let items = commandHelper.copyItemsWithDefaults(items0, { source: parsed.value.sources, destination: parsed.value.destinations, well: parsed.value.wells, volume: parsed.value.volumes, syringe: parsed.value.syringes, program: parsed.value.program, tipModel: parsed.value.tipModel, // TODO: Create a TipModel schema, and then set the tipModel properties in schemas to the &quot;TipModel&quot; type instead of &quot;string&quot; distance: parsed.value.distances, sourceMixing: parsed.value.sourceMixing, destinationMixing: parsed.value.destinationMixing }); // console.log(&quot;items: &quot;+JSON.stringify(items)) if (items.length == 0) { return {}; } // 1) Add labware to well properties // 2) Fixup mixing specs for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (item.source &amp;&amp; parsed.objectName.sourceLabware) { item.source = getLabwareWell(parsed.objectName.sourceLabware, item.source); } if (item.destination &amp;&amp; parsed.objectName.destinationLabware) { item.destination = getLabwareWell(parsed.objectName.destinationLabware, item.destination); } if (item.well &amp;&amp; parsed.objectName.wellLabware) { item.well = getLabwareWell(parsed.objectName.wellLabware, item.well); } if (item.hasOwnProperty(&quot;sourceMixing&quot;)) { item.sourceMixing = processMixingSpecs([item.sourceMixing]); } if (item.hasOwnProperty(&quot;destinationMixing&quot;)) { item.destinationMixing = processMixingSpecs([item.destinationMixing]); } } // Calculate volumes from calibrators for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (item.hasOwnProperty(&quot;volume&quot;)) { // Ignore other volume properties } else if (item.hasOwnProperty(&quot;volumeTotal&quot;)) { // Ignore other volume properties } else if (item.hasOwnProperty(&quot;volumeCalibrated&quot;)) { const spec = item.volumeCalibrated; const calibratorName = spec.calibrator; const targetValue = math.eval(spec.value); const calibratorVariable = _.get(parsed.orig, [&quot;calibrators&quot;, calibratorName, &quot;calibratorVariable&quot;]); assert(_.isString(calibratorVariable), &quot;expected calibratorVariable to be a string: &quot;+JSON.stringify(calibratorVariable)); const calibratorData0 = _.get(parsed.orig, [&quot;calibrators&quot;, calibratorName, &quot;calibratorData&quot;]); assert(_.isArray(calibratorData0), &quot;expected calibratorData to be an array&quot;); const calibratorData = _.sortBy(calibratorData0, calibratorVariable); const dataLE = _.last(_.filter(calibratorData, x =&gt; x[calibratorVariable] &lt;= targetValue)); const dataGE = _.first(_.filter(calibratorData, x =&gt; x[calibratorVariable] &gt;= targetValue)); const valueLE = math.eval(dataLE[calibratorVariable]); const valueGE = math.eval(dataGE[calibratorVariable]); const volumeLE = math.eval(dataLE.volume); const volumeGE = math.eval(dataGE.volume); if (math.equal(valueLE, targetValue)) { item.volume = volumeLE; } else if (math.equal(valueGE, targetValue)) { item.volume = volumeGE; } else { const d = math.subtract(valueGE, valueLE); const p = math.divide(math.subtract(targetValue, valueLE), d); // console.log({d, p}) // console.log(math.multiply(math.subtract(1, p), volumeLE)) // console.log(math.multiply(p, volumeGE)) item.volume = math.add(math.multiply(math.subtract(1, p), volumeLE), math.multiply(p, volumeGE)); } // console.log({spec, dataLE, dataGE, volume: item.volume}) } } // In order to handle 'volumeTotal', // perform an initial calculation of well volumes, but this will skip source // liquids, and therefore need to be performed again later after choosing source wells. calculateWellVolumes(items, data); for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (item.hasOwnProperty(&quot;volume&quot;)) { // Ignore other volume properties } else if (item.hasOwnProperty(&quot;volumeTotal&quot;)) { item.volume = math.subtract(item.volumeTotal, item.volumeBefore); // console.log({item}) } } // console.log(JSON.stringify(items, null, ' ')) // Find all wells, both sources and destinations const wellName_l = _(items).map(function (item) { //console.log({item}) // TODO: allow source to refer to a set of wells, not just a single well // TODO: create a function getSourceWells() return [item.source, item.destination, item.well] }).flattenDeep().compact().uniq().value(); // wellName_l = _.uniq(_.compact(_.flattenDeep([wellName_l, sourcesTop, destinationsTop]))); // console.log(&quot;wellName_l&quot;, JSON.stringify(wellName_l)) // Find all labware const labwareName_l = _(wellName_l).map(function (wellName) { //console.log({wellName}) const i = wellName.indexOf('('); return (i &gt;= 0) ? wellName.substr(0, i) : wellName; }).uniq().value(); const labware_l = _.map(labwareName_l, function (name) { return _.merge({name: name}, expect.objectsValue({}, name, data.objects)); }); // console.log({labwareName_l, labware_l}) // Check whether labwares are on sites that can be pipetted const query2_l = []; _.forEach(labware_l, function(labware) { if (!labware.location) { return {errors: [labware.name+&quot;.location must be set&quot;]}; } const query = { &quot;pipetter.canAgentEquipmentSite&quot;: { &quot;agent&quot;: agent, &quot;equipment&quot;: equipmentName, &quot;site&quot;: labware.location } }; const queryResults = llpl.query(query); // console.log(&quot;queryResults: &quot;+JSON.stringify(queryResults, null, '\\t')); if (_.isEmpty(queryResults)) { throw {name: &quot;ProcessingError&quot;, errors: [labware.name+&quot; is at site &quot;+labware.location+&quot;, which hasn't been configured for pipetting; please move it to a pipetting site.&quot;]}; } query2_l.push(query); }); // console.log({query2_l}) // Check whether the same agent and equipment can be used for all the pipetting steps if (!_.isEmpty(query2_l)) { const query2 = {&quot;and&quot;: query2_l}; //console.log(&quot;query2: &quot;+JSON.stringify(query2, null, '\\t')); const queryResults2 = llpl.query(query2); //console.log(&quot;query2: &quot;+JSON.stringify(query2, null, '\\t')); //console.log(&quot;queryResults2: &quot;+JSON.stringify(queryResults2, null, '\\t')); if (_.isEmpty(queryResults2)) { return {errors: [&quot;unable to find an agent/equipment combination that can pipette at all required locations: &quot;+_.map(labware_l, function(l) { return l.location; }).join(', ')]} } // Arbitrarily pick first listed agent/equipment combination else { const x = queryResults2[0][&quot;and&quot;][0][&quot;pipetter.canAgentEquipmentSite&quot;]; agent = x.agent; equipmentName = x.equipment; } } // Load equipment object const equipment = _.get(data.objects, equipmentName); assert(equipment, &quot;could not find equipment: &quot;+equipmentName); const sourceToItems = _.groupBy(items, 'source'); // Only keep items that have a positive volume (will need to adapt this for pipetter.punctureSeal) if (options.keepVolumelessItems !== true) { items = _.filter(items, item =&gt; item.volume &amp;&amp; item.volume.toNumber('l') &gt; 0); // console.log({items}) } if (items.length === 0) { return {expansion: []}; } // Any items which have a syringe assigned, if they have a permanent tip model, then set item's tipModel for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (!_.isUndefined(item.syringe)) { const syringeName = pipetterUtils.getSyringeName(item.syringe, equipmentName, data); const syringe = _.get(data.objects, syringeName); if (syringe &amp;&amp; syringe.tipModelPermanent) item.tipModel = syringe.tipModelPermanent; } } // console.log(&quot;A: &quot;+JSON.stringify(_.first(items))) // Make sure all items have a 'tipModel' property { // Try to find tipModel, first for all items // Restrict settings to items without tipModel properties const items2 = items.filter(x =&gt; _.isUndefined(x.tipModel)); // console.log({items2}) if (items2.length &gt; 0 &amp;&amp; !setTipModel(items2, equipment, equipmentName)) { // TODO: Try to find tipModel for each layer // Try to find tipModel for each source _.forEach(sourceToItems, function(items) { const items2 = items.filter(x =&gt; _.isUndefined(x.tipModel)); if (items2.length &gt; 0 &amp;&amp; !setTipModel(items2, equipment, equipmentName)) { // Try to find tipModel for each item for this source _.forEach(items2, function(item) { if (!setTipModel([item], equipment, equipmentName)) { throw {name: &quot;ProcessingError&quot;, message: &quot;no tip model available for item: &quot;+JSON.stringify(item)}; } }); } }); } } // console.log(&quot;B: &quot;+JSON.stringify(_.first(items))) // Make sure all items have a 'program' property { // Try to find program, first for all items const items2 = items.filter(x =&gt; _.isUndefined(x.program)); if (items2.length &gt; 0 &amp;&amp; !assignProgram(items2, data)) { // Try to find program for each source _.forEach(sourceToItems, function(items) { const items2 = items.filter(x =&gt; _.isUndefined(x.program)); if (items2.length &gt; 0 &amp;&amp; !assignProgram(items, data)) { // Try to find program for each item for this source _.forEach(items2, function(item) { if (!assignProgram([item], data)) { throw {name: &quot;ProcessingError&quot;, message: &quot;could not automatically choose a program for item: &quot;+JSON.stringify(item)}; } }); } }); } } // console.log(&quot;C: &quot;+JSON.stringify(_.first(items))) // TODO: Limit syringe choices based on params const syringesAvailable = _.map(_.keys(equipment.syringe), s =&gt; `${equipmentName}.syringe.${s}`) || []; const tipModelToSyringes = equipment.tipModelToSyringes; // Group the items const groups = groupingMethods.groupingMethod3(items, syringesAvailable, tipModelToSyringes); // console.log(&quot;groups:\\n&quot;+JSON.stringify(groups, null, '\\t')); // Pick syringe for each item // For each group assign syringes, starting with the first available one _.forEach(groups, function(group) { const tipModelToSyringesAvailable = _.cloneDeep(tipModelToSyringes); _.forEach(group, function(item) { const tipModel = item.tipModel; assert(tipModelToSyringesAvailable[tipModel].length &gt;= 1); if (_.isUndefined(item.syringe)) { item.syringe = tipModelToSyringesAvailable[tipModel].splice(0, 1)[0]; } // TODO: do we need to remove item.syringe from tipModelToSyringesAvailable, it item.syringe was already provided? -- ellis, 2016-03-30 }); }); // Pick source well for items, if the source has multiple wells // Rotate through source wells in order of max volume for (const group of groups) { sourceMethods.sourceMethod3(group, data, effects); } // Add properties `volumeBefore` and `volumeAfter` to the items. calculateWellVolumes(items, data); // Calculate when tips need to be washed // Create pipetting commands const syringeToSource = {}; // How clean is the syringe/tip currently? const syringeToCleanValue = _.fromPairs(_.map(syringesAvailable, s =&gt; [s, 5])); const expansionList = []; /* cleanBegin: intensity of first cleaning at beginning of pipetting, before first aspiration. Priority: item.cleanBefore || params.cleanBegin || params.clean || source.cleanBefore || &quot;thorough&quot; cleanBetween: intensity of cleaning between groups. Priority: max(previousCleanAfter, (item.cleanBefore || params.cleanBetween || params.clean || source.cleanBefore || &quot;thorough&quot;)) previousCleanAfter = item.cleanAfter || if (!params.cleanBetween) source.cleanAfter cleanEnd: intensity of cleaning after pipetting is done. Priority: max(previousCleanAfter, params.cleanEnd || params.clean || &quot;thorough&quot;) */ // Find the cleaning intensity required before the first aspiration const syringeToCleanBeginValue = {}; _.forEach(groups, function(group) { _.forEach(group, function(item) { const syringe = item.syringe; if (!syringeToCleanBeginValue.hasOwnProperty(syringe)) { // TODO: handle source's cleanBefore const intensity = item.cleanBefore || parsed.value.cleanBegin || parsed.value.clean || &quot;thorough&quot;; const intensityValue = intensityToValue[intensity]; syringeToCleanBeginValue[syringe] = intensityValue; } }); }); // Add cleanBegin commands expansionList.push.apply(expansionList, createCleanActions(syringeToCleanBeginValue, agent, equipmentName, data, true)); //console.log(&quot;expansionList:&quot;) //console.log(JSON.stringify(expansionList, null, ' ')); // console.log(&quot;D: &quot;+JSON.stringify(_.first(groups))) const syringeToCleanAfterValue = {}; let doCleanBefore = false _.forEach(groups, function(group) { assert(group.length &gt; 0); // What cleaning intensity is required for the tip before aspirating? const syringeToCleanBeforeValue = _.clone(syringeToCleanAfterValue); //console.log({syringeToCleanBeforeValue, syringeToCleanAfterValue}) _.forEach(group, function(item) { const source = item.source || item.well; const syringe = item.syringe; const isSameSource = (source === syringeToSource[syringe]); // Find required clean intensity // Priority: max(previousCleanAfter, (item.cleanBefore || params.cleanBetween || params.clean || source.cleanBefore || &quot;thorough&quot;)) // FIXME: ignore isSameSource if tip has been contaminated by 'Wet' pipetting position // FIXME: also take the source's and destination's &quot;cleanBefore&quot; into account const intensity = (!isSameSource) ? item.cleanBefore || parsed.value.cleanBetween || parsed.value.clean || &quot;thorough&quot; : item.cleanBefore || parsed.value.cleanBetweenSameSource || parsed.value.cleanBetween || parsed.value.clean || &quot;thorough&quot;; expect.truthy({}, intensityToValue.hasOwnProperty(intensity), `unrecognized intensity value: ${intensity}`); let intensityValue = intensityToValue[intensity]; if (syringeToCleanAfterValue.hasOwnProperty(syringe)) intensityValue = Math.max(syringeToCleanAfterValue[syringe], intensityValue); //console.log({source, syringe, isSameSource, intensityValue}) // Update cleaning value required before current aspirate if (!syringeToCleanBeforeValue.hasOwnProperty(syringe) || intensityValue &gt; syringeToCleanBeforeValue[syringe]) { syringeToCleanBeforeValue[syringe] = intensityValue; } // Set the aspirated source and indicate that the tip is no longer clean syringeToSource[syringe] = source; syringeToCleanValue[syringe] = 0; // FIXME: also consider the source's cleanAfter if (item.hasOwnProperty('cleanAfter')) syringeToCleanAfterValue[syringe] = item.cleanAfter; else delete syringeToCleanAfterValue[syringe]; //console.log({syringeToCleanAfterValue, syringe}) // TODO: if wet contact, indicate tip contamination }); // Add cleanBefore commands for this group (but not for the first group, because of the cleanBegin section above) if (doCleanBefore) { expansionList.push.apply(expansionList, createCleanActions(syringeToCleanBeforeValue, agent, equipmentName, data)); } doCleanBefore = true; // console.log(&quot;E: &quot;+JSON.stringify(_.first(group))) // _PipetteItems const items2 = _.map(group, function(item) { const item2 = _.pick(item, [&quot;syringe&quot;, &quot;source&quot;, &quot;destination&quot;, &quot;well&quot;, &quot;volume&quot;, &quot;count&quot;, &quot;distance&quot;]); if (!_.isUndefined(item2.volume)) { item2.volume = item2.volume.format({precision: 14}); } if (!_.isUndefined(item2.distance)) { item2.distance = item2.distance.format({precision: 14}); } // Mix the source well if (item.sourceVolumeBefore &amp;&amp; item.sourceMixing) { const mixing = item.sourceMixing; const volume0 = item.sourceVolumeBefore; const volume = calculateMixingVolume(volume0, mixing.amount); const mixing2 = { count: mixing.count, volume: volume.format({precision: 14}) }; item2.sourceMixing = mixing2; } // Mix the destination well if (item.volumeAfter &amp;&amp; item.destinationMixing) { const mixing = item.destinationMixing; const volume0 = item.volumeAfter; // console.log({mixing, volume0: (volume0) ? volume0 : item}) const volume = calculateMixingVolume(volume0, mixing.amount); const mixing2 = { count: mixing.count, volume: volume.format({precision: 14}) }; item2.destinationMixing = mixing2; } return item2; }); // console.log(&quot;Z: &quot;+JSON.stringify(_.first(items2))) // _pipette instruction expansionList.push(_.merge({}, { &quot;command&quot;: &quot;pipetter._pipette&quot;, &quot;agent&quot;: agent, &quot;equipment&quot;: equipmentName, &quot;program&quot;: group[0].program, &quot;sourceProgram&quot;: parsed.value.sourceProgram, &quot;items&quot;: items2, })); }); // cleanEnd // Priority: max(previousCleanAfter, params.cleanEnd || params.clean || &quot;thorough&quot;) const syringeToCleanEndValue = {}; // console.log({syringeToCleanValue}) _.forEach(syringeToCleanValue, function (value, syringe) { const intensity = parsed.value.cleanEnd || parsed.value.clean || &quot;thorough&quot;; assert(intensityToValue.hasOwnProperty(intensity), &quot;unknown clean intensity: &quot;+intensity); let intensityValue = intensityToValue[intensity]; if (syringeToCleanAfterValue.hasOwnProperty(syringe)) intensityValue = Math.max(syringeToCleanAfterValue[syringe], intensityValue); if (value &lt; intensityValue) syringeToCleanEndValue[syringe] = intensityValue; }); //console.log({syringeToCleanEndValue}) expansionList.push.apply(expansionList, createCleanActions(syringeToCleanEndValue, agent, equipmentName, data)); // Create the effets object // TODO: set final tip clean values const effects = {}; return { expansion: expansionList, effects: effects }; } // const NOMIXING = {count: 0, amount: 0}; const MIXINGDEFAULT = {count: 3, amount: 0.7}; function processMixingSpecs(l) { const mixing = _.reduce( l, (acc, mixing) =&gt; { if (_.isUndefined(mixing) || mixing === false) return undefined; else if (mixing === true) return {}; else if (_.isPlainObject(mixing)) return _.merge(acc || {}, mixing); return undefined; }, undefined ); _.defaults(mixing, MIXINGDEFAULT); return mixing; } // Try to find a tipModel for the given items function findTipModel(items, equipment, equipmentName) { /*if (_.size(equipment.tipModel) === 1) { const tipModelName = _.keys(equipment.tipModel)[0]; return `${equipmentName}.tipModel.${tipModelName}`; } else {*/ const tipModelName = _.findKey(equipment.tipModel, (tipModel) =&gt; { return _.every(items, item =&gt; { const volume = item.volume; // Only if the item has a volume, then we'll need a tipModel if (!_.isUndefined(volume) &amp;&amp; math.compare(volume, math.unit(0, &quot;ul&quot;)) &gt; 0) { assert(math.unit('l').equalBase(volume), &quot;expected units to be in liters&quot;); if (math.compare(volume, math.eval(tipModel.min)) &lt; 0 || math.compare(volume, math.eval(tipModel.max)) &gt; 0) { return false; } // TODO: check whether the labware is sealed // TODO: check whether the well has cells } return true; }); }); return (!_.isEmpty(tipModelName)) ? `${equipmentName}.tipModel.${tipModelName}` : undefined; // } } function setTipModel(items, equipment, equipmentName) { assert(!_.isEmpty(items)); // FIXME: allow for overriding tipModel via top pipetter params const tipModelName = findTipModel(items, equipment, equipmentName); // console.log({tipModelName, items}) if (tipModelName) { _.forEach(items, function(item) { if (!item.tipModel) item.tipModel = tipModelName; }); return true; } else { return false; } } // Calculate volume for each well or destination, // adding properties `volumeBefore` and `volumeAfter` to the items. function calculateWellVolumes(items, data) { const wellVolumes = {}; for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (_.isString(item.source)) { const well = item.source; const volume0 = (wellVolumes.hasOwnProperty(well)) ? wellVolumes[well] : WellContents.getWellVolume(well, data) const volume1 = math.subtract(volume0, item.volume); item.sourceVolumeBefore = volume0; item.sourceVolumeAfter = volume1; wellVolumes[well] = volume1; } const well = item.well || item.destination; if (well) { const volume0 = (wellVolumes.hasOwnProperty(well)) ? wellVolumes[well] : WellContents.getWellVolume(well, data) const volume1 = (item.destination &amp;&amp; item.volume) ? math.add(volume0, item.volume) : volume0; item.volumeBefore = volume0; item.volumeAfter = volume1; wellVolumes[well] = volume1; // console.log({well, volume: wellVolumes[well]}) } } } function extractLiquidNamesFromContents(contents) { if (_.isEmpty(contents) || contents.length &lt; 2) return []; if (contents.length === 2 &amp;&amp; _.isString(contents[1])) return [contents[1]]; else { return _(contents).tail().map(function(contents2) { return extractLiquidNamesFromContents(contents2); }).flatten().value(); } } // Try to find a pipettingClass for the given items function findPipettingClass(items, data) { // Pick liquid properties by inspecting source contents const pipettingClasses0 = items.map(item =&gt; { let pipettingClass = &quot;Water&quot;; const source0 = item.source || item.well || item.destination; // If no source is provided, then use well or destination const source = commandHelper.asArray(source0); // FIXME: for debug only if (!source || _.isEmpty(source)) { console.log({item}); } // ENDFIX //console.log({source}) if (source.length &gt; 0) { //console.log({source}) const contents = WellContents.getWellContents(source[0], data); if (contents) { const liquids = extractLiquidNamesFromContents(contents); const pipettingClasses = _(liquids).map(function(name) { return misc.findObjectsValue(name+&quot;.pipettingClass&quot;, data.objects, null, &quot;Water&quot;); }).uniq().value(); // FIXME: should pick &quot;Water&quot; if water-like liquids have high enough concentration // Use &quot;Water&quot; if present if (!_.includes(pipettingClasses, &quot;Water&quot;)) { if (pipettingClasses.length === 1) { pipettingClass = pipettingClasses[0]; } else if (pipettingClasses.length &gt; 1) { pipettingClass = null; } } } } return pipettingClass; }); const pipettingClasses = _.uniq(pipettingClasses0); if (pipettingClasses.length === 1) { return pipettingClasses[0]; } else { return null; } } // Pick position (wet or dry) by whether there are already contents in the destination well function findPipettingPosition(items, data) { const pipettingPositions = _(items).map(item =&gt; item.destination || item.well).compact().map(function(well) { const i = well.indexOf('('); const labware = well.substr(0, i); const wellId = well.substr(i + 1, 3); // FIXME: parse this instead, allow for A1 as well as A01 const contents = misc.findObjectsValue(labware+&quot;.contents.&quot;+wellId, data.objects); const liquids = extractLiquidNamesFromContents(contents); return _.isEmpty(liquids) ? &quot;Dry&quot; : &quot;Wet&quot;; }).uniq().value(); if (pipettingPositions.length === 1) { return pipettingPositions[0]; } else { return null; } } function assignProgram(items0, data) { // console.log(&quot;assignProgram: &quot;+JSON.stringify(items)) // items0.forEach(x =&gt; console.log(JSON.stringify(x))) // console.log({items0}) const items = items0.filter(item =&gt; item.volume &amp;&amp; math.larger(item.volume, math.unit(0, &quot;l&quot;))); if (items.length &gt; 0) { // console.log({items}) const pipettingClass = findPipettingClass(items, data); if (!pipettingClass) return false; const pipettingPosition = findPipettingPosition(items, data); if (!pipettingPosition) return false; const tipModels = _(items).map('tipModel').compact().uniq().value(); if (tipModels.length !== 1) return false; const tipModelName = tipModels[0]; assert(tipModelName, `missing value for tipModelName: `+JSON.stringify(tipModels)); const tipModelCode = misc.getObjectsValue(tipModelName+&quot;.programCode&quot;, data.objects); //console.log({equipment}) assert(tipModelCode, `missing value for ${tipModelName}.programCode`); const program = &quot;\\&quot;Roboliq_&quot;+pipettingClass+&quot;_&quot;+pipettingPosition+&quot;_&quot;+tipModelCode+&quot;\\&quot;&quot;; _.forEach(items0, function(item) { item.program = program; }); } return true; } // Create clean commands before pipetting this group function createCleanActions(syringeToCleanValue, agent, equipmentName, data, compareToOriginalState = false) { // console.log(&quot;createCleanActions: &quot;+JSON.stringify(syringeToCleanValue)) const items = _(syringeToCleanValue).toPairs().map(([syringeName0, n]) =&gt; { if (n &gt; 0) { const syringeName = pipetterUtils.getSyringeName(syringeName0, equipmentName, data); const syringe = commandHelper._g(data, syringeName); if (compareToOriginalState) { const intensity = syringe.cleaned; const syringeCleanedValue = intensityToValue[syringe.cleaned] || 0; // console.log({syringeName0, n, syringeName, intensity, syringeCleanedValue, syringe}) if (n &gt; syringeCleanedValue) return {syringe: syringeName, intensity: valueToIntensity[n]}; } else { return {syringe: syringeName, intensity: valueToIntensity[n]}; } } }).compact().value(); // console.log({cleanItems: items}) if (_.isEmpty(items)) return []; return [{ command: &quot;pipetter.cleanTips&quot;, agent: agent, equipment: equipmentName, items }]; } /* // Mix destination after dispensing? function addMixing(parsed, agent, equipmentName, group, mixPropertyName, wellPropertyName, volumePropertyName) { let mixItems = []; _.forEach(group, function(item) { const well = item[wellPropertyName]; const doMixing = !_.isUndefined(well) &amp;&amp; _.get(item, mixPropertyName, _.get(parsed.value, mixPropertyName, false)); if (doMixing) { const mixing = _.defaults({count: 3, amount: 0.7}, item[mixPropertyName], parsed.value[mixPropertyName]); const volume0 = item[volumePropertyName]; const volume = calculateMixingVolume(volume0, mixing.amount); const mixItem = _.merge({}, { syringe: item.syringe, well, count: mixing.count, volume: volume.format({precision: 14}) }); mixItems.push(mixItem); } }); if (mixItems.length &gt; 0) { const mixCommand = { command: &quot;pipetter._mix&quot;, agent, equipment: equipmentName, program: group[0].program, // FIXME: even if we used Air dispense for the dispense, we need to use Wet or Bot here items: mixItems }; return mixCommand; } return undefined; } */ function calculateMixingVolume(volume0, amount) { amount = _.isString(amount) ? math.eval(amount) : amount; // console.log(&quot;amount: &quot;+JSON.stringify(amount)) // console.log(&quot;type: &quot;+math.typeof(amount)) switch (math.typeof(amount)) { case &quot;number&quot;: case &quot;BigNumber&quot;: case &quot;Fraction&quot;: // assert(amount &gt;= 0 &amp;&amp; amount &lt; 1, &quot;amount must be between 0 and 1: &quot;+JSON.stringify(item)); return math.multiply(volume0, amount); case &quot;Unit&quot;: return amount; } assert(false, &quot;expected amount to be a volume or a number: &quot;+JSON.amount); } /** * Handlers for {@link pipetter} commands. * @static */ const commandHandlers = { &quot;pipetter._aspirate&quot;: function(params, parsed, data) { // console.log(&quot;params&quot;, JSON.stringify(params, null, ' ')) const effects = pipetterUtils.getEffects_pipette(parsed, data); // console.log(&quot;effects:&quot;, JSON.stringify(effects, null, ' ')) return {effects}; }, &quot;pipetter._dispense&quot;: function(params, parsed, data) { //console.log(&quot;params&quot;, JSON.stringify(params, null, ' ')) const effects = pipetterUtils.getEffects_pipette(parsed, data); //console.log(&quot;effects:&quot;, JSON.stringify(effects, null, ' ')) return {effects}; }, &quot;pipetter._measureVolume&quot;: function(params, parsed, data) { // console.log(&quot;pipetter._punctureSeal: &quot;+JSON.stringify(parsed, null, '\\t')) const effects = pipetterUtils.getEffects_pipette(parsed, data); const result = { effects, reports: (_.isEmpty(data.objects.DATA)) ? undefined : { measurementFactors: data.objects.DATA } }; if (_.has(parsed.value, [&quot;output&quot;, &quot;simulated&quot;])) { const wells = parsed.value.items.map(item =&gt; item.well); simulatedHelpers.simulatedByWells(parsed, data, wells, result); } return result; }, &quot;pipetter._mix&quot;: function(params, parsed, data) { // console.log(&quot;pipetter._mix: &quot;+JSON.stringify(parsed, null, '\\t')) parsed.value.items = commandHelper.copyItemsWithDefaults(parsed.value.items, parsed.value.itemDefaults); //console.log(&quot;params&quot;, JSON.stringify(params, null, ' ')) //console.log(&quot;effects:&quot;, JSON.stringify(pipetterUtils.getEffects_pipette(params, data), null, ' ')) return { effects: pipetterUtils.getEffects_pipette(parsed, data) }; }, &quot;pipetter._pipette&quot;: function(params, parsed, data) { // console.log(&quot;params&quot;, JSON.stringify(params, null, ' ')) const effects = pipetterUtils.getEffects_pipette(parsed, data); // console.log(&quot;effects:&quot;, JSON.stringify(effects, null, ' ')) return {effects}; }, &quot;pipetter._punctureSeal&quot;: function(params, parsed, data) { // console.log(&quot;pipetter._punctureSeal: &quot;+JSON.stringify(parsed, null, '\\t')) const effects = pipetterUtils.getEffects_pipette(parsed, data); // Add effects for seal punctures _.forEach(parsed.value.items, item =&gt; { const wellInfo = wellsParser.parseOne(item.well); const labwareName = wellInfo.source || wellInfo.labware; const id = `${labwareName}.sealPunctures.${wellInfo.wellId}`; if (_.get(data.objects, id) !== true) { effects[id] = true; } }); return { effects }; }, &quot;pipetter._washTips&quot;: function(params, parsed, data) { //console.log(&quot;_washTips:&quot;); //console.log(JSON.stringify(parsed, null, '\\t')) const effects = {}; parsed.value.syringes.forEach((syringe, index) =&gt; { const syringeName = parsed.objectName[`syringes.${index}`]; if (!_.isUndefined(syringe.contaminants)) effects[`${syringeName}.contaminants`] = null; // Remove contents property if (!_.isUndefined(syringe.contents)) effects[`${syringeName}.contents`] = null; // Set cleaned property if (syringe.cleaned !== parsed.value.intensity) effects[`${syringeName}.cleaned`] = parsed.value.intensity; }); return {effects}; }, &quot;pipetter.cleanTips&quot;: function(params, parsed, data) { // console.log(&quot;pipetter.cleanTips:&quot;) // console.log(JSON.stringify(parsed, null, '\\t')); const syringes0 = (params.syringes) ? commandHelper.asArray(params.syringes) : (!params.items &amp;&amp; parsed.value.equipment &amp;&amp; parsed.value.equipment.syringe) ? _.keys(parsed.value.equipment.syringe).map(s =&gt; parsed.objectName.equipment + &quot;.syringe.&quot; + s) : []; const n = _.max([syringes0.length, commandHelper.asArray(params.items).length]) const itemsToMerge = [ syringes0.map(syringe =&gt; { return {syringe} }), (params.intensity) ? _.times(n, () =&gt; ({intensity: params.intensity})) : [] ]; const items = _.merge([], itemsToMerge[0], itemsToMerge[1], params.items); //console.log(&quot;items: &quot;+JSON.stringify(params.items)) //console.log(JSON.stringify(itemsToMerge, null, '\\t')); //console.log(&quot;items: &quot;+JSON.stringify(items)) // Ensure fully qualified names for the syringes _.forEach(items, item =&gt; { if (_.isInteger(item.syringe)) { item.syringe = `${parsed.objectName.equipment}.syringe.${item.syringe}`; } }); // Get list of valid agent/equipment/syringe combinations for all syringes const nodes = _.flatten(items.map(item =&gt; { const predicates = [ {&quot;pipetter.canAgentEquipmentSyringe&quot;: { &quot;agent&quot;: parsed.objectName.agent, &quot;equipment&quot;: parsed.objectName.equipment, syringe: item.syringe }} ]; //console.log(predicates) const [, alternatives] = commandHelper.queryLogic(data, predicates, &quot;pipetter.canAgentEquipmentSyringe&quot;); expect.truthy({paramName: &quot;items&quot;}, !_.isEmpty(alternatives), `could not find agent and equipment to clean syring ${item.syringe}`); return alternatives; })); //console.log(nodes); // Group by agent+equipment const equipToNodes = _.groupBy(nodes, x =&gt; `${x.agent}|${x.equipment}`); //console.log(equipToNodes); // Group by syringe const syringeToNodes = _.groupBy(nodes, x =&gt; x.syringe); // console.log({syringeToNodes}); // Desired intensity for each syringe const syringeToItem = _.groupBy(items, item =&gt; item.syringe); // Sub-command list let expansion = []; // Get list of syringes let syringesRemaining = _.uniq(items.map(item =&gt; item.syringe)); //console.log({nodes, syringeToNodes, syringeToItem}) // Generate sub-commands until all syringes have been taken care of while (!_.isEmpty(syringesRemaining)) { const syringe = syringesRemaining[0]; const nodes = syringeToNodes[syringe]; // console.log({syringe, nodes}) // Arbitrarily pick the first possible agent/equipment combination const {agent, equipment} = nodes[0]; const equipNodes = equipToNodes[`${agent}|${equipment}`]; const syringes = _.intersection(syringesRemaining, equipNodes.map(x =&gt; x.syringe)); // Create cleanTips items const items = _.flatten(syringes.map(syringe =&gt; syringeToItem[syringe])); //console.log({syringes, syringeToItem, items}) // Add the sub-command expansion.push({ command: `pipetter.cleanTips|${agent}|${equipment}`, agent, equipment, items }); // Remove those syringes from the remaining list syringesRemaining = _.difference(syringesRemaining, syringes); } //console.log(expansion); return {expansion}; }, &quot;pipetter.measureVolume&quot;: function(params, parsed, data) { // console.log(&quot;pipetter.measureVolume: &quot;+JSON.stringify(parsed)) const items = commandHelper.copyItemsWithDefaults(parsed.value.items, { well: parsed.value.wells, }); // console.log(&quot;items: &quot;+JSON.stringify(items)) // Add labware to well properties for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (item.well &amp;&amp; parsed.objectName.wellLabware) { item.well = getLabwareWell(parsed.objectName.wellLabware, item.well); } } const parsed2 = _.cloneDeep(parsed); // _.merge(parsed2.value, defaults3); parsed2.value.items = items; const result = pipette(params, parsed2, data, {keepVolumelessItems: true}); _.forEach(result.expansion, step =&gt; { if (step.command === &quot;pipetter._pipette&quot;) { step.command = &quot;pipetter._measureVolume&quot;; if (parsed.orig.output) step.output = _.clone(parsed.orig.output); } }); return result; }, &quot;pipetter.mix&quot;: function(params, parsed, data) { // console.log(&quot;pipetter.mix: &quot;+JSON.stringify(parsed, null, '\\t')) const items = commandHelper.copyItemsWithDefaults(parsed.value.items, { well: parsed.value.wells, count: parsed.value.counts, amount: parsed.value.amounts }); // console.log(&quot;items: &quot;+JSON.stringify(items)) // Add labware to well properties for (let i = 0; i &lt; items.length; i++) { const item = items[i]; if (item.well &amp;&amp; parsed.objectName.wellLabware) { item.well = getLabwareWell(parsed.objectName.wellLabware, item.well); } } const items2 = _.map(items, (item, i) =&gt; { assert(item.well, `missing well for mix item ${i}: ${JSON.stringify(item)}`); const volume0 = WellContents.getWellVolume(item.well, data); assert(math.compare(volume0, math.unit(0, 'l')) &gt; 0, &quot;cannot mix empty wells&quot;); const item2 = _.omit(item, [&quot;amount&quot;]); item2.volume = calculateMixingVolume(volume0, item.amount); return item2; }); const parsed2 = _.cloneDeep(parsed); // _.merge(parsed2.value, defaults3); parsed2.value.items = items2; const result = pipette(params, parsed2, data); _.forEach(result.expansion, step =&gt; { if (step.command === &quot;pipetter._pipette&quot;) { step.command = &quot;pipetter._mix&quot;; const {items: items3, defaults: defaults3} = commandHelper.splitItemsAndDefaults(step.items, [&quot;syringe&quot;, &quot;well&quot;]); // console.log({items3, defaults3}); if (!_.isEmpty(defaults3)) step.itemDefaults = defaults3; step.items = items3; } }); return result; }, &quot;pipetter.pipette&quot;: pipette, &quot;pipetter.pipetteDilutionSeries&quot;: function(params, parsed, data) { // console.log(&quot;pipetter.pipetteDilutionSeries: &quot;+JSON.stringify(parsed, null, '\\t')) const destinationLabware = parsed.objectName.destinationLabware; const dilutionMethod = parsed.value.dilutionMethod; // Fill all destination wells with diluent const diluentItems = []; const items = []; _.forEach(parsed.value.items, (item, itemIndex) =&gt; { if (_.isEmpty(item.destinations)) return; // FIXME: handle `source` assert(_.isUndefined(item.source), &quot;`source` property not implemented yet&quot;); const destinations1 = item.destinations.map(s =&gt; getLabwareWell(destinationLabware, s)); const destination0 = destinations1[0]; const destinations2 = _.tail(destinations1); const syringeName = parsed.objectName[`items.${itemIndex}.syringe`] || item.syringe; // console.log({destination0, destinations2, syringeName}) let dilutionFactorPrev = 1; // get volume of destination0 const volume0 = WellContents.getWellVolume(destination0, data); assert(math.compare(volume0, math.unit(0, 'l')) &gt; 0, &quot;first well in dilution series shouldn't be empty&quot;); // The target volume of the dilution wells (or take the volume of the first 'destination') const volumeFinal = parsed.value.volume || volume0; // Dilute the destination0, if necessary if (math.smaller(volume0, volumeFinal)) { assert(parsed.objectName.diluent, &quot;missing 'diluent'&quot;); const diluentVolume2 = math.subtract(volumeFinal, volume0); const item2 = { source: parsed.objectName.diluent, destination: getLabwareWell(destinationLabware, destination0), volume: diluentVolume2.format({precision: 4}), syringe: syringeName, }; diluentItems.push(item2); } // Calculate volume to transfer from one well to the next, and the diluent volume const sourceVolume = (dilutionMethod === &quot;source&quot;) ? volumeFinal : math.divide(volumeFinal, parsed.value.dilutionFactor); const diluentVolume = (dilutionMethod === &quot;source&quot;) ? volumeFinal : math.subtract(volumeFinal, sourceVolume); // console.log({volume0: volume0.format(), sourceVolume: sourceVolume.format(), diluentVolume: diluentVolume.format()}) // If we want to pre-dispense the diluent: if (dilutionMethod === &quot;begin&quot;) { // Distribute diluent to all destination wells // If 'lastWellHandling == none', don't dilute the last well const destinations3 = (parsed.value.lastWellHandling !== &quot;none&quot;) ? destinations2 : _.initial(destinations2); _.forEach(destinations3, (destinationWell, index) =&gt; { const wellContents = WellContents.getWellContents(destinationWell, data); const wellVolume = WellContents.getVolume(wellContents); if (math.smaller(wellVolume, diluentVolume)) { assert(parsed.objectName.diluent, &quot;missing 'diluent'&quot;); const diluentVolume2 = math.subtract(diluentVolume, wellVolume); const item2 = { layer: index+1, source: parsed.objectName.diluent, destination: getLabwareWell(destinationLabware, destinationWell), volume: diluentVolume2.format({precision: 4}), syringe: syringeName, }; diluentItems.push(item2); } }); } // console.log({diluentItems}) // Pipette the dilutions let source = destination0; _.forEach(destinations2, (destinationWell, index) =&gt; { const destination = getLabwareWell(destinationLabware, destinationWell); // Dilute the source first? if (dilutionMethod === &quot;source&quot;) { const layer = (index + 1) * 2 - 1; const volume = math.subtract(math.multiply(volumeFinal, parsed.value.dilutionFactor), volumeFinal); const item2 = { layer, source: parsed.objectName.diluent, destination: source, volume: volume.format({precision: 4}), syringe: syringeName, sourceMixing: false, destinationMixing: false }; items.push(item2); } // Transfer to destination { const layer = (dilutionMethod !== &quot;begin&quot;) ? (index + 1) * 2 : index + 1; // console.log({dilutionMethod, index, layer}) const item2 = { layer, source, destination, volume: sourceVolume.format({precision: 4}), syringe: syringeName }; // Mix before aspirating from first dilution well if (index === 0 || dilutionMethod === &quot;source&quot;) { item2.sourceMixing = _.get(parsed.value, &quot;sourceMixing&quot;, true); } items.push(item2); } source = destination; }); // May need to extract aliquot from the final destination well in order to // get it to the proper volume if (dilutionMethod !== &quot;source&quot;) { // If disposal wells are specified, transfer extra volume from last well to the disposal // FIXME: implement sending last aspirate to TRASH! // Create final aspiration items.push({ layer: (dilutionMethod === &quot;begin&quot;) ? destinations2.length + 1 : (destinations2.length + 1) * 2 - 1, source: getLabwareWell(destinationLabware, _.last(destinations2)), volume: sourceVolume.format({precision: 4}), syringe: syringeName }); } /*const source = (firstItemIsSource) ? dilution0.destination : dilution0.source; _.forEach(series, dilution =&gt; { // If the first item doesn't define a source, but it's dilutionFactor = 1, then treat the destination well as the source. assert(!_.isUndefined(source), &quot;dilution item requires a source&quot;); diluentItems.push({source: parsed.objectName.diluent, destination}) }); */ }); //const items = []; const expansion = []; if (diluentItems.length &gt; 0) { // Cleaning: // if 'items' is empty, const params1 = _.pick(parsed.orig, [&quot;destinationLabware&quot;, &quot;sourceLabware&quot;, &quot;syringes&quot;]); params1.command = &quot;pipetter.pipette&quot;; params1.items = diluentItems; if (parsed.value.cleanBegin) params1.cleanBegin = parsed.value.cleanBegin; params1.cleanBetweenSameSource = &quot;none&quot;; if (items.length &gt; 0) params1.cleanEnd = &quot;none&quot;; else if (parsed.value.cleanEnd) params1.cleanEnd = parsed.value.cleanEnd; _.merge(params1, parsed.orig.diluentParams); expansion.push(params1); } if (items.length &gt; 0) { const params2 = _.pick(parsed.orig, [&quot;destinationLabware&quot;, &quot;sourceLabware&quot;, &quot;syringes&quot;]); params2.command = &quot;pipetter.pipette&quot;; params2.items = items; if (diluentItems.length &gt; 0) params2.cleanBegin = &quot;none&quot;; else if (parsed.value.cleanBegin) params2.cleanBegin = parsed.value.cleanBegin; params2.cleanBetweenSameSource = &quot;none&quot;; if (parsed.value.cleanEnd) params2.cleanEnd = parsed.value.cleanEnd; const destinationMixing = (dilutionMethod === &quot;begin&quot;) ? true : false; _.defaults(params2, parsed.value.dilutionParams, {cleanBetween: &quot;none&quot;, destinationMixing}); expansion.push(params2); // console.log({params1, params2}) } return { expansion }; }, &quot;pipetter.pipetteMixtures&quot;: function(params, parsed, data) { // console.log(&quot;pipetter.pipetteMixtures: &quot;+JSON.stringify(parsed, null, '\\t')); // Obtain a matrix of mixtures (rows for destinations, columns for layers) const mixtures0 = parsed.value.mixtures.map((item, index1) =&gt; { //console.log({index1, destination: item.destination || _.get(parsed.value.destinations, index1), destinations: _.get(parsed.value.destinations, index1)}) const {destination, syringe, sources} = (_.isPlainObject(item)) ? {destination: item.destination || _.get(parsed.value.destinations, index1), syringe: item.syringe, sources: item.sources} : {destination: _.get(parsed.value.destinations, index1), syringe: undefined, sources: item}; return sources.map((subitem, index2) =&gt; { // If the layer is empty, ignore it if (!_.isEmpty(subitem)) { // Fill in destination and syringe defaults for current destination+layer const item2 = _.merge({}, {destination, syringe}, subitem, {index: index2} ); //console.log({item2}) return item2; } else { return []; } }); }); //const destinations = parsed.value.destinations; //console.log(&quot;params:&quot;, params); //console.log(&quot;data.objects.mixtures:&quot;, data.objects.mixtures); //console.log(&quot;mixtures:\\n&quot;+JSON.stringify(mixtures0)); //console.log(&quot;A:&quot;, misc.getVariableValue(params.destinations, data.objects)) //console.log(&quot;data.objects.mixtureWells:&quot;, data.objects.mixtureWells); //console.log(&quot;destinations:&quot;, destinations); //expect.truthy({}, destinations.length &gt;= params.mixtures.length, &quot;length of destinations array must be equal or greater than length of mixtures array.&quot;); const mixtures = _.compact(mixtures0); //console.log(&quot;mixtures:&quot;, mixtures); const params2 = _.omit(params, ['mixtures', 'destinations', 'order']); let order = parsed.value.order || [&quot;index&quot;]; if (!_.isArray(order)) order = [order]; //console.log(&quot;A:&quot;, params2.items) params2.items = _(mixtures).flatten().compact().sortBy(order).map(item =&gt; _.omit(item, 'index')).value(); // console.log(&quot;B:&quot;, params2.items) params2.command = &quot;pipetter.pipette&quot;; return { expansion: { &quot;1&quot;: params2 } }; }, &quot;pipetter.punctureSeal&quot;: function(params, parsed, data) { const result = pipette(params, parsed, data, {keepVolumelessItems: true}); _.forEach(result.expansion, step =&gt; { if (step.command === &quot;pipetter._pipette&quot;) { step.command = &quot;pipetter._punctureSeal&quot;; } delete step.program; }); return result; }, }; module.exports = { roboliq: &quot;v1&quot;, schemas: yaml.load(__dirname+'/../schemas/pipetter.yaml'), commandHandlers: commandHandlers }; × Search results Close "},"commands_pipetter_groupingMethods.js.html":{"id":"commands_pipetter_groupingMethods.js.html","title":"Source: commands/pipetter/groupingMethods.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/pipetter/groupingMethods.js /** * Functions to break pipeetting items into groups that should be handled simultaneously. * Possible methods include: * * - each item is its own group * - groups are built until no more syringes would be available based on the item's tipModel (but syringe doesn't need to be assigned yet) * - groups are built (with limited look-ahead) where alternatives are investigated when a group splits over two columns * - have a fixed assignment between wells and syringes (i.e. row n = tip (n % 4)) for the sake of managing differences between tips * @module */ import _ from 'lodash' import assert from 'assert' /** * Place each item into its own group. * * @param {array} items Array of pipetting items. * @return {array} An array of groups of items; each group is a sublist of items from the original array. */ export function groupingMethod1(items) { return _.map(items, function(item) { return [item]; }); } /** * Groups are built until no more syringes would be available based on the item's tipModel (but syringe doesn't need to be assigned yet). * Also break groups on program changes. * TODO: break group if a previous dispense well is used as a source well. * * NOTE: if 'tipModelToSyringes' is supplied, this algorithm will not work predictably if the sets of syringes partially overlap with each other (complete overlap is fine). * * @param {array} items Array of pipetting items. * @param {array} syringes Array of integers representing the available syringe indexes * @param {object} tipModelToSyringes An optional map from tipModel to syringes that can be used with the given tipModel. If the map contains syringes that aren't listed in the 'syringes' array, they won't be used. * @return {array} An array of groups of items; each group is a sublist of items from the original array. */ export function groupingMethod2(items, syringes, tipModelToSyringes) { //console.log({items, syringes, tipModelToSyringes}) const groups = []; while (!_.isEmpty(items)) { const program = items[0].program; let syringesAvailable = _.clone(syringes); const group = _.takeWhile(items, function (item) { //console.log(&quot;A &quot;+JSON.stringify(item)); // Make sure we still have syringes available if (syringesAvailable.length == 0) return false; // Make sure all items in the group use the same program if (item.program !== program) return false; //console.log(&quot;B&quot;); assert(item.tipModel); // If tipModelToSyringes was provided if (!_.isEmpty(tipModelToSyringes)) { //console.log(&quot;C&quot;); assert(tipModelToSyringes.hasOwnProperty(item.tipModel)); var syringesPossible = tipModelToSyringes[item.tipModel]; //console.log({syringesPossible, syringesAvailable}) assert(!_.isEmpty(syringesPossible)); // Try to find a possible syringe that's still available var l = _.intersection(syringesPossible, syringesAvailable); if (_.isEmpty(l)) return false; //console.log(&quot;D&quot;); // Remove an arbitrary syringe from the list of available syringes syringesAvailable = _.without(syringesAvailable, l[0]); } else { //console.log(&quot;E&quot;); // Remove an arbitrary syringe from the list of available syringes syringesAvailable.splice(0, 1); } return true; }); assert(group.length &gt; 0); items = _.drop(items, group.length); groups.push(group); } return groups; } /** * Groups are built until no more syringes would be available based on the item's tipModel (but syringe doesn't need to be assigned yet). * It tries to group by `layer` by putting as many items from the same layer into the group before moving onto the next item. * Breaks are forced on: * * program changes * * when a previous dispense well is used as a source well * * NOTE: if 'tipModelToSyringes' is supplied, this algorithm will not work predictably if the sets of syringes partially overlap with each other (complete overlap is fine). * * @param {array} items Array of pipetting items. * @param {array} syringes Array of integers representing the available syringe indexes * @param {object} tipModelToSyringes An optional map from tipModel to syringes that can be used with the given tipModel. If the map contains syringes that aren't listed in the 'syringes' array, they won't be used. * @return {array} An array of groups of items; each group is a sublist of items from the original array. */ export function groupingMethod3(items, syringes, tipModelToSyringes) { //console.log({items, syringes, tipModelToSyringes}) if (_.isEmpty(items)) return []; assert(syringes.length &gt; 0) // Make a mutable copy of items, which we'll be splicing and shifting items = _.clone(items); // While items list isn't empty: // // If group is empty: // Create a group with first item // Set dispenseWells = {} // Set syringesAvailable = all // Set program to item.program // Set layer to item.layer // If layer: // nextItems = [next item with same layer, next item in items list] // Else: // nextItems = [next item in items list] // Else: (group isn't empty) // nextItems = [next item in items list] // // For all items in nextItems: // if the item can be added to the group: // add item to group // remote item from items list // break // // If no item was added, create a new empty group let current = undefined; function tryAdd(item, debug = false) { //console.log(&quot;A &quot;+JSON.stringify(item)); // Make sure we still have syringes available if (current.syringesAvailable.length == 0) { if (debug) console.log(&quot;syringesAvailable.length == 0&quot;); return false; } // Make sure all items in the group use the same program if (current.program !== item.program) { if (debug) console.log({currentProgram: current.program, itemProgram: item.program}); return false; } // Make sure source was not previously a destination in this group // const source = item.source || item.well; // const destination = item.destination || item.well; if (_.some(current.group, item2 =&gt; (item.source || item.well) === (item2.destination || item2.well))) { if (debug) console.log({currentGroup: current.group, item}); return false; } // Make sure syringe was not already used (only relevant want syringe is manually specified) if (item.syringe) { if (current.syringesUsed.hasOwnProperty(item.syringe)) { if (debug) console.log({syringesUsed: current.syringesUsed, itemSyringe: item.syringe}); return false; } current.syringesUsed[item.syringe] = true; } //console.log(&quot;B&quot;); assert(item.tipModel); // If tipModelToSyringes was provided if (!_.isEmpty(tipModelToSyringes)) { //console.log(&quot;C&quot;); assert(tipModelToSyringes.hasOwnProperty(item.tipModel), `tipModelToSyringes must contain an entry for &quot;${item.tipModel}&quot;`); const syringesPossible = tipModelToSyringes[item.tipModel]; //console.log({syringesPossible, syringesAvailable}) assert(!_.isEmpty(syringesPossible)); // Try to find a possible syringe that's still available const l = _.intersection(syringesPossible, current.syringesAvailable); if (_.isEmpty(l)) { if (debug) console.log({syringesPossible, syringesAvailable: current.syringesAvailable}); return false; } //console.log(&quot;D&quot;); // Remove an arbitrary syringe from the list of available syringes current.syringesAvailable = _.without(current.syringesAvailable, l[0]); } else { //console.log(&quot;E&quot;); // Remove an arbitrary syringe from the list of available syringes current.syringesAvailable.splice(0, 1); } current.group.push(item); current.layer = item.layer; return true; } const groups = []; while (!_.isEmpty(items)) { // If we need to start a new group: if (_.isUndefined(current)) { const item = items.shift(); current = { group: [], syringesAvailable: _.clone(syringes), syringesUsed: {}, program: item.program, layer: item.layer }; const added = tryAdd(item); assert(added, `couldn't add item to empty group!: ${JSON.stringify(item)}`); groups.push(current.group); } // Else, we will try to add an item to the current group else { const nextIndexes = [0]; // First check next item that's in the same layer as the last item in group if (!_.isUndefined(current.layer)) { const j = _.findIndex(items, item =&gt; { //console.log({a: current.layer, b: item.layer, c: _.isEqual(current.layer, item.layer), d: current.layer === item.layer}); return _.isEqual(current.layer, item.layer); }); //console.log({layer: current.layer, j}) if (j &gt; 0) { nextIndexes.unshift(j); } } // Try to add one of the items in nextIndexes let added = false; for (let k = 0; k &lt; nextIndexes.length; k++) { const j = nextIndexes[k]; const item = items[j]; if (tryAdd(item)) { // Remove the j-th element items.splice(j, 1); added = true; break; } } // If no item could be added, signal that a new group should be started by undefining `current` if (!added) { current = undefined; } } } return groups; } × Search results Close "},"commands_pipetter_pipetterUtils.js.html":{"id":"commands_pipetter_pipetterUtils.js.html","title":"Source: commands/pipetter/pipetterUtils.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/pipetter/pipetterUtils.js /** * A module of helper functions for the pipetter commands. * @module commands/pipetter/pipetterUtils */ var _ = require('lodash'); var assert = require('assert'); var math = require('mathjs'); import expect from '../../expect.js'; var misc = require('../../misc.js'); var wellsParser = require('../../parsers/wellsParser.js'); import * as WellContents from '../../WellContents.js'; /** * Get fully qualified syringe object name * @param {string|integer} syringeName - name or number of syringe * @param {object} data - The data object passed to command handlers. * @return {string} fully qualified syringe object name, if found */ export function getSyringeName(syringeName, equipmentName, data) { const syringeName2 = `${equipmentName}.syringe.${syringeName}`; if (_.isInteger(syringeName)) { return syringeName2; } else if (_.has(data.objects, syringeName)) { return syringeName; } else if (_.has(data.objects, syringeName2)) { return syringeName2; } return syringeName; } /** * Get an object representing the effects of pipetting, aspirating, or dispensing. * @param {object} params The parameters for the pipetter._aspirate command. * @param {object} data The data object passed to command handlers. * @param {object} effects an optional effects object for effects which have taken place during the command handler and aren't in the data object * @return {object} The effects caused by the `_aspirate`, `_dispense` or `_pipette` command. */ export function getEffects_pipette(parsed, data, effects) { const effects2 = (effects) ? _.cloneDeep(effects) : {}; const effectsNew = {}; function addEffect(name, obj) { effects2[name] = obj; effectsNew[name] = obj; } //console.log(&quot;getEffects_aspirate:\\n&quot;+JSON.stringify(parsed, null, '\\t')); parsed.value.items.forEach((item, index) =&gt; { // console.log(&quot;item: &quot;+JSON.stringify(item, null, '\\t')); // Get initial contents of the syringe const syringe = _.isString(item.syringe) ? _.get(data.objects, item.syringe) : item.syringe; const syringeName = _.isString(item.syringe) ? item.syringe : parsed.objectName[`items.${index}.syringe`]; const syringeContentsName = `${syringeName}.contents`; const syringeContents00 = effects2[syringeContentsName] || syringe.contents || []; const syringeContaminantsName = `${syringeName}.contaminants`; const volume = item.volume; const source = item.source; if (!_.isUndefined(source)) { const syringeContents0 = syringeContents00; const syringeContaminants0 = effects2[syringeContaminantsName] || syringe.contaminants || []; //console.log({syringeName, syringeContents0}); // Get initial contents of the source well const [srcContents00, srcContentsName] = WellContents.getContentsAndName(source, data, effects2); const srcContents0 = (_.isEmpty(srcContents00)) ? [&quot;Infinity l&quot;, source] : srcContents00; //console.log(&quot;srcContents0&quot;, srcContents0, srcContentsName); // Contents of source well and syringe after aspiration const [srcContents1a, syringeContents1a] = WellContents.transferContents(srcContents0, syringeContents0, item.volume); const srcContents1 = WellContents.mergeContents(srcContents1a); const syringeContents1 = WellContents.mergeContents(syringeContents1a); // console.log({srcContents1, syringeContents1a, syringeContents1}); // Update content effect for source addEffect(srcContentsName, srcContents1); // Get list of syringe contaminants const contaminants1 = _.keys(WellContents.flattenContents(syringeContents1)); //console.log({syringeContaminantsName, syringeContaminants0, contaminants1}); // Update contaminant effects if (!_.isEqual(syringeContaminants0, contaminants1)) addEffect(syringeContaminantsName, contaminants1); // Update content effect addEffect(syringeContentsName, syringeContents1); // Remove cleaned property //console.log(`syringe ${syringeName}: `+JSON.stringify(item.syringe)) if (!_.isUndefined(syringe.cleaned)) addEffect(`${syringeName}.cleaned`, null); // Update __WELLS__ effects for source const volume1 = math.eval(srcContents1[0]); const nameWELL = &quot;__WELLS__.&quot;+srcContentsName; //console.log(&quot;nameWELL:&quot;, nameWELL) const well0 = misc.findObjectsValue(nameWELL, data.objects, effects2) || { isSource: true, volumeMin: srcContents0[0], volumeMax: srcContents0[0] }; const well1 = _.merge({}, well0, { volumeMax: math.max(math.eval(well0.volumeMax), volume1).format({precision: 14}), volumeMin: math.min(math.eval(well0.volumeMin), volume1).format({precision: 14}), volumeRemoved: (well0.volumeRemoved) ? math.chain(math.eval(well0.volumeRemoved)).add(volume).done().format({precision: 14}) : volume.format({precision: 14}) }); //console.log({well0, well1}); //console.log(&quot;x:\\n&quot;+JSON.stringify(x, null, ' ')); addEffect(nameWELL, well1); } const destination = item.destination; if (!_.isUndefined(destination)) { const syringeContents0 = effects2[syringeContentsName] || syringe.contents || []; const syringeContaminants0 = effects2[syringeContaminantsName] || syringe.contaminants || []; //console.log({syringeName, syringeContents0}); // Get initial contents of the destination well const [dstContents0, dstContentsName] = WellContents.getContentsAndName(destination, data, effects2); //console.log(&quot;dst contents&quot;, dstContents0, dstContentsName); expect.truthy({paramName: `items[${index}].syringe`}, !WellContents.isEmpty(syringeContents0), &quot;syringe contents should not be empty when dispensing&quot;); // Final contents of source well and syringe const [syringeContents1, dstContents1] = WellContents.transferContents(syringeContents0, dstContents0, item.volume); //console.log({syringeContents1, dstContents1}) //console.log({srcContents1, syringeContents1}); // Check for contact with the destination contents by looking for // the word &quot;wet&quot; in the program name. const isWetContact = !_.isEmpty(parsed.value.program) &amp;&amp; /(_wet_|\\bwet\\b|_wet\\b)/.test(parsed.value.program.toLowerCase()); if (isWetContact) { // Contaminate the syringe with source contents // FIXME: Contaminate the syringe with destination contents if there is wet contact, i.e., use dstContents1 instead of srcContents0 for flattenContents() const contaminantsB = _.keys(WellContents.flattenContents(dstContents0)); const contaminants1 = _.uniq(syringeContaminants0.concat(contaminantsB)); if (!_.isEqual(syringeContaminants0, contaminants1)) addEffect(syringeContaminantsName, contaminants1); } // Update content effect // If content volume = zero, set to null const syringeContents2 = (WellContents.isEmpty(syringeContents1)) ? null : syringeContents1; if (!_.isEqual(syringeContents0, syringeContents2)) addEffect(syringeContentsName, syringeContents2); // Update content effect for destination addEffect(dstContentsName, dstContents1); // Update __WELLS__ effects for destination // REFACTOR: lots of duplication with the same code in the source condition const volume0 = WellContents.getVolume(dstContents0); const volume1 = WellContents.getVolume(dstContents1); const nameWELL = &quot;__WELLS__.&quot;+dstContentsName; //console.log({nameWELL, volume0, volume1}) //console.log(&quot;nameWELL:&quot;, nameWELL) const well0 = misc.findObjectsValue(nameWELL, data.objects, effects2) || { isSource: false, volumeMin: volume0.format({precision: 14}), volumeMax: volume0.format({precision: 14}) }; //console.log({well0}) const well1 = _.merge(well0, { volumeMax: math.max(math.eval(well0.volumeMax), volume1).format({precision: 14}), volumeMin: math.min(math.eval(well0.volumeMin), volume1).format({precision: 14}), volumeAdded: (well0.volumeAdded) ? math.chain(math.eval(well0.volumeAdded)).add(volume).done().format({precision: 14}) : volume.format({precision: 14}) }); //console.log(&quot;x:\\n&quot;+JSON.stringify(x, null, ' ')); addEffect(nameWELL, well1); } if (!_.isUndefined(item.well)) { // console.log({item}) const source = item.well; const syringeContents0 = syringeContents00; const syringeContaminants0 = effects2[syringeContaminantsName] || syringe.contaminants || []; //console.log({syringeName, syringeContents0}); // Get initial contents of the source well const [srcContents00, srcContentsName] = WellContents.getContentsAndName(source, data, effects2); const srcContents0 = (_.isEmpty(srcContents00)) ? [&quot;Infinity l&quot;, source] : srcContents00; //console.log(&quot;srcContents0&quot;, srcContents0, srcContentsName); // Contents of source well and syringe after aspiration const [srcContents1, syringeContents1] = WellContents.transferContents(srcContents0, syringeContents0, item.volume || WellContents.emptyVolume); //console.log({srcContents1, syringeContents1}); // Get list of syringe contaminants const contaminants1 = _.keys(WellContents.flattenContents(syringeContents1)); //console.log({syringeContaminantsName, syringeContaminants0, contaminants1}); // Update contaminant effects if (!_.isEqual(syringeContaminants0, contaminants1)) addEffect(syringeContaminantsName, contaminants1); // Remove cleaned property //console.log(`syringe ${syringeName}: `+JSON.stringify(item.syringe)) if (!_.isUndefined(syringe.cleaned)) addEffect(`${syringeName}.cleaned`, null); } // Prevent superfluous 'nulling' of syringe contents //console.log({syringeContentsName, syringeContents00, effects2: effects2[syringeContentsName], effectsNew: effectsNew[syringeContentsName]}) if (effects2[syringeContentsName] === null &amp;&amp; _.isEmpty(syringeContents00)) delete effectsNew[syringeContentsName]; }); //console.log(&quot;effectsNew:\\n&quot;+JSON.stringify(effectsNew)); return effectsNew; } × Search results Close "},"commands_pipetter_sourceMethods.js.html":{"id":"commands_pipetter_sourceMethods.js.html","title":"Source: commands/pipetter/sourceMethods.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/pipetter/sourceMethods.js /** * Methods for assigning which source well to use when a source liquid is * available in multiple wells. * * Details: * Assign source well by group for items without assigned source wells; if multiple syringes need to access the same source, and that source has multiple wells, then possible methods include: * * - pick first one * - rotate through source wells in order * - rotate through source wells in order of max volume * - try a simple geometrical assignment considering whether there are more tips or wells; if that fails, use previous method * - same as above, but if wells &gt; tips, try starting at first (wells - tips) wells and see which one produces the greatest minimum final volume * * @module */ var _ = require('lodash'); var assert = require('assert'); var math = require('mathjs'); import commandHelper from '../../commandHelper.js'; var expect = require('../../expect.js'); var pipetterUtils = require('./pipetterUtils.js'); var WellContents = require('../../WellContents.js'); /** * Pick the first well in a source set and ignore the others. * * The 'sourceWell' property of each item in 'group' will be set. * * @static * @param {array} group Array of pipetting items that are grouped together * @param {object} data Data passed to the commandHandler */ function sourceMethod1(group, data) { _.forEach(group, function (item) { var source = item.source; var sourceInfo = sourceParser.parse(item.source); if (sourceInfo.source) { var wells = expect.objectsValue({}, source+&quot;.wells&quot;, data.objects); assert(!_.isEmpty(wells)); item.sourceWell = wells[0]; } else { item.sourceWell = source; } }); } // Rotate through source wells in order /*function sourceMethod2(group, data) { var sourceToWellIndex = {}; _.forEach(group, function (item) { var source = item.source; var sourceInfo = sourceParser.parse(item.source); if (sourceInfo.source) { var wells = getObjectsValue(source+&quot;.wells&quot;, data.objects); assert(!_.isEmpty(wells)); var i = (sourceToWellIndex.hasOwnProperty(source)) ? sourceToWellIndex[source] : 0; item.sourceWell = wells[i]; sourceToWellIndex[source] = (i + 1) % wells.length; } else { item.sourceWell = source; } }); }*/ /** * Rotate through source wells in order of max volume. * The 'sourceWell' property of each item in 'group' will be set. * * @static * @param {array} group Array of pipetting items that are grouped together * @param {object} data Data passed to the commandHandler * @param {object} effects (Optional) Map from variable to effects */ function sourceMethod3(group, data, effects) { // Make our own copy of the the effects object var effects = (effects) ? _.cloneDeep(effects) : {}; // Consider each source in the group separately var sourceToItems = _.groupBy(_.filter(group, x =&gt; x.source), 'source'); //console.log(&quot;sourceToItems:\\n&quot;+JSON.stringify(sourceToItems, null, ' ')); for (const items of _.values(sourceToItems)) { // console.log(&quot;sourceMethod3&quot;, items) assert(items[0].source); var wells = _.clone(items[0].source); assert(!_.isEmpty(wells)); for (const item of items) { //console.log(&quot;wells: &quot;, wells); if (_.isArray(wells)) { if (wells.length === 1) { item.source = wells[0]; } else { var wellAndVolumes = _.map(wells, function(wellName) { var volume = WellContents.getWellVolume(wellName, data, effects); return {wellName, volume: volume.toNumber('ul')}; }); // Sort by volume //console.log({wellAndVolumes}) math.sort(wellAndVolumes, function(a, b) { return -math.compare(a.volume, b.volume)}); // Pick well with greatest volume var wellName = wellAndVolumes[0].wellName; item.source = wellName; //console.log(&quot;well chosen:&quot;, wellName); // Move the chosen well to the back of the array _.pull(wells, wellName); wells.push(wellName); const params = {items: [_.clone(item)]}; params.items[0].volume = item.volume.format({precision: 14}); const schema = { properties: { items: { description: &quot;Data about what should be pipetted where&quot;, &quot;type&quot;: &quot;array&quot;, items: {type: &quot;pipetter._PipetteItem&quot;} } }, required: [&quot;items&quot;] }; //console.log(&quot;param of items:&quot;) //console.log(JSON.stringify(params, null, '\\t')) const parsed = commandHelper.parseParams(params, data, schema); //console.log(&quot;parsed:&quot;); //console.log(JSON.stringify(parsed, null, '\\t')) // Get effect of pipetting, so that source volumes are changed appropriately var effects2 = pipetterUtils.getEffects_pipette(parsed, data, effects); _.merge(effects, effects2); //console.log(&quot;effects2&quot;, effects2) //console.log(&quot;effects&quot;, effects) } } else { //item.source = item.source; } } } } module.exports = { sourceMethod1, //sourceMethod2: sourceMethod2, sourceMethod3 } × Search results Close "},"commands_simulatedHelpers.js.html":{"id":"commands_simulatedHelpers.js.html","title":"Source: commands/simulatedHelpers.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/simulatedHelpers.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Helper functions for simulating measurements. * @module commands/simulatedHelpers */ var _ = require('lodash'); import math from 'mathjs'; var commandHelper = require('../commandHelper.js'); const Design = require('../design.js'); import wellsParser from '../parsers/wellsParser.js'; export function simulatedByWells(parsed, data, wells0, result) { // console.log(JSON.stringify(parsed, null, '\\t')) // console.log({SCOPE: data.objects.SCOPE}) let simulatedOutput; if (_.has(parsed.value, [&quot;output&quot;, &quot;simulated&quot;])) { const joinKey = _.get(parsed.value, [&quot;output&quot;, &quot;joinKey&quot;]); const userValues = _.get(parsed.value, [&quot;output&quot;, &quot;userValues&quot;], {}); const wells = _.uniq(_.map(wells0, x =&gt; x.replace(/.*\\(([^)]*)\\)/, &quot;$1&quot;))); const common = (_.isEmpty(joinKey)) ? data.objects.SCOPE : {}; // console.log({common}) // console.log(&quot;DATA:\\n&quot;+JSON.stringify(data.objects.DATA)) simulatedOutput = _.map(wells, (well, i) =&gt; { const row0 = (!_.isUndefined(joinKey)) ? _.find(data.objects.DATA, row =&gt; (row[joinKey].replace(/.*\\(([^)]*)\\)/, &quot;$1&quot;) === well)) || {} : common; const scope = _.defaults({}, row0, data.objects.SCOPE); // console.log({i, row0, simulated: parsed.value.output.simulated}) const value = Design.calculate(parsed.value.output.simulated, scope); const row = _.merge({RUNID: &quot;simulated&quot;, object: parsed.objectName.object}, row0, userValues, {well, value_type: &quot;absorbance&quot;, value}); // console.log(&quot;row: &quot;+JSON.stringify(row)) return row; }); if (_.has(parsed.value, [&quot;output&quot;, &quot;units&quot;])) { _.forEach(simulatedOutput, row =&gt; { _.forEach(parsed.value.output.units, (units, key) =&gt; { if (_.has(row, key)) { // console.log(row) // console.log({key, units, value: row[key]}); // console.log({a: math.eval(row[key])}) row[key] = math.eval(row[key]).toNumber(units); } }); }); } } if (simulatedOutput) { if (_.has(parsed.value, [&quot;output&quot;, &quot;writeTo&quot;])) { _.set(result, [&quot;simulatedOutput&quot;, parsed.value.output.writeTo+&quot;.json&quot;], simulatedOutput); } if (_.has(parsed.value, [&quot;output&quot;, &quot;appendTo&quot;])) { _.set(result, [&quot;simulatedOutput&quot;, parsed.value.output.appendTo+&quot;.jsonl&quot;], _.get(data, [&quot;simulatedOutput&quot;, parsed.value.output.appendTo+&quot;.jsonl&quot;], []).concat(simulatedOutput)); } } return simulatedOutput; } export function simulatedByLabware(parsed, data, labwares0, result) { // console.log(JSON.stringify(parsed, null, '\\t')) // console.log({SCOPE: data.objects.SCOPE}) let simulatedOutput; if (_.has(parsed.value, [&quot;output&quot;, &quot;simulated&quot;])) { const joinKey = _.get(parsed.value, [&quot;output&quot;, &quot;joinKey&quot;]); const userValues = _.get(parsed.value, [&quot;output&quot;, &quot;userValues&quot;], {}); const labwares = _.uniq(_.map(labwares0, x =&gt; x.replace(/.*\\(([^)]*)\\)/, &quot;$1&quot;))); const common = (_.isEmpty(joinKey)) ? data.objects.SCOPE : {}; // console.log({common}) // console.log(&quot;DATA:\\n&quot;+JSON.stringify(data.objects.DATA)) simulatedOutput = _.map(labwares, labware =&gt; { const row0 = (!_.isUndefined(joinKey)) ? _.find(data.objects.DATA, row =&gt; (row[joinKey].replace(/.*\\(([^)]*)\\)/, &quot;$1&quot;) === labware)) || {} : common; const scope = _.defaults({}, row0, data.objects.SCOPE); // console.log({row0, row1, simulated: parsed.value.output.simulated}) const value = Design.calculate(parsed.value.output.simulated, scope); const row = _.merge({RUNID: &quot;simulated&quot;, object: parsed.objectName.object}, row0, userValues, {labware, value_type: &quot;absorbance&quot;, value}); // console.log(&quot;row: &quot;+JSON.stringify(row)) return row; }); if (_.has(parsed.value, [&quot;output&quot;, &quot;units&quot;])) { _.forEach(simulatedOutput, row =&gt; { _.forEach(parsed.value.output.units, (units, key) =&gt; { if (_.has(row, key)) { // console.log(row) // console.log({key, units, value: row[key]}); // console.log({a: math.eval(row[key])}) row[key] = math.eval(row[key]).toNumber(units); } }); }); } } if (simulatedOutput) { if (_.has(parsed.value, [&quot;output&quot;, &quot;writeTo&quot;])) { _.set(result, [&quot;simulatedOutput&quot;, parsed.value.output.writeTo+&quot;.json&quot;], simulatedOutput); } if (_.has(parsed.value, [&quot;output&quot;, &quot;appendTo&quot;])) { _.set(result, [&quot;simulatedOutput&quot;, parsed.value.output.appendTo+&quot;.jsonl&quot;], _.get(data, [&quot;simulatedOutput&quot;, parsed.value.output.appendTo+&quot;.jsonl&quot;], []).concat(simulatedOutput)); } } return simulatedOutput; } × Search results Close "},"commands_timer.js.html":{"id":"commands_timer.js.html","title":"Source: commands/timer.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/timer.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Namespace for the ``timer`` commands. * @namespace timer * @version v1 */ /** * Timer commands module. * @module commands/timer * @return {Protocol} */ var _ = require('lodash'); var jmespath = require('jmespath'); var yaml = require('yamljs'); var commandHelper = require('../commandHelper.js'); var expect = require('../expect.js'); var misc = require('../misc.js'); /** * Create predicates for objects of type = &quot;Timer&quot; * @static */ var objectToPredicateConverters = { &quot;Timer&quot;: function(name, object) { return _.compact([ {&quot;isTimer&quot;: {&quot;equipment&quot;: name}}, (object.running) ? {&quot;running&quot;: {&quot;equipment&quot;: name}} : null ]); }, }; function findAgentEquipmentAlternatives(params, data, running) { var llpl = require('../HTN/llpl.js').create(); //console.log(&quot;predicates:\\n&quot;+JSON.stringify(data.predicates)) llpl.initializeDatabase(data.predicates); var agent = params.agent || &quot;?agent&quot;; var equipment = params.equipment || &quot;?equipment&quot;; var query1 = {&quot;timer.canAgentEquipment&quot;: { &quot;agent&quot;: agent, &quot;equipment&quot;: equipment }}; var query2 = (running === true) ? {running: {equipment: equipment}} : (running === false) ? {not: {running: {equipment: equipment}}} : null; var query = {&quot;and&quot;: _.compact([query1, query2])}; //console.log(&quot;query:\\n&quot;+JSON.stringify(query, null, '\\t')) var resultList = llpl.query(query); //console.log(&quot;resultList:\\n&quot;+JSON.stringify(resultList)) var alternatives = jmespath.search(resultList, '[].and[].&quot;timer.canAgentEquipment&quot;'); if (_.isEmpty(alternatives)) { var resultList1 = llpl.query(query1); if (_.isEmpty(resultList1)) { return { errors: [&quot;missing timer data (please add predicates `timer.canAgentEquipment`)&quot;] }; } else { return { errors: [&quot;missing available timer configuration for &quot; + JSON.stringify(query)] }; } } return alternatives; } /** * Handlers for {@link timer} commands. * @static */ var commandHandlers = { /** * Sleep for a given duration using a specific timer. * * Handler should return `effects` that the timer is not running. * * @typedef _sleep * @memberof timer * @property {string} command - &quot;timer._sleep&quot; * @property {string} agent - Agent identifier * @property {string} equipment - Equipment identifier * @property {number} duration - Number of seconds to sleep */ &quot;timer._sleep&quot;: function(params, parsed, data) { var effects = {}; if (parsed.value.stop) effects[parsed.objectName.equipment + &quot;.running&quot;] = false; return { effects: effects }; }, /** * Start the given timer. * * Handler should return `effects` that the timer is running. * * @typedef _start * @memberof timer * @property {string} command - &quot;timer._start&quot; * @property {string} agent - Agent identifier * @property {string} equipment - Equipment identifier */ &quot;timer._start&quot;: function(params, parsed, data) { var effects = {}; effects[parsed.objectName.equipment + &quot;.running&quot;] = true; return { effects: effects }; }, /** * Stop the given timer. * * Handler should return `effects` that the timer is not running. * * @typedef _stop * @memberof timer * @property {string} command - &quot;timer._stop&quot; * @property {string} agent - Agent identifier * @property {string} equipment - Equipment identifier */ &quot;timer._stop&quot;: function(params, parsed, data) { var effects = {}; effects[parsed.objectName.equipment + &quot;.running&quot;] = false; return { effects: effects }; }, /** * Wait until the given timer has reacher the given elapsed time. * * Handler should: * - expect that the timer (identified by the `equipment` parameter) is running * - return `effects` that the timer is not running * * @typedef _wait * @memberof timer * @property {string} command - &quot;timer._wait&quot; * @property {string} agent - Agent identifier * @property {string} equipment - Equipment identifier * @property {number} till - Number of seconds to wait till from the time the timer was started * @property {boolean} stop - Whether to stop the timer after waiting, or let it continue */ &quot;timer._wait&quot;: function(params, parsed, data) { // TODO: assert that timer is running var effects = {}; if (parsed.value.stop) effects[parsed.objectName.equipment + &quot;.running&quot;] = false; return { effects: effects }; }, /** * A control construct to perform the given sub-steps and then wait * until a certain amount of time has elapsed since the beginning of this command. * * @typedef doAndWait * @memberof timer * @property {string} command - &quot;timer.doAndWait&quot; * @property {string} [agent] - Agent identifier * @property {string} [equipment] - Equipment identifier * @property {number} duration - Number of seconds this command should last * @property {Array|Object} steps - Sub-steps to perform */ &quot;timer.doAndWait&quot;: function(params, parsed, data) { var alternatives = findAgentEquipmentAlternatives(params, data, false); if (alternatives.errors) return alternatives; var agent = alternatives[0].agent; var equipment = alternatives[0].equipment; var expansion = { 1: { command: &quot;timer._start&quot;, agent: agent, equipment: equipment }, 2: parsed.value.steps, 3: { command: &quot;timer._wait&quot;, agent: agent, equipment: equipment, till: parsed.value.duration.toNumber('s'), stop: true }, }; return { expansion: expansion }; }, /** * Sleep for a given duration. * * @typedef sleep * @memberof timer * @property {string} command - &quot;timer.sleep&quot; * @property {string} [agent] - Agent identifier * @property {string} [equipment] - Equipment identifier * @property {number} duration - Number of seconds to sleep */ &quot;timer.sleep&quot;: function(params, parsed, data) { var alternatives = findAgentEquipmentAlternatives(params, data, false); if (alternatives.errors) return alternatives; var params2 = _.merge( { command: &quot;timer._sleep&quot;, duration: parsed.value.duration.format({precision: 6}) }, alternatives[0] ); var expansion = { &quot;1&quot;: params2 }; // Create the effets object var effects = {}; //effects[params2.equipment + &quot;.running&quot;] = true; return { expansion: expansion, effects: effects, alternatives: alternatives }; }, /** * Start a timer. * * @typedef start * @memberof timer * @property {string} command - &quot;timer.start&quot; * @property {string} [agent] - Agent identifier * @property {string} [equipment] - Equipment identifier */ &quot;timer.start&quot;: function(params, parsed, data) { var alternatives = findAgentEquipmentAlternatives(params, data, false); //console.log({alternatives}) if (alternatives.errors) return alternatives; var params2 = _.merge( { command: &quot;timer._start&quot; }, alternatives[0] ); var expansion = { &quot;1&quot;: params2 }; // Create the effets object var effects = {}; //effects[params2.equipment + &quot;.running&quot;] = true; return { expansion: expansion, effects: effects, alternatives: alternatives }; }, /** * Stop a running timer. * * @typedef stop * @memberof timer * @property {string} command - &quot;timer.stop&quot; * @property {string} [agent] - Agent identifier * @property {string} [equipment] - Equipment identifier */ &quot;timer.stop&quot;: function(params, parsed, data) { var alternatives = findAgentEquipmentAlternatives(params, data, true); if (alternatives.errors) return alternatives; if (alternatives.length &gt; 1) { return {errors: [&quot;ambiguous time.stop command, multiple running timers: &quot;+alternatives]}; } var params2 = _.merge( { command: &quot;timer._stop&quot; }, alternatives[0] ); var expansion = { &quot;1&quot;: params2 }; // Create the effets object var effects = {}; //effects[params2.equipment + &quot;.running&quot;] = false; return { expansion: expansion, effects: effects, alternatives: alternatives }; }, &quot;timer.wait&quot;: function(params, parsed, data) { var alternatives = findAgentEquipmentAlternatives(params, data, true); if (alternatives.errors) return alternatives; if (alternatives.length &gt; 1) { return {errors: [&quot;ambiguous time.wait command, multiple running timers: &quot;+alternatives]}; } var params2 = _.merge( { command: &quot;timer._wait&quot;, till: parsed.value.till.format({precision: 14}), stop: parsed.value.stop }, alternatives[0] ); var expansion = { &quot;1&quot;: params2 }; // Create the effets object var effects = {}; //effects[params2.equipment + &quot;.running&quot;] = false; return { expansion: expansion, effects: effects, alternatives: alternatives }; }, }; /** * @type {Protocol} */ module.exports = { roboliq: &quot;v1&quot;, objectToPredicateConverters, schemas: yaml.load(__dirname+'/../schemas/timer.yaml'), commandHandlers }; × Search results Close "},"commands_transporter.js.html":{"id":"commands_transporter.js.html","title":"Source: commands/transporter.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: commands/transporter.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Namespace for the ``transporter`` commands. * @namespace transporter * @version v1 */ /** * Transporter commands module. * @module commands/transporter * @return {Protocol} * @version v1 */ const _ = require('lodash'); import yaml from 'yamljs'; const commandHelper = require('../commandHelper.js'); const expect = require('../expect.js'); const misc = require('../misc.js'); /** * Create predicates for objects of type = &quot;Transporter&quot; * @static */ var objectToPredicateConverters = { &quot;Transporter&quot;: function(name, data) { return [{ &quot;isTransporter&quot;: { &quot;equipment&quot;: name } }]; }, }; /** * Transport a lid from a container to a destination site. */ function moveLidFromContainerToSite(params, parsed, data) { // console.log(&quot;transporter.moveLidFromContainerToSite:&quot;); console.log(JSON.stringify(parsed, null, '\\t')) if (parsed.input.containerObject.type != &quot;Plate&quot;) { expect.throw({paramName: &quot;object&quot;}, &quot;expected lid to be on a plate; instead lid's location is &quot;+parsed.input.container); } const transporterLogic = require('./transporterLogic.json'); const keys = [&quot;null&quot;, &quot;one&quot;]; const movePlateParams = makeMoveLidFromContainerToSiteParams(parsed); const shop = require('../HTN/shop.js'); const llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); let input0 = data.predicates; let plan; let errorLog = &quot;&quot;; for (let i = 0; i &lt; keys.length; i++) { const key = keys[i]; const method = {method: makeMoveLidFromContainerToSiteMethod(parsed, movePlateParams, i)}; input0 = input0.concat(_.values(transporterLogic[key])); input0 = input0.concat([method]); if (transporterLogic.hasOwnProperty(key)) { llpl.addToDatabase(transporterLogic[key]); } llpl.addToDatabase([method]); // const fs = require('fs'); // fs.writeFileSync(&quot;a.json&quot;, JSON.stringify(llpl.database, null, '\\t')); const queryResultsAll = queryMovePlateMethod(llpl, method.method, i); // If we didn't find a path for this method: if (queryResultsAll.length === 0) { //const queryResultOne = llpl.query({stackable: {below: &quot;?below&quot;, above: &quot;ourlab.model.lidModel_384_square&quot;}}); //console.log(&quot;queryResultOne: &quot; +JSON.stringify(queryResultOne)) const text = debugMovePlateMethod(llpl, method.method, queryResultsAll, i); errorLog += text; } // If we did find a path: else { // console.log(`${queryResultsAll.length} path(s) found, e.g.: ${JSON.stringify(queryResultsAll[0])}`); const tasks = { &quot;tasks&quot;: { &quot;ordered&quot;: [{ moveLidFromContainerToSite: movePlateParams }] } }; const input = input0.concat([tasks]); var planner = shop.makePlanner(input); plan = planner.plan(); //console.log(key, plan) if (!_.isEmpty(plan)) { //console.log(&quot;plan found for &quot;+key) //console.log(planner.ppPlan(plan)); } else { console.log(&quot;apparently unable to open some site or something&quot;) } break; } } if (_.isEmpty(plan)) { console.log(errorLog); //console.log(&quot;transporter.movePlate: &quot;+JSON.stringify(parsed, null, '\\t')) return {errors: [`unable to find a transportation path for lid ${parsed.input.object} on ${parsed.input.container} from ${parsed.input.origin} to ${parsed.input.destination}`]}; } var tasks = planner.listAndOrderTasks(plan, true); //console.log(&quot;Tasks:&quot;) //console.log(JSON.stringify(tasks, null, ' ')); var cmdList = _(tasks).map(function(task) { return _(task).map(function(taskParams, taskName) { return (data.planHandlers.hasOwnProperty(taskName)) ? data.planHandlers[taskName](taskParams, params, data) : []; }).flatten().value(); }).flatten().value(); // console.log(&quot;cmdList: &quot;+JSON.stringify(cmdList, null, ' ')); // Create the expansion object var expansion = {}; var i = 1; _.forEach(cmdList, function(cmd) { expansion[i.toString()] = cmd; i += 1; }); // Create the effets object var effects = {}; effects[`${parsed.objectName.object}.location`] = parsed.objectName.destination; return { expansion: expansion, effects: effects }; } moveLidFromContainerToSite.inputSpec = { lid: &quot;object&quot;, lidModel: &quot;object*model&quot;, container: &quot;object*location&quot;, containerObject: &quot;object*location*&quot;, model: &quot;?object*location*model&quot;, origin: &quot;?object*location*location&quot;, destination: &quot;destination&quot; }; /** * Take the parsed parameters passed to `transporter.moveLidFromContainerToSite` * and create the parameter list for the task `moveLidFromContainerToSite` in `makeMoveLidFromContainerToSiteMethod()`. * If any of the following parameters are not specified, then they will also * be a part of the created parameters: agent, equipment, program */ function makeMoveLidFromContainerToSiteParams(parsed) { // console.log(&quot;makeMoveLidFromContainerToSiteParams: &quot;+JSON.stringify(parsed)) return _.pickBy({ agent: (parsed.objectName.agent) ? &quot;?agent&quot; : undefined, equipment: (parsed.objectName.equipment) ? &quot;?equipment&quot; : undefined, program: (parsed.objectName.program || parsed.value.program) ? &quot;?program&quot; : undefined, lid: &quot;?lid&quot;, container: &quot;?container&quot;, destination: &quot;?destination&quot; }); } function makeMoveLidFromContainerToSiteMethod(parsed, moveLidParams, n) { // console.log(&quot;makeMoveLidFromContainToSiteMethod: &quot;+JSON.stringify(parsed, null, '\\t')); const {lid, lidModel, container, model, origin, destination} = parsed.input; function makeArray(name, value) { return _.map(_.range(n), i =&gt; (_.isUndefined(value)) ? name+(i+1) : value); } const agents = makeArray(&quot;?agent&quot;, parsed.objectName.agent); const equipments = makeArray(&quot;?equipment&quot;, parsed.objectName.equipment); const programs = makeArray(&quot;?program&quot;, parsed.objectName.program || parsed.value.program) //const origin = parsed.value.object.location; // if (n === 0) { const name = &quot;moveLidFromContainerToSite-0&quot;; return { &quot;description&quot;: `${name}: transport lid from container to destination in ${n} step(s)`, &quot;task&quot;: {&quot;moveLidFromContainerToSite&quot;: moveLidParams}, &quot;preconditions&quot;: [ {&quot;location&quot;: {&quot;labware&quot;: lid, &quot;site&quot;: destination}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}} ]} }; } else if (n === 1) { const name = &quot;moveLidFromContainerToSite-1&quot;; return { &quot;description&quot;: `${name}: transport plate from origin to destination in ${n} step(s)`, &quot;task&quot;: {&quot;moveLidFromContainerToSite&quot;: moveLidParams}, &quot;preconditions&quot;: [ {&quot;model&quot;: {&quot;labware&quot;: lid, &quot;model&quot;: lidModel}}, // TODO: Superfluous, but maybe check anyway {&quot;location&quot;: {&quot;labware&quot;: lid, &quot;site&quot;: container}}, //{&quot;labwareHasLid&quot;: {&quot;labware&quot;: container}}, {&quot;model&quot;: {&quot;labware&quot;: container, &quot;model&quot;: model}}, {&quot;location&quot;: {&quot;labware&quot;: container, &quot;site&quot;: origin}}, {&quot;siteIsOpen&quot;: {&quot;site&quot;: origin}}, {&quot;siteIsOpen&quot;: {&quot;site&quot;: destination}}, {&quot;siteModel&quot;: {&quot;site&quot;: origin, &quot;siteModel&quot;: &quot;?originModel&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: destination, &quot;siteModel&quot;: &quot;?destinationModel&quot;}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?destinationModel&quot;, &quot;above&quot;: lidModel}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: destination}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: origin}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: destination}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;siteClique&quot;: &quot;?siteClique1&quot;}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}}, {&quot;transporter._moveLidFromContainerToSite&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], lid, lidModel, container, model, origin, &quot;originModel&quot;: &quot;?originModel&quot;, destination, &quot;destinationModel&quot;: &quot;?destinationModel&quot;}} ]} }; } assert(false); } /** * Transport a lid from an origin site to a container. */ function moveLidFromSiteToContainer(params, parsed, data) { // console.log(&quot;transporter.moveLidFromSiteToContainer:&quot;); console.log(JSON.stringify(parsed, null, '\\t')); if (parsed.input.originType != &quot;Site&quot;) { expect.throw({paramName: &quot;object&quot;}, &quot;expected lid to be on a site; instead lid's location is &quot;+parsed.input.origin); } const transporterLogic = require('./transporterLogic.json'); const keys = [&quot;null&quot;, &quot;one&quot;]; const movePlateParams = makeMoveLidFromSiteToContainerParams(parsed); const shop = require('../HTN/shop.js'); const llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); let input0 = data.predicates; let plan; let errorLog = &quot;&quot;; for (let i = 0; i &lt; keys.length; i++) { const key = keys[i]; const method = {method: makeMoveLidFromSiteToContainerMethod(parsed, movePlateParams, i, llpl)}; input0 = input0.concat(_.values(transporterLogic[key])); input0 = input0.concat([method]); if (transporterLogic.hasOwnProperty(key)) { llpl.addToDatabase(transporterLogic[key]); } llpl.addToDatabase([method]); // const fs = require('fs'); // fs.writeFileSync(&quot;a.json&quot;, JSON.stringify(llpl.database, null, '\\t')); const queryResultsAll = queryMovePlateMethod(llpl, method.method, i); // If we didn't find a path for this method: if (queryResultsAll.length === 0) { //const queryResultOne = llpl.query({stackable: {below: &quot;?below&quot;, above: &quot;ourlab.model.lidModel_384_square&quot;}}); //console.log(&quot;queryResultOne: &quot; +JSON.stringify(queryResultOne)) const text = debugMovePlateMethod(llpl, method.method, queryResultsAll, i); errorLog += text; } // If we did find a path: else { // console.log(`${queryResultsAll.length} path(s) found, e.g.: ${JSON.stringify(queryResultsAll[0])}`); const tasks = { &quot;tasks&quot;: { &quot;ordered&quot;: [{ moveLidFromSiteToContainer: movePlateParams }] } }; const input = input0.concat([tasks]); var planner = shop.makePlanner(input); plan = planner.plan(); //console.log(key, plan) if (!_.isEmpty(plan)) { //console.log(&quot;plan found for &quot;+key) //console.log(planner.ppPlan(plan)); } else { console.log(&quot;apparently unable to open some site or something&quot;) } break; } } if (_.isEmpty(plan)) { console.log(errorLog); const x = _.pickBy({agent: parsed.objectName.agent, equipment: parsed.objectName.equipment, program: parsed.objectName.program || parsed.value.program, model: parsed.value.object.model, origin: parsed.objectName[&quot;object.location&quot;], destination: parsed.objectName.destination}); //console.log(&quot;transporter.movePlate: &quot;+JSON.stringify(parsed, null, '\\t')) return {errors: [&quot;unable to find a transportation path for lid `&quot;+parsed.objectName.object+&quot;` from `&quot;+parsed.objectName.origin+&quot;` to `&quot;+parsed.objectName.container+&quot;` at `&quot;+parsed.value.container.location+&quot;`&quot;, JSON.stringify(x)]}; } var tasks = planner.listAndOrderTasks(plan, true); //console.log(&quot;Tasks:&quot;) //console.log(JSON.stringify(tasks, null, ' ')); var cmdList = _(tasks).map(function(task) { return _(task).map(function(taskParams, taskName) { return (data.planHandlers.hasOwnProperty(taskName)) ? data.planHandlers[taskName](taskParams, params, data) : []; }).flatten().value(); }).flatten().value(); // console.log(&quot;cmdList: &quot;+JSON.stringify(cmdList, null, ' ')); // Create the expansion object var expansion = {}; var i = 1; _.forEach(cmdList, function(cmd) { expansion[i.toString()] = cmd; i += 1; }); // Create the effets object var effects = {}; effects[`${parsed.objectName.object}.location`] = parsed.objectName.container; // console.log(&quot;expansion: &quot;+JSON.stringify(expansion, null, '\\t')) // console.log(&quot;effects: &quot;+JSON.stringify(effects, null, '\\t')) return { expansion: expansion, effects: effects }; } moveLidFromSiteToContainer.inputSpec = { origin: &quot;object*location&quot;, originType: &quot;object*location*type&quot;, lid: &quot;object&quot;, lidModel: &quot;object*model&quot;, container: &quot;container&quot;, model: &quot;container*model&quot;, destination: &quot;container*location&quot; }; /** * Take the parsed parameters passed to `transporter.moveLidFromSiteToContainer` * and create the parameter list for the task `moveLidFromSiteToContainer` in `makeMoveLidFromSiteToContainerMethod()`. * If any of the following parameters are not specified, then they will also * be a part of the created parameters: agent, equipment, program */ function makeMoveLidFromSiteToContainerParams(parsed) { // console.log(&quot;makeMoveLidFromSiteToContainerParams: &quot;+JSON.stringify(parsed)) return _.pickBy({ agent: (parsed.objectName.agent) ? &quot;?agent&quot; : undefined, equipment: (parsed.objectName.equipment) ? &quot;?equipment&quot; : undefined, program: (parsed.objectName.program || parsed.value.program) ? &quot;?program&quot; : undefined, lid: &quot;?lid&quot;, origin: &quot;?origin&quot;, container: &quot;?container&quot; }); } function makeMoveLidFromSiteToContainerMethod(parsed, moveLidParams, n, llpl) { // console.log(&quot;makeMoveLidFromContainToSiteMethod: &quot;+JSON.stringify(parsed, null, '\\t')); const {origin, lid, lidModel, container, model, destination} = parsed.input; // console.log({lid, lidModel, container, model, origin, destination}) const originQuery = llpl.query({&quot;siteModel&quot;: {&quot;site&quot;: origin, &quot;siteModel&quot;: &quot;?originModel&quot;}}); const destinationQuery = llpl.query({&quot;siteModel&quot;: {&quot;site&quot;: destination, &quot;siteModel&quot;: &quot;?destinationModel&quot;}}); // console.log(&quot;originQuery: &quot;+JSON.stringify(originQuery, null, '\\t')) // console.log(&quot;destinationQuery: &quot;+JSON.stringify(destinationQuery, null, '\\t')) const originModel = originQuery[0].siteModel.siteModel; const destinationModel = destinationQuery[0].siteModel.siteModel; // console.log(&quot;labwareHasNoLid?: &quot;+JSON.stringify(llpl.query({&quot;labwareHasNoLid&quot;: {&quot;site&quot;: container}}))) function makeArray(name, value) { return _.map(_.range(n), i =&gt; (_.isUndefined(value)) ? name+(i+1) : value); } const agents = makeArray(&quot;?agent&quot;, parsed.objectName.agent); const equipments = makeArray(&quot;?equipment&quot;, parsed.objectName.equipment); const programs = makeArray(&quot;?program&quot;, parsed.objectName.program || parsed.value.program) if (n === 0) { const name = &quot;moveLidFromSiteToContainer-0&quot;; return { &quot;description&quot;: `${name}: transport lid from container to destination in ${n} step(s)`, &quot;task&quot;: {&quot;moveLidFromSiteToContainer&quot;: moveLidParams}, &quot;preconditions&quot;: [ {&quot;location&quot;: {&quot;labware&quot;: lid, &quot;labware&quot;: destination}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}} ]} }; } else if (n === 1) { const name = &quot;moveLidFromSiteToContainer-1&quot;; return { &quot;description&quot;: `${name}: transport plate from origin to destination in ${n} step(s)`, &quot;task&quot;: {&quot;moveLidFromSiteToContainer&quot;: moveLidParams}, &quot;preconditions&quot;: [ // {&quot;model&quot;: {&quot;labware&quot;: lid, &quot;model&quot;: lidModel}}, // TODO: Superfluous, but maybe check anyway {&quot;location&quot;: {&quot;labware&quot;: lid, &quot;site&quot;: origin}}, {&quot;model&quot;: {&quot;labware&quot;: container, &quot;model&quot;: model}}, {&quot;location&quot;: {&quot;labware&quot;: container, &quot;site&quot;: destination}}, {&quot;siteIsOpen&quot;: {&quot;site&quot;: origin}}, {&quot;siteIsOpen&quot;: {&quot;site&quot;: destination}}, {&quot;siteModel&quot;: {&quot;site&quot;: origin, &quot;siteModel&quot;: originModel}}, {&quot;siteModel&quot;: {&quot;site&quot;: destination, &quot;siteModel&quot;: destinationModel}}, {&quot;stackable&quot;: {&quot;below&quot;: model, &quot;above&quot;: lidModel}}, {&quot;labwareHasNoLid&quot;: {&quot;labware&quot;: container}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: origin}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: destination}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;siteClique&quot;: &quot;?siteClique1&quot;}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}}, {&quot;transporter._moveLidFromSiteToContainer&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], lid, lidModel, container, model, origin, &quot;originModel&quot;: originModel, destination, &quot;destinationModel&quot;: destinationModel}} ]} }; } assert(false); } function makeMovePlateParams(parsed) { return _.merge({}, { agent: (parsed.objectName.agent) ? &quot;?agent&quot; : undefined, equipment: (parsed.objectName.equipment) ? &quot;?equipment&quot; : undefined, program: (parsed.objectName.program || parsed.value.program) ? &quot;?program&quot; : undefined, labware: &quot;?labware&quot;, destination: &quot;?destination&quot; }); } function makeMovePlateMethod(parsed, movePlateParams, n) { //console.log(&quot;makeMovePlateMethod: &quot;+JSON.stringify(parsed, null, '\\t')); function makeArray(name, value) { return _.map(_.range(n), i =&gt; (_.isUndefined(value)) ? name+(i+1) : value); } const labware = parsed.objectName.object; const model = parsed.value.object.model; const origin = parsed.value.object.location; const destination = parsed.objectName.destination; const agents = makeArray(&quot;?agent&quot;, parsed.objectName.agent); const equipments = makeArray(&quot;?equipment&quot;, parsed.objectName.equipment); const programs = makeArray(&quot;?program&quot;, parsed.objectName.program || parsed.value.program) //const origin = parsed.value.object.location; // if (n === 0) { const name = &quot;movePlate-0&quot;; return { &quot;description&quot;: `${name}: transport plate from origin to destination in ${n} step(s)`, &quot;task&quot;: {&quot;movePlate&quot;: movePlateParams}, &quot;preconditions&quot;: [ {&quot;location&quot;: {&quot;labware&quot;: labware, &quot;site&quot;: destination}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}} ]} }; } else if (n === 1) { const name = &quot;movePlate-1&quot;; return { &quot;description&quot;: `${name}: transport plate from origin to destination in ${n} step(s)`, &quot;task&quot;: {&quot;movePlate&quot;: movePlateParams}, &quot;preconditions&quot;: [ {&quot;model&quot;: {&quot;labware&quot;: labware, &quot;model&quot;: model}}, // TODO: Superfluous, but maybe check anyway {&quot;location&quot;: {&quot;labware&quot;: labware, &quot;site&quot;: origin}}, // TODO: Superfluous, but maybe check anyway {&quot;siteModel&quot;: {&quot;site&quot;: origin, &quot;siteModel&quot;: &quot;?originModel&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: destination, &quot;siteModel&quot;: &quot;?destinationModel&quot;}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?destinationModel&quot;, &quot;above&quot;: model}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: destination}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: origin}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: destination}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;siteClique&quot;: &quot;?siteClique1&quot;}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}}, {&quot;openAndMovePlate&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;labware&quot;: labware, &quot;model&quot;: model, &quot;origin&quot;: origin, &quot;originModel&quot;: &quot;?originModel&quot;, &quot;destination&quot;: destination, &quot;destinationModel&quot;: &quot;?destinationModel&quot;}} ]} }; } else if (n === 2) { const name = &quot;movePlate-2&quot;; return { &quot;description&quot;: `${name}: transport plate from origin to destination in ${n} step(s)`, &quot;task&quot;: {&quot;movePlate&quot;: movePlateParams}, &quot;preconditions&quot;: [ {&quot;model&quot;: {&quot;labware&quot;: labware, &quot;model&quot;: model}}, // TODO: can handle this in programatically {&quot;location&quot;: {&quot;labware&quot;: labware, &quot;site&quot;: origin}}, // TODO: can handle this in programatically {&quot;siteModel&quot;: {&quot;site&quot;: origin, &quot;siteModel&quot;: &quot;?originModel&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: destination, &quot;siteModel&quot;: &quot;?destinationModel&quot;}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?destinationModel&quot;, &quot;above&quot;: model}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: destination}}, // TODO: Check this programmatically instead of via logic {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: origin}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique2&quot;, &quot;site&quot;: destination}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: &quot;?site2&quot;}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique2&quot;, &quot;site&quot;: &quot;?site2&quot;}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site2&quot;, &quot;thing2&quot;: origin}}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site2&quot;, &quot;thing2&quot;: destination}}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;siteClique&quot;: &quot;?siteClique1&quot;}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[1], &quot;equipment&quot;: equipments[1], &quot;program&quot;: programs[1], &quot;siteClique&quot;: &quot;?siteClique2&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: &quot;?site2&quot;, &quot;siteModel&quot;: &quot;?site2Model&quot;}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?site2Model&quot;, &quot;above&quot;: model}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: &quot;?site2&quot;}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}}, {&quot;openAndMovePlate&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;labware&quot;: labware, &quot;model&quot;: model, &quot;origin&quot;: origin, &quot;originModel&quot;: &quot;?originModel&quot;, &quot;destination&quot;: &quot;?site2&quot;, &quot;destinationModel&quot;: &quot;?site2Model&quot;}}, {&quot;openAndMovePlate&quot;: {&quot;agent&quot;: agents[1], &quot;equipment&quot;: equipments[1], &quot;program&quot;: programs[1], &quot;labware&quot;: labware, &quot;model&quot;: model, &quot;origin&quot;: &quot;?site2&quot;, &quot;originModel&quot;: &quot;?site2Model&quot;, &quot;destination&quot;: destination, &quot;destinationModel&quot;: &quot;?destinationModel&quot;}} ]} }; } else if (n === 3) { const name = &quot;movePlate-3&quot;; return { &quot;description&quot;: `${name}: transport plate from origin to destination in ${n} step(s)`, &quot;task&quot;: {&quot;movePlate&quot;: movePlateParams}, &quot;preconditions&quot;: [ {&quot;model&quot;: {&quot;labware&quot;: labware, &quot;model&quot;: model}}, // TODO: can handle this in programatically {&quot;location&quot;: {&quot;labware&quot;: labware, &quot;site&quot;: origin}}, // TODO: can handle this in programatically {&quot;siteModel&quot;: {&quot;site&quot;: origin, &quot;siteModel&quot;: &quot;?originModel&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: destination, &quot;siteModel&quot;: &quot;?destinationModel&quot;}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?destinationModel&quot;, &quot;above&quot;: model}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: destination}}, // TODO: Check this programmatically instead of via logic {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: origin}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique3&quot;, &quot;site&quot;: destination}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique1&quot;, &quot;site&quot;: &quot;?site2&quot;}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique2&quot;, &quot;site&quot;: &quot;?site2&quot;}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique2&quot;, &quot;site&quot;: &quot;?site3&quot;}}, {&quot;siteCliqueSite&quot;: {&quot;siteClique&quot;: &quot;?siteClique3&quot;, &quot;site&quot;: &quot;?site3&quot;}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site2&quot;, &quot;thing2&quot;: origin}}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site2&quot;, &quot;thing2&quot;: destination}}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site2&quot;, &quot;thing2&quot;: &quot;?site3&quot;}}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site3&quot;, &quot;thing2&quot;: origin}}}, {&quot;not&quot;: {&quot;same&quot;: {&quot;thing1&quot;: &quot;?site3&quot;, &quot;thing2&quot;: destination}}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;siteClique&quot;: &quot;?siteClique1&quot;}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[1], &quot;equipment&quot;: equipments[1], &quot;program&quot;: programs[1], &quot;siteClique&quot;: &quot;?siteClique2&quot;}}, {&quot;transporter.canAgentEquipmentProgramSites&quot;: {&quot;agent&quot;: agents[2], &quot;equipment&quot;: equipments[2], &quot;program&quot;: programs[2], &quot;siteClique&quot;: &quot;?siteClique3&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: &quot;?site2&quot;, &quot;siteModel&quot;: &quot;?site2Model&quot;}}, {&quot;siteModel&quot;: {&quot;site&quot;: &quot;?site3&quot;, &quot;siteModel&quot;: &quot;?site3Model&quot;}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?site2Model&quot;, &quot;above&quot;: model}}, {&quot;stackable&quot;: {&quot;below&quot;: &quot;?site3Model&quot;, &quot;above&quot;: model}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: &quot;?site2&quot;}}, {&quot;siteIsClear&quot;: {&quot;site&quot;: &quot;?site3&quot;}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ {&quot;print&quot;: {&quot;text&quot;: name}}, {&quot;openAndMovePlate&quot;: {&quot;agent&quot;: agents[0], &quot;equipment&quot;: equipments[0], &quot;program&quot;: programs[0], &quot;labware&quot;: labware, &quot;model&quot;: model, &quot;origin&quot;: origin, &quot;originModel&quot;: &quot;?originModel&quot;, &quot;destination&quot;: &quot;?site2&quot;, &quot;destinationModel&quot;: &quot;?site2Model&quot;}}, {&quot;openAndMovePlate&quot;: {&quot;agent&quot;: agents[1], &quot;equipment&quot;: equipments[1], &quot;program&quot;: programs[1], &quot;labware&quot;: labware, &quot;model&quot;: model, &quot;origin&quot;: &quot;?site2&quot;, &quot;originModel&quot;: &quot;?site2Model&quot;, &quot;destination&quot;: &quot;?site3&quot;, &quot;destinationModel&quot;: &quot;?site3Model&quot;}}, {&quot;openAndMovePlate&quot;: {&quot;agent&quot;: agents[2], &quot;equipment&quot;: equipments[2], &quot;program&quot;: programs[2], &quot;labware&quot;: labware, &quot;model&quot;: model, &quot;origin&quot;: &quot;?site3&quot;, &quot;originModel&quot;: &quot;?site3Model&quot;, &quot;destination&quot;: destination, &quot;destinationModel&quot;: &quot;?destinationModel&quot;}} ]} }; } assert(false); } function queryMovePlateMethod(llpl, method, n) { //console.log(&quot;originId: &quot;+originId) const criteria = method.preconditions; const queryAll = {&quot;and&quot;: criteria}; const queryResultsAll = llpl.query(queryAll); return queryResultsAll; } function debugMovePlateMethod(llpl, method, queryResultsAll, n) { const lines = []; const criteria = method.preconditions; //console.log(queryResultsAll.length); if (queryResultsAll.length === 0) { lines.push(`\\nmovePlate-${n} failed:`); // console.log(&quot;debug: &quot;+criteria); // let failures = 0; _.forEach(criteria, criterion =&gt; { // console.log({criterion}) const queryOne = {&quot;and&quot;: [criterion]}; const queryResultOne = llpl.query(queryOne); //console.log(&quot;queryResultOne: &quot;+JSON.stringify(queryResultOne)); if (queryResultOne.length === 0) { // failures++; lines.push(&quot;FAILED: &quot;+JSON.stringify(criterion)); } else { //console.log(&quot;queryResults:\\n&quot;+JSON.stringify(queryResultOne, null, '\\t')); } }); } else { console.log(&quot;found paths: &quot;+queryResultsAll) } return lines.join(&quot;\\n&quot;); } /** * Handlers for {@link transporter} commands. * @static */ var commandHandlers = { /** * Transport a lid from labware to site or from site to labware. * * Handler should return `effects` with the lid's new location * and set or remove labware's `hasLid` property. */ &quot;transporter._moveLidFromContainerToSite&quot;: function(params, parsed, data) { return {effects: { //[`${parsed.objectName.container}.hasLid`]: false, [`${parsed.objectName.object}.location`]: parsed.objectName.destination }}; }, /** * Transport a lid from labware to site or from site to labware. * * Handler should return `effects` with the lid's new location * and set or remove labware's `hasLid` property. */ &quot;transporter._moveLidFromSiteToContainer&quot;: function(params, parsed, data) { return {effects: { //[`${parsed.objectName.container}.hasLid`]: false, [`${parsed.objectName.object}.location`]: parsed.objectName.container }}; }, /** * Transport a plate to a destination. * * Handler should return `effects` with the plate's new location. */ &quot;transporter._movePlate&quot;: function(params, parsed, data) { return {effects: { [`${parsed.objectName.object}.location`]: parsed.objectName.destination }}; }, &quot;transporter.moveLidFromContainerToSite&quot;: moveLidFromContainerToSite, &quot;transporter.moveLidFromSiteToContainer&quot;: moveLidFromSiteToContainer, /** * Transport a plate to a destination. */ &quot;transporter.movePlate&quot;: function(params, parsed, data) { //console.log(&quot;transporter.movePlate(&quot;+JSON.stringify(params)+&quot;)&quot;) const transporterLogic = require('./transporterLogic.json'); const keys = [&quot;null&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]; const movePlateParams = makeMovePlateParams(parsed); const shop = require('../HTN/shop.js'); const llpl = require('../HTN/llpl.js').create(); llpl.initializeDatabase(data.predicates); let input0 = data.predicates; let plan; let errorLog = &quot;&quot;; for (let i = 0; i &lt; keys.length; i++) { const key = keys[i]; const method = {method: makeMovePlateMethod(parsed, movePlateParams, i)}; input0 = input0.concat(_.values(transporterLogic[key])); input0 = input0.concat([method]); if (transporterLogic.hasOwnProperty(key)) { llpl.addToDatabase(transporterLogic[key]); } llpl.addToDatabase([method]); // const fs = require('fs'); // fs.writeFileSync(&quot;a.json&quot;, JSON.stringify(llpl.database, null, '\\t')); const queryResultsAll = queryMovePlateMethod(llpl, method.method, i); // If we didn't find a path for this method: if (queryResultsAll.length === 0) { const text = debugMovePlateMethod(llpl, method.method, queryResultsAll, i); errorLog += text; } // If we did find a path: else { // console.log(`${queryResultsAll.length} path(s) found, e.g.: ${JSON.stringify(queryResultsAll[0])}`); const tasks = { &quot;tasks&quot;: { &quot;ordered&quot;: [{ movePlate: movePlateParams }] } }; const input = input0.concat([tasks]); var planner = shop.makePlanner(input); plan = planner.plan(); //console.log(key, plan) if (!_.isEmpty(plan)) { //console.log(&quot;plan found for &quot;+key) //console.log(planner.ppPlan(plan)); } else { console.log(&quot;apparently unable to open some site or something&quot;) } break; } } /* const transporterPredicates = _(transporterLogic).values().map(x =&gt; _.values(x)).flatten().value(); var input0 = [].concat(data.predicates, transporterPredicates, [tasksOrdered]); var input = input0; //console.log(JSON.stringify(input, null, '\\t')); var shop = require('../HTN/shop.js'); var planner = shop.makePlanner(input); var plan = planner.plan(); //console.log(&quot;plan:\\n&quot;+JSON.stringify(plan, null, ' ')); var x = planner.ppPlan(plan); console.log(x); */ if (_.isEmpty(plan)) { console.log(errorLog); /* var agentId = params.agent || &quot;?agent&quot;; var modelId = parsed.value.object.model || &quot;?model&quot;; var originId = parsed.value.object.location || &quot;?site&quot;; debug_movePlate_null(input0, agentId, parsed.objectName.object, modelId, originId, parsed.objectName.destination); debug_movePlate_one(input0, agentId, parsed.objectName.object, modelId, originId, parsed.objectName.destination); for (let i = 0; i &lt;= 3; i++) { const method = makeMovePlateMethod(parsed, movePlateParams, i); debugMovePlateMethod() */ } if (_.isEmpty(plan)) { const x = _.merge({}, {agent: parsed.objectName.agent, equipment: parsed.objectName.equipment, program: parsed.objectName.program || parsed.value.program, model: parsed.value.object.model, origin: parsed.value.object.location, destination: parsed.objectName.destination}); //console.log(&quot;transporter.movePlate: &quot;+JSON.stringify(parsed, null, '\\t')) return {errors: [&quot;unable to find a transportation path for `&quot;+parsed.objectName.object+&quot;` from `&quot;+misc.findObjectsValue(parsed.objectName.object+&quot;.location&quot;, data.objects)+&quot;` to `&quot;+parsed.objectName.destination+&quot;`&quot;, JSON.stringify(x)]}; } var tasks = planner.listAndOrderTasks(plan, true); // console.log(&quot;Tasks:&quot;) // console.log(JSON.stringify(tasks, null, ' ')); var cmdList = _(tasks).map(function(task) { return _(task).map(function(taskParams, taskName) { return (data.planHandlers.hasOwnProperty(taskName)) ? data.planHandlers[taskName](taskParams, params, data) : []; }).flatten().value(); }).flatten().value(); // console.log(&quot;cmdList:&quot;) // console.log(JSON.stringify(cmdList, null, ' ')); // Create the expansion object var expansion = {}; var i = 1; _.forEach(cmdList, function(cmd) { expansion[i.toString()] = cmd; i += 1; }); // console.log({expansion}) // Create the effets object var effects = {}; effects[`${parsed.objectName.object}.location`] = parsed.objectName.destination; return { expansion: expansion, effects: effects }; }, &quot;transporter.doThenRestoreLocation&quot;: function(params, parsed, data) { //console.log(&quot;transporter.doThenRestoreLocation(&quot;+JSON.stringify(parsed, null, '\\t')+&quot;)&quot;); const expansion = _.cloneDeep(_.values(parsed.value.steps)); // console.log(&quot;objects: &quot;+JSON.stringify(parsed.value.objects)) for (let i = 0; i &lt; parsed.value.objects.length; i++) { const labwareName = parsed.objectName[`objects.${i}`]; const command = _.merge({}, { command: &quot;transporter.movePlate&quot;, agent: parsed.objectName.agent, equipment: parsed.objectName.equipment, program: parsed.value.program, object: labwareName, destination: parsed.value.objects[i].location }); expansion.push(command); } return { expansion }; } }; /** * Plan handler to allow other modules to use `transporter._movePlate` as a * planning action. * @static */ var planHandlers = { &quot;transporter._movePlate&quot;: function(params, parentParams, data) { return [{ command: &quot;transporter._movePlate&quot;, agent: params.agent, equipment: params.equipment, program: params.program, object: params.labware, destination: params.destination }]; }, &quot;transporter._moveLidFromContainerToSite&quot;: function(params, parentParams, data) { return [{ command: &quot;transporter._moveLidFromContainerToSite&quot;, agent: params.agent, equipment: params.equipment, program: params.program, object: params.lid, container: params.container, destination: params.destination }]; }, &quot;transporter._moveLidFromSiteToContainer&quot;: function(params, parentParams, data) { return [{ command: &quot;transporter._moveLidFromSiteToContainer&quot;, agent: params.agent, equipment: params.equipment, program: params.program, object: params.lid, origin: params.origin, container: params.container }]; }, }; module.exports = { roboliq: &quot;v1&quot;, objectToPredicateConverters: objectToPredicateConverters, schemas: yaml.load(__dirname+'/../schemas/transporter.yaml'), commandHandlers: commandHandlers, planHandlers: planHandlers }; × Search results Close "},"config_roboliq.js.html":{"id":"config_roboliq.js.html","title":"Source: config/roboliq.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: config/roboliq.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Roboliq's default configuration. * @module config/roboliq */ var _ = require('lodash'); import yaml from 'yamljs'; var predicates = [ // // Rules // // same: Two things are the same if they unify. { &quot;&lt;--&quot;: { &quot;same&quot;: { &quot;thing1&quot;: &quot;?thing&quot;, &quot;thing2&quot;: &quot;?thing&quot; } } }, // labwareHasNoLid: a labware has no lid if no labware is on top of it { &quot;&lt;--&quot;: { &quot;labwareHasNoLid&quot;: { &quot;labware&quot;: &quot;?labware&quot; }, &quot;and&quot;: [{ &quot;not&quot;: { &quot;location&quot;: { &quot;labware&quot;: &quot;?lid&quot;, &quot;site&quot;: &quot;?labware&quot; } } }] } }, // siteIsClear: a site is clear if no labware is on it { &quot;&lt;--&quot;: { &quot;siteIsClear&quot;: { &quot;site&quot;: &quot;?site&quot; }, &quot;and&quot;: [{ &quot;not&quot;: { &quot;location&quot;: { &quot;labware&quot;: &quot;?labware&quot;, &quot;site&quot;: &quot;?site&quot; } } }] } }, // siteIsOpen: a site is open if it's not closed (FUTURE: and if it's not locked) { &quot;&lt;--&quot;: { &quot;siteIsOpen&quot;: { &quot;site&quot;: &quot;?site&quot; }, &quot;and&quot;: [{ &quot;not&quot;: { &quot;siteIsClosed&quot;: { &quot;site&quot;: &quot;?site&quot; } } }] } }, // member of list (see HTN-orig/lists.js) {&quot;&lt;--&quot;: {&quot;member&quot;: {&quot;target&quot;: &quot;?target&quot;, &quot;list&quot;: {&quot;cons&quot;: {&quot;first&quot;: &quot;?target&quot;, &quot;rest&quot;: &quot;?restOfList&quot;}}}}}, {&quot;&lt;--&quot;: {&quot;member&quot;: {&quot;target&quot;: &quot;?target&quot;, &quot;list&quot;: {&quot;cons&quot;: {&quot;first&quot;: &quot;?firstOfList&quot;, &quot;rest&quot;: &quot;?restOfList&quot;}}}, &quot;and&quot;: [{&quot;member&quot;: {&quot;target&quot;: &quot;?target&quot;, &quot;list&quot;: &quot;?restOfList&quot;}}]}}, {&quot;method&quot;: {&quot;description&quot;: &quot;generic.openSite-null: null-operation for opening an already open site&quot;, &quot;task&quot;: {&quot;generic.openSite&quot;: {&quot;site&quot;: &quot;?site&quot;}}, &quot;preconditions&quot;: [ {&quot;siteIsOpen&quot;: {&quot;site&quot;: &quot;?site&quot;}} ], &quot;subtasks&quot;: {&quot;ordered&quot;: [ //{&quot;print&quot;: {&quot;text&quot;: &quot;generic.openSite-null&quot;}} ]} }}, ]; var objectToPredicateConverters = { Lid: function(name, object) { return [ {&quot;isLabware&quot;: {&quot;labware&quot;: name}}, {&quot;isLid&quot;: {&quot;labware&quot;: name}}, {&quot;model&quot;: {&quot;labware&quot;: name, &quot;model&quot;: object.model}}, {&quot;location&quot;: {&quot;labware&quot;: name, &quot;site&quot;: object.location}} ]; }, LidModel: function(name, object) { return [{ &quot;isModel&quot;: { &quot;model&quot;: name } }]; }, &quot;Plate&quot;: function(name, object) { var value = [ { &quot;isLabware&quot;: { &quot;labware&quot;: name } }, { &quot;isPlate&quot;: { &quot;labware&quot;: name } }, { &quot;model&quot;: { &quot;labware&quot;: name, &quot;model&quot;: object.model } }, { &quot;location&quot;: { &quot;labware&quot;: name, &quot;site&quot;: object.location } } ]; if (object.sealed) { value.push({ &quot;plateIsSealed&quot;: { &quot;labware&quot;: name } }); } return value; }, &quot;PlateModel&quot;: function(name, object) { return [{ &quot;isModel&quot;: { &quot;model&quot;: name } }]; }, &quot;Site&quot;: function(name, object) { return _.compact([ {&quot;isSite&quot;: {&quot;model&quot;: name}}, (object.closed) ? {&quot;siteIsClosed&quot;: {&quot;site&quot;: name}} : null, ]); }, }; var planHandlers = { &quot;trace&quot;: function() { return []; } }; module.exports = { roboliq: &quot;v1&quot;, imports: [ '../commands/data.js', '../commands/system.js', // Equipment '../commands/equipment.js', '../commands/absorbanceReader.js', '../commands/centrifuge.js', '../commands/fluorescenceReader.js', '../commands/incubator.js', '../commands/pipetter.js', '../commands/scale.js', '../commands/sealer.js', '../commands/shaker.js', '../commands/timer.js', '../commands/transporter.js', ], predicates: predicates, objectToPredicateConverters: objectToPredicateConverters, schemas: yaml.load(__dirname+'/../schemas/roboliq.yaml'), planHandlers: planHandlers, directiveHandlers: require('./roboliqDirectiveHandlers.js'), }; × Search results Close "},"config_roboliqDirectiveHandlers.js.html":{"id":"config_roboliqDirectiveHandlers.js.html","title":"Source: config/roboliqDirectiveHandlers.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: config/roboliqDirectiveHandlers.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Roboliq's default directives. * @module config/roboliqDirectiveHandlers */ var _ = require('lodash'); var assert = require('assert'); var math = require('mathjs'); var random = require('random-js'); import commandHelper from '../commandHelper.js'; var Design = require('../design.js'); var expect = require('../expect.js'); var misc = require('../misc.js'); var wellsParser = require('../parsers/wellsParser.js'); // TODO: analyze wells string (call wellsParser) // TODO: zipMerge to merge destinations into mix items (but error somehow if not enough destinations) // TODO: extractKey list of destinations from items // TODO: extractValue list of destinations from items // TODO: extract unique list of destinations, make it a well string? function handleDirective(spec, data) { return misc.handleDirective(spec, data); } function directive_createWellAssignments(spec, data) { return expect.try(&quot;#createWellAssignments&quot;, () =&gt; { const parsed = commandHelper.parseParams(spec, data, { properties: { list: {type: &quot;array&quot;}, wells: {type: &quot;Wells&quot;} }, required: [&quot;list&quot;, &quot;wells&quot;] }); return _.take(parsed.value.wells, parsed.value.list.length); }); } function directive_data(spec, data) { // console.log(&quot;directive_data: &quot;+JSON.stringify(spec, null, '\\t')) // console.log(&quot;DATA: &quot;+JSON.stringify(data.objects.DATA, null, '\\t')) return expect.try(&quot;data()&quot;, () =&gt; { const updatedSCOPEDATA = commandHelper.updateSCOPEDATA({data: spec}, data); // console.log({updateDATA: updatedSCOPEDATA.DATA}) let result = Design.query(updatedSCOPEDATA.DATA, spec); // console.log(&quot;result0: &quot;+JSON.stringify(result)) if (spec.templateGroup) { result = _.map(result, DATA =&gt; { const SCOPE = _.merge({}, updatedSCOPEDATA.SCOPE, Design.getCommonValues(DATA)); return commandHelper.substituteDeep(spec.templateGroup, data, SCOPE, DATA); }); // console.log(&quot;result1: &quot;+JSON.stringify(result)) } else if (spec.hasOwnProperty(&quot;map&quot;) || spec.template) { const template = _.get(spec, &quot;map&quot;, spec.template); // console.log(&quot;result: &quot;+JSON.stringify(result, null, '\\t')) result = _.map(result, DATA =&gt; _.map(DATA, row =&gt; { const SCOPE = _.defaults({}, row, updatedSCOPEDATA.SCOPE); // console.log(&quot;row: &quot;+JSON.stringify(row, null, '\\t')) // console.log(&quot;SCOPE: &quot;); console.log(SCOPE); return commandHelper.substituteDeep(template, data, SCOPE, undefined); })); // console.log(&quot;result1: &quot;+JSON.stringify(result)) } // deprecated, use `map` if (spec.value) { result = _.map(result, DATA =&gt; _.map(DATA, row =&gt; { if (_.startsWith(spec.value, &quot;$`&quot;)) { const SCOPE = _.merge({}, updatedSCOPEDATA.SCOPE, row); return commandHelper.substituteDeep(spec.value, data, SCOPE, DATA); } else { return row[spec.value]; } })); // console.log(&quot;result1: &quot;+JSON.stringify(result)) } if (spec.hasOwnProperty(&quot;summarize&quot;)) { // console.log(&quot;result: &quot;+JSON.stringify(result, null, '\\t')) result = _.map(result, DATA =&gt; { const SCOPE = _.clone(updatedSCOPEDATA.SCOPE); const columns = getColumns(DATA); _.forEach(columns, key =&gt; { SCOPE[key] = _.map(DATA, key); }); // console.log(SCOPE); // console.log(&quot;SCOPE: &quot;+JSON.stringify(SCOPE, null, '\\t')) return commandHelper.substituteDeep(spec.summarize, data, SCOPE, DATA, false); }); // console.log(&quot;result1: &quot;+JSON.stringify(result)) } result = (spec.groupBy) ? result : _.flatten(result); // console.log(&quot;result2: &quot;+JSON.stringify(result)) if (spec.flatten) { result = _.flatten(result); // console.log(&quot;result3: &quot;+JSON.stringify(result)) } if (spec.head) { result = _.head(result); // console.log(&quot;result4: &quot;+JSON.stringify(result)) } else if (spec.unique) { result = _.uniq(result); } if (spec.join) { result = result.join(spec.join); // console.log(&quot;result5: &quot;+JSON.stringify(result)) } if (spec.orderBy) { result = _.orderBy(result, spec.orderBy); } if (spec.reverse) { result = _.reverse(result); } // console.log(&quot;result: &quot;+JSON.stringify(result, null, '\\t')) return result; }); } function getColumns(DATA) { // Get column names const columnMap = {}; _.forEach(DATA, row =&gt; _.forEach(_.keys(row), key =&gt; { columnMap[key] = true; } )); const columns = _.keys(columnMap); // console.log({columns}) return columns; } function directive_destinationWells(spec, data) { expect.truthy({}, _.isString(spec), &quot;#destinationWells: expected string, received &quot;+spec); return directive_wells(spec, data); } function directive_for(spec, data) { // console.log({spec}) expect.paramsRequired(spec, ['factors', 'output']); var views = directive_factorialCols(spec.factors, data); //console.log(&quot;views:&quot;, views); return _.map(views, function(view) { var rendered = misc.renderTemplate(spec.output, view, data); //console.log(&quot;rendered:&quot;, rendered); var rendered2 = misc.handleDirectiveDeep(rendered, data); //console.log(&quot;rendered2:&quot;, rendered2); return rendered2; }); } function directive_factorialArrays(spec, data) { //console.log(&quot;genList:&quot;, spec); assert(_.isArray(spec)); var lists = _.map(spec, function(elem) { return handleDirective(elem, data); }); return combineLists(lists); } function combineLists(elem) { //console.log(&quot;combineLists: &quot;, elem); var list = []; if (_.isArray(elem) &amp;&amp; !_.isEmpty(elem)) { list = elem[0]; if (!_.isArray(list)) list = [list]; for (var i = 1; i &lt; elem.length; i++) { //console.log(&quot;list@&quot;+i, list); list = _(list).map(function(x) { //console.log(&quot;x&quot;, x); if (!_.isArray(x)) x = [x]; return elem[i].map(function(y) { return x.concat(y); }); }).flatten().value(); } } return list; } function directive_factorialCols(spec, data) { //console.log(&quot;genFactorialCols:&quot;, spec); assert(_.isPlainObject(spec) || _.isArray(spec)); var variables = (_.isPlainObject(spec)) ? _.toPairs(spec) : _(spec).map(_.toPairs).flatten().value(); var lists = _.map(variables, function(pair) { var key = pair[0]; var values = pair[1]; if (!_.isArray(values)) { var obj1 = {}; obj1[key] = values; return [obj1]; } else { return values.map(function(value) { var obj1 = {}; obj1[key] = value; return obj1; }); } }) var result = directive_factorialMerge(lists, data); //console.log(&quot;genFactorialCols result:&quot;, result); return result; } function directive_gradient(data, data_) { if (!_.isArray(data)) data = [data]; var list = []; _.forEach(data, function(data) { assert(data.volume); assert(data.count); assert(data.count &gt;= 2); var decimals = _.isNumber(data.decimals) ? data.decimals : 2; //console.log(&quot;decimals:&quot;, decimals); var volumeTotal = math.round(math.eval(data.volume).toNumber('ul'), decimals); // Pick volumes var volumes = Array(data.count); for (var i = 0; i &lt; data.count / 2; i++) { volumes[i] = math.round(volumeTotal * i / (data.count - 1), decimals); volumes[data.count - i - 1] = math.round(volumeTotal - volumes[i], decimals); } if ((data.count % 2) === 1) volumes[Math.floor(data.count / 2)] = math.round(volumeTotal / 2, decimals); //console.log(&quot;volumes:&quot;, volumes); // Create items for (var i = 0; i &lt; data.count; i++) { var volume2 = volumes[i]; var volume1 = math.round(volumeTotal - volume2, decimals); var l = []; l.push((volume1 &gt; 0) ? {source: data.source1, volume: math.unit(volume1, 'ul').format({precision: 14})} : null); l.push((volume2 &gt; 0) ? {source: data.source2, volume: math.unit(volume2, 'ul').format({precision: 14})} : null); //if (l.length &gt; 0) list.push(l); } }); return list; } /** * Merge an array of objects, or combinatorially merge an array of arrays of objects. * * @param {Array} spec The array of objects or arrays of objects to merge. * @return {Object|Array} The object or array resulting from combinatorial merging. */ function directive_factorialMerge(spec, data) { //console.log(&quot;#merge&quot;, spec); if (_.isEmpty(spec)) return spec; //console.log(&quot;genMerge lists:&quot;, lists); var result = genMerge2(spec, data, {}, 0, []); // If all elements were objects rather than arrays, return an object: /*if (_.every(spec, _.isPlainObject)) { assert(result.length == 1); result = result[0]; }*/ //console.log(&quot;genMerge result:&quot;, result); return result; } /** * Helper function for factorial merging of arrays of objects. * For example, the first element of the first array is merged with the first element of the second array, * added to the `acc` list, then the first element of the first array is merged with the second element of the second array, and so on. * @param {array} spec array of objects, may be nested arbitrarily deep, i.e. array of arrays of objects * @param {object} data [description] * @param {object} obj0 accumulated result of the current merge, will be added to `acc` once the end of the `spec` list is reached * @param {number} index index of current item in `spec` * @param {array} acc accumulated list of merged objects * @return {array} Returns a factorial list of merged objects. */ function genMerge2(spec, data, obj0, index, acc) { //console.log(&quot;genMerge2&quot;, spec, obj0, index, acc); assert(_.isArray(spec)); var list = _.map(spec, function(elem) { if (!_.isArray(elem)) elem = [elem]; return handleDirective(elem, data); }); if (index &gt;= spec.length) { acc.push(obj0); return acc; } var elem = spec[index]; if (!_.isArray(elem)) elem = [elem]; for (var j = 0; j &lt; elem.length; j++) { var elem2 = handleDirective(elem[j], data); //console.log(&quot;elem2:&quot;, elem2) if (_.isArray(elem2)) { genMerge2(elem2, data, obj1, 0, acc); } else if (elem2 !== null) { assert(_.isPlainObject(elem2)); var obj1 = _.merge({}, obj0, elem[j]); genMerge2(list, data, obj1, index + 1, acc); } } return acc; } //function expandArrays function directive_factorialMixtures(spec, data) { // Get mixutre items var items; if (_.isArray(spec)) items = spec; else { expect.paramsRequired(spec, ['items']); items = misc.getVariableValue(spec.items, data.objects); } assert(_.isArray(items)); var items2 = _.map(items, function(item) { return (_.isPlainObject(item)) ? directive_factorialCols(item, data) : item; }); var combined = combineLists(items2); if (spec.replicates &amp;&amp; spec.replicates &gt; 1) { combined = directive_replicate({count: spec.replicates, value: combined}, data); } return combined; } // function directive_include_jsonl(spec, data) { // assert(_.isString(spec)); // const filename = spec; // console.log(&quot;files: &quot;+JSON.stringify(Object.keys(data))) // assert(data.files.hasOwnProperty(filename)); // const filedata = data.files[spec]; // console.log(JSON.stringify(filename)); // assert(false); // } function directive_length(spec, data) { if (_.isArray(spec)) return spec.length; else if (_.isString(spec)) { var value = misc.getObjectsValue(spec, data.objects) if (_.isPlainObject(value) &amp;&amp; value.hasOwnProperty('value')) value = value.value; expect.truthy({}, _.isArray(value), '#length expected an array, received: '+spec); return value.length; } else { expect.truthy({}, false, '#length expected an array, received: '+spec); } } function directive_merge(spec, data) { assert(_.isArray(spec)); var list = _.map(spec, function(x) { return handleDirective(x, data); }); return _.merge.apply(null, [{}].concat(list)); } function directive_pipetteMixtures(spec, data) { // Get mixutre items var items; if (_.isArray(spec)) items = spec; else { expect.paramsRequired(spec, ['items']); items = misc.getVariableValue(spec.items, data.objects); } assert(_.isArray(items)); var items2 = _.map(items, function(item) { return (_.isPlainObject(item)) ? directive_factorialCols(item, data) : item; }); var combined = combineLists(items2); if (spec.replicates &amp;&amp; spec.replicates &gt; 1) { combined = directive_replicate({count: spec.replicates, value: combined}, data); } //console.log(1) //console.log(JSON.stringify(combined, null, '\\t')) // Check and set volumes const volumePerMixture = (spec.volume) ? math.eval(spec.volume) : undefined; //console.log({volumePerMixture}) //console.log({combined}) combined.forEach(l =&gt; { let volumeTotal = math.unit(0, 'l'); let missingVolumeIndex = -1; //console.log({l}) // Find total volume of components and whether any components are missing the volume parameter _.forEach(l, (x, i) =&gt; { //console.log({x, i, and: x.hasOwnProperty('volume')}) if (x) { if (!x.hasOwnProperty('volume')) { assert(volumePerMixture, &quot;missing volume parameter: &quot;+JSON.stringify(x)); assert(missingVolumeIndex &lt; 0, &quot;only one mixture element may omit the volume parameter: &quot;+JSON.stringify(l)); missingVolumeIndex = i; //console.log({missingVolumeIndex}) } else { volumeTotal = math.add(volumeTotal, math.eval(x.volume)); } } }); // If one of the components needs to have its volume set: if (missingVolumeIndex &gt;= 0) { assert(volumePerMixture); //console.log({volumePerMixture, volumeTotal, subtract: math.subtract(volumePerMixture, volumeTotal).format({precision: 10})}) l[missingVolumeIndex] = _.merge({}, l[missingVolumeIndex], { volume: math.subtract(volumePerMixture, volumeTotal).format({precision: 13}) }); } else if (!_.isUndefined(volumePerMixture)) { const t1 = volumePerMixture.format({precision: 14}); const t2 = volumeTotal.format({precision: 14}); if (t1 !== t2) { console.log(&quot;WARNING: volume in mixture should sum to &quot;+t1+&quot; rather than &quot;+t2+&quot;: &quot;+JSON.stringify(l)); } } }); //console.log(2) //console.log(JSON.stringify(combined, null, '\\t')) _.forEach(spec.transformations || [], t =&gt; { if (t.name === 'shuffle') { var mt = random.engines.mt19937(); assert(_.isNumber(t.seed), &quot;`shuffle` requires a numeric `seed` paramter&quot;); mt.seed(t.seed); random.shuffle(mt, combined); } }); //console.log(3) //console.log(JSON.stringify(combined, null, '\\t')) _.forEach(spec.transformationsPerWell || [], t =&gt; { if (t.name === 'sortByVolumeMax') { combined = _.map(combined, l =&gt; { const offset = 0; const count = t.count || l.length - offset; return _.take(l, offset) .concat(_.sortBy(_.take(l, count), x =&gt; -math.eval(x.volume).toNumber('l'))) .concat(_.drop(l, offset + count)); }); } }); //console.log(4) //console.log(JSON.stringify(combined, null, '\\t')) return combined; } function directive_replaceLabware(spec, data) { expect.paramsRequired(spec, ['list', 'new']); var list = misc.getVariableValue(spec.list, data.objects); //if (!_.isArray(list)) console.log(&quot;list:&quot;, list) assert(_.isArray(list), &quot;expected a list, received: &quot;+JSON.stringify(list)); assert(_.isString(spec.new)); var l1 = _.flatten(_.map(list, function(s) { var l2 = wellsParser.parse(s); return _.map(l2, function(x) { //console.log(&quot;s:&quot;, s, &quot;x:&quot;, x); //console.log(x.hasOwnProperty('labware'), !spec.old, x.labware === spec.old); if (x.hasOwnProperty('labware') &amp;&amp; (!spec.old || x.labware === spec.old)) { x.labware = spec.new; } return x; }); })); var l2 = wellsParser.processParserResult(l1, data.objects); return l2; } function directive_replicate(spec) { assert(_.isPlainObject(spec)); assert(_.isNumber(spec.count)); assert(spec.value); var depth = spec.depth || 0; assert(depth &gt;= 0); var step = function(x, count, depth) { //console.log(&quot;step:&quot;, x, count, depth); if (_.isArray(x) &amp;&amp; depth &gt; 0) { if (depth === 1) return _.flatten(_.map(x, function(y) { return step(y, count, depth - 1); })); else return _.map(x, function(y) { return step(y, count, depth - 1); }); } else { return _.flatten(_.fill(Array(count), x)); } } return step(spec.value, spec.count, depth); } function directive_tableCols(table, data) { //console.log(&quot;genTableCols:&quot;, table) assert(_.isPlainObject(table)); assert(!_.isEmpty(table)); var ns1 = _.uniq(_.map(table, function(x) { return _.isArray(x) ? x.length : 1; })); var ns = _.filter(ns1, function(n) { return n &gt; 1; }); assert(ns1.length &gt; 0); assert(ns.length &lt;= 1); var n = (ns.length === 1) ? ns[0] : 1; var list = Array(n); for (var i = 0; i &lt; n; i++) { list[i] = _.mapValues(table, function(value) { return (_.isArray(value)) ? value[i] : value; }); } return list; } function directive_tableRows(table, data) { //console.log(&quot;genTableRows:&quot;, table) assert(_.isArray(table)); var list = []; var names = []; var defaults = {}; _.forEach(table, function(row) { // Object are for default values that will apply to the following rows if (_.isArray(row)) { // First array in table is the column names if (names.length === 0) { names = row; } else { assert(row.length === names.length); var obj = _.clone(defaults); for (var i = 0; i &lt; names.length; i++) { obj[names[i]] = row[i]; } list.push(obj); } } else { assert(_.isPlainObject(row)); defaults = _.merge(defaults, row); //console.log(&quot;defaults:&quot;, defaults) } }); return list; } function directive_take(spec, data) { //console.log(&quot;#take:&quot;, spec); expect.paramsRequired(spec, ['list', 'count']); var list = misc.getVariableValue(spec.list, data.objects); var count = misc.getVariableValue(spec.count, data.objects); return _.take(list, count); } function directive_wells(spec, data) { return wellsParser.parse(spec, data.objects); } function directive_zipMerge(spec, data) { assert(_.isArray(spec)); if (spec.length &lt;= 1) return spec; //console.log('spec:', spec); var zipped = _.zip.apply(null, spec); //console.log('zipped:', zipped); var merged = _.map(zipped, function(l) { return _.merge.apply(null, [{}].concat(l)); }); //console.log('spec:', spec); return merged; } // // from design.js // function directive_allocateWells(spec, data) { assert(spec.N, &quot;You must specify a positive value for parameter `N` in `allocateWells()`&quot;) // console.log(&quot;directive_allocateWells: &quot;+JSON.stringify(spec)) const design = { design: { &quot;.*&quot;: spec.N, &quot;x=allocateWells&quot;: spec } }; const table = Design.flattenDesign(design); return _.map(table, &quot;x&quot;); } module.exports = { &quot;createPipetteMixtureList&quot;: directive_pipetteMixtures, &quot;createWellAssignments&quot;: directive_createWellAssignments, &quot;data&quot;: directive_data, &quot;destinationWells&quot;: directive_destinationWells, &quot;factorialArrays&quot;: directive_factorialArrays, &quot;factorialCols&quot;: directive_factorialCols, &quot;factorialMerge&quot;: directive_factorialMerge, &quot;factorialMixtures&quot;: directive_factorialMixtures, &quot;for&quot;: directive_for, &quot;gradient&quot;: directive_gradient, // &quot;include_jsonl&quot;: directive_include_jsonl, &quot;length&quot;: directive_length, &quot;merge&quot;: directive_merge, &quot;replaceLabware&quot;: directive_replaceLabware, &quot;replicate&quot;: directive_replicate, &quot;tableCols&quot;: directive_tableCols, &quot;tableRows&quot;: directive_tableRows, &quot;take&quot;: directive_take, //&quot;#wells&quot;: genWells, &quot;undefined&quot;: function() { return undefined; }, &quot;zipMerge&quot;: directive_zipMerge, // From design.js: &quot;allocateWells&quot;: directive_allocateWells, }; × Search results Close "},"design.js.html":{"id":"design.js.html","title":"Source: design.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: design.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ 'use babel'; /** * Functions for processing design specifications. * In particular, it can take concise design specifications and expand them * into a long table of factor values. * @module */ import _ from 'lodash'; import assert from 'assert'; // import Immutable, {Map, fromJS} from 'immutable'; import math from 'mathjs'; import naturalSort from 'javascript-natural-sort'; import Random from 'random-js'; import stableSort from 'stable'; //import yaml from 'yamljs'; import wellsParser from './parsers/wellsParser.js'; const DEBUG = false; //import {locationRowColToText} from './parsers/wellsParser.js'; // FIXME: HACK: this function is included here temporarily, to make usage in react component easier for the moment function locationRowColToText(row, col) { var colText = col.toString(); if (colText.length == 1) colText = &quot;0&quot;+colText; return String.fromCharCode(&quot;A&quot;.charCodeAt(0) + row - 1) + colText; } /** * Print a text representation of the table * @param {array} rows - array of rows * @param {Boolean} [hideRedundancies] - suppress printing of values that haven't changed from the previous row */ export function printRows(rows, hideRedundancies = false) { const data = _.flattenDeep(rows); // Get column names const columnMap = {}; _.forEach(data, row =&gt; _.forEach(_.keys(row), key =&gt; { columnMap[key] = true; } )); const columns = _.keys(columnMap); // console.log({columns}) // Convert data to array of lines (which are arrays of columns) const lines = []; _.forEach(data, group =&gt; { if (!_.isArray(group)) { group = [group]; } else { lines.push([&quot;---&quot;]); } _.forEach(group, row =&gt; { // console.log(JSON.stringify(row)) const line = _.map(columns, key =&gt; { const x1 = _.get(row, key, &quot;&quot;); const x2 = (_.isNull(x1)) ? &quot;&quot; : x1; return x2.toString(); }); lines.push(line); }); }); // Calculate column widths const widths = _.map(columns, key =&gt; key.length); // console.log({widths}) _.forEach(lines, line =&gt; { _.forEach(line, (s, i) =&gt; { if (!_.isEmpty(s)) widths[i] = Math.max(widths[i], s.length); }); }); // console.log({widths}) console.log(columns.map((s, i) =&gt; _.padEnd(s, widths[i])).join(&quot; &quot;)); console.log(columns.map((s, i) =&gt; _.repeat(&quot;=&quot;, widths[i])).join(&quot; &quot;)); let linePrev; _.forEach(lines, line =&gt; { const s = line.map((s, i) =&gt; { const s2 = (s === &quot;&quot;) ? &quot;-&quot; : (hideRedundancies &amp;&amp; linePrev &amp;&amp; s === linePrev[i]) ? &quot;&quot; : s; return _.padEnd(s2, widths[i]); }).join(&quot; &quot;); console.log(s); linePrev = line; }); console.log(columns.map((s, i) =&gt; _.repeat(&quot;=&quot;, widths[i])).join(&quot; &quot;)); } /** * Print a TAB-formatted representation of the table * @param {array} rows - array of rows */ export function printTAB(rows) { const hideRedundancies = false; const data = _.flattenDeep(rows); // Get column names const columnMap = {}; _.forEach(data, row =&gt; _.forEach(_.keys(row), key =&gt; { columnMap[key] = true; } )); const columns = _.keys(columnMap); // console.log({columns}) // Convert data to array of lines (which are arrays of columns) const lines = []; _.forEach(data, group =&gt; { if (!_.isArray(group)) { group = [group]; } else { lines.push([&quot;---&quot;]); } _.forEach(group, row =&gt; { // console.log(JSON.stringify(row)) const line = _.map(columns, key =&gt; { const x1 = _.get(row, key, &quot;&quot;); const x2 = (_.isNull(x1)) ? &quot;&quot; : x1; return x2.toString(); }); lines.push(line); }); }); console.log(columns.join(&quot;\\t&quot;)); _.forEach(lines, line =&gt; { const s = line.join(&quot;\\t&quot;); console.log(s); }); } /** * Print a markdown pipe table * @param {array} rows - array of rows */ export function printMarkdown(rows) { const hideRedundancies = false; const data = _.flattenDeep(rows); // Get column names const columnMap = {}; _.forEach(data, row =&gt; _.forEach(_.keys(row), key =&gt; { columnMap[key] = true; } )); const columns = _.keys(columnMap); // console.log({columns}) // Convert data to array of lines (which are arrays of columns) const lines = []; _.forEach(data, group =&gt; { if (!_.isArray(group)) { group = [group]; } else { lines.push([&quot;---&quot;]); } _.forEach(group, row =&gt; { // console.log(JSON.stringify(row)) const line = _.map(columns, key =&gt; { const x1 = _.get(row, key, &quot;&quot;); const x2 = (_.isNull(x1)) ? &quot;&quot; : x1; return x2.toString(); }); lines.push(line); }); }); console.log(columns.join(&quot; | &quot;)); console.log(columns.map(s =&gt; &quot;:-----:&quot;).join(&quot; | &quot;)); _.forEach(lines, line =&gt; { const s = line.join(&quot; | &quot;); console.log(s); }); console.log(); } /** * Turn a design specification into a design table. * @param {object} design - the design specification. */ export function flattenDesign(design, randomEngine) { if (_.isEmpty(design)) { return []; } randomEngine = randomEngine || Random.engines.mt19937(); const randomSeed = _.isNumber(design.randomSeed) ? design.randomSeed : 0; randomEngine.seed(randomSeed); let children; if (_.isArray(design.children)) { children = design.children.map(child =&gt; flattenDesign(child, randomEngine)); } else { const conditionsList = _.isArray(design.design) ? design.design : [design.design]; children = conditionsList.map(conditions =&gt; expandConditions(conditions, randomEngine, design.initialRows)); } let rows; if (children.length == 1) { rows = children[0]; } // If there were multiple children, we'll need to join them: either merge columns or concat rows else { // console.log(JSON.stringify(children, null, '\\t')) const joinMethod = design.join || &quot;concat&quot;; if (joinMethod === &quot;merge&quot;) { rows = _.merge.apply(_, [[]].concat(children)); } else { rows = [].concat(...children); } } if (design.where) { rows = filterOnWhere(rows, design.where); } if (design.orderBy) { rows = _.orderBy(rows, design.orderBy); } if (design.select) { rows = rows.map(row =&gt; _.pick(row, design.select)); } return rows; } export function getCommonValues(table) { if (_.isEmpty(table)) return {}; assert(_.isArray(table), `required an array: ${JSON.stringify(table)}`); let common = _.clone(table[0]); for (let i = 1; i &lt; table.length; i++) { // Remove any value from common which aren't shared with this row. _.forEach(table[i], (value, name) =&gt; { if (common.hasOwnProperty(name) &amp;&amp; !_.isEqual(common[name], value)) { delete common[name]; } }); } return common; } export function getCommonValuesNested(nestedRows, rowIndexes, common) { if (_.isEmpty(rowIndexes)) return {}; for (let i = 0; i &lt; rowIndexes.length; i++) { const rowIndex = rowIndexes[i]; const row = nestedRows[rowIndex]; if (_.isArray(row)) { getCommonValuesNested(row, _.range(row.length), common); } else if (_.isUndefined(common)) { common = _.clone(row); } else { // Remove any value from common which aren't shared with this row. _.forEach(row, (value, name) =&gt; { if (common.hasOwnProperty(name) &amp;&amp; !_.isEqual(common[name], value)) { delete common[name]; } }); } } return common; } /** * Is like _.flattenDeep, but it mutates the array in-place. * * @param {array} rows - array to flatten */ export function flattenArrayM(rows) { let i = rows.length; while (i &gt; 0) { i--; const item = rows[i]; if (_.isArray(item)) { // Flatten the sub-array flattenArrayM(item); // Splice the original sub-array back into the parent array rows.splice(i, 1, ...item); } } return rows; } /** * Is like _.flattenDeep, but only for the given rows, and it mutates both the rows array and rowIndexes array in-place. * * @param {array} rows - array to flatten * @param {array} rowIndexes - array of row indexes to flatten * @param {array} [otherRowIndexes] - a second, optional array of row indexes that should have the same modifications made to it as rowIndexes * @param {integer} rowIndexesOffset - index in rowIndexes to start at */ export function flattenArrayAndIndexes(rows, rowIndexes, otherRowIndexes = []) { if (DEBUG) { console.log(`flattenArrayAndIndexes:`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(rows)}`) } let i = 0; while (i &lt; rowIndexes.length) { const rowIndex = rowIndexes[i]; const item = rows[rowIndex]; if (_.isArray(item)) { // Flatten the sub-array flattenArrayM(item); // Splice the original sub-array back into the parent array rows.splice(rowIndex, 1, ...item); // Update rowIndexes for (let j = i + 1; j &lt; rowIndexes.length; j++) { rowIndexes[j] += item.length - 1; } // console.log(` 1: ${rowIndexes.join(&quot;,&quot;)}`) const x = _.range(rowIndex, rowIndex + item.length); // console.log({x}) rowIndexes.splice(i, 1, ...x); // console.log(` 2: ${rowIndexes.join(&quot;,&quot;)}`) for (let m = 0; m &lt; otherRowIndexes.length; m++) { const rowIndexes2 = otherRowIndexes[m]; let k = -1; for (let j = 0; j &lt; rowIndexes2.length; j++) { if (rowIndexes2[j] === rowIndex) { k = j; } else if (rowIndexes2[j] &gt; rowIndex) { rowIndexes2[j] += item.length - 1; } } if (k &gt;= 0) { const x = _.range(rowIndex, rowIndex + item.length); // console.log({x}) rowIndexes2.splice(k, 1, ...x); } // console.log({m, len: otherRowIndexes.length, k}) // console.log(` 3 otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); } i += item.length; } else { i++; } // console.log(` 4 otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); } if (DEBUG) { console.log(&quot; (flattenArrayAndIndexes) otherRowIndexes: &quot;+JSON.stringify(otherRowIndexes)); } } /** * If conditions is an array, then each element will be processed individually and then the results will be merged together. * @param {object|array} conditions - an object of conditions or an array of such objects. * @param {array} table0 - the initial rows to start expanding conditions on (default `[{}]`) */ export function expandConditions(conditions, randomEngine, table0 = [{}]) { // console.log(&quot;expandConditions: &quot;+JSON.stringify(conditions)) const conditionsList = _.isArray(conditions) ? conditions : [conditions]; const conditionsRows = conditionsList.map(conditions =&gt; { const table = _.cloneDeep(table0); expandRowsByObject(table, _.range(0, table.length), [], conditions, randomEngine); flattenArrayM(table); return table; }); let table = (conditionsRows.length == 1) ? conditionsRows[0] : _.merge.apply(_, [[]].concat(conditionsRows)); // should probably be `_.merge([], ...conditionsRows)` return table; } /** * expandRowsByObject: * for each key/value pair, call expandRowsByNamedValue */ function expandRowsByObject(nestedRows, rowIndexes, otherRowIndexes, conditions, randomEngine) { if (DEBUG) { console.log(&quot;expandRowsByObject: &quot;+JSON.stringify(conditions)); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexes: ${rowIndexes}\\n ${JSON.stringify(nestedRows)}`) assertNoDuplicates(otherRowIndexes); } for (let name in conditions) { expandRowsByNamedValue(nestedRows, rowIndexes, otherRowIndexes, name, conditions[name], randomEngine); } } /** * // REQUIRED by: expandRowsByObject * expandRowsByNamedValue: * TODO: turn the name/value into an action in order to allow for more sophisticated expansion * if has star-suffix, call branchRowsByNamedValue * else call assignRowsByNamedValue */ export function expandRowsByNamedValue(nestedRows, rowIndexes, otherRowIndexes, name, value, randomEngine) { if (DEBUG) { console.log(`expandRowsByNamedValue: ${name}, ${JSON.stringify(value)}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(nestedRows)}`) assertNoDuplicates(otherRowIndexes); assertNoDuplicates(otherRowIndexes.concat([rowIndexes])); } // If an action is specified using the &quot;=&quot; symbol: const iEquals = name.indexOf(&quot;=&quot;); if (iEquals &gt;= 0) { // Need to flatten the rows in case the action uses groupBy or sameBy flattenArrayAndIndexes(nestedRows, rowIndexes, otherRowIndexes); // console.log(` 'otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); // console.log(` 'rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(nestedRows)}`) const actionType = name.substr(iEquals + 1) || &quot;assign&quot;; const actionHandler = actionHandlers[actionType]; assert(actionHandler, `unknown action type: ${actionType} in ${name}`) name = name.substr(0, iEquals); const result = actionHandler(nestedRows, rowIndexes, otherRowIndexes, name, value, randomEngine); // If no result was returned, the action handled modified the rows directly: if (_.isUndefined(result)) { return; } // Otherwise, continue processing using the action's results else { value = result; } } const starIndex = name.indexOf(&quot;*&quot;); if (starIndex &gt;= 0) { // Remove the branching suffix from the name name = name.substr(0, starIndex); // If the name is empty, automatically pick a dummy name that will be omitted if (_.isEmpty(name)) { name = &quot;.HIDDEN&quot;; } // If the branching value is just a number, then assume it means the number of replicates if (_.isNumber(value)) { value = _.range(1, value + 1); } // console.log({loc: &quot;A&quot;, rowIndexes, nestedRows}) branchRowsByNamedValue(nestedRows, rowIndexes, otherRowIndexes, name, value, randomEngine); // console.log(&quot;B&quot;) } else { assignRowsByNamedValue(nestedRows, rowIndexes, otherRowIndexes, name, value, randomEngine, true); } } /* * // REQUIRED by: expandRowsByNamedValue, branchRowsByNamedValue * assignRowsByNamedValue: (REQUIRED FOR ASSIGNING ARRAY TO ROWS) * if value is array: * for i in count: * rowIndex = rowIndexes[i] * assignRowByNamedKeyItem(nestedRows, rowIndex, name, i+1, value[i]) * else if value is object: * keys = _.keys(value) * for each i in keys.length: * key = keys[i] * item = value[key] * assignRowByNamedKeyItem(nestedRows, rowIndex, name, key, item) * else: * for each row: * setColumnValue(row, name, value) */ function assignRowsByNamedValue(nestedRows, rowIndexesGroups, otherRowIndexes, name, value, randomEngine, doUnnest = true) { const l = (_.every(rowIndexesGroups, l =&gt; _.isArray(l))) ? rowIndexesGroups : [rowIndexesGroups]; if (DEBUG) { console.log(`assignRowsByNamedValue: ${name}, ${JSON.stringify(value)}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexesGroups: ${JSON.stringify(rowIndexesGroups)}\\n ${JSON.stringify(nestedRows)}`) assertNoDuplicates(otherRowIndexes); assertNoDuplicates(otherRowIndexes.concat(l)); //printRows(nestedRows) } const otherRowIndexes2 = otherRowIndexes.concat(l); for (let il = 0; il &lt; l.length; il++) { const rowIndexes = _.clone(l[il]); // console.log({il, rowIndexes, l}) let valueIndex = 0; const isSpecial = value instanceof Special; if (isSpecial) { value.reset(); } /*// If value is an array of objects if (_.isArray(value) &amp;&amp; _.every(value, x =&gt; _.isObject(x))) { // Assign indexes const valueIndexes = _.range(1, value.length + 1); assignRowsByNamedValue(nestedRows, rowIndexes, otherRowIndexes, name, valueIndexes, randomEngine, doUnnest); // Assign objects expandRowsByObject(nestedRows, rowIndexes, otherRowIndexes, item, randomEngine); } else*/ if (isSpecial || _.isArray(value)) { for (let i = 0; i &lt; rowIndexes.length; i++) { const rowIndex = rowIndexes[i]; const rowIndexes2 = [rowIndex]; const n = assignRowByNamedValuesKey(nestedRows, rowIndex, otherRowIndexes.concat([rowIndexes, rowIndexes2]), name, value, valueIndex, undefined, randomEngine, doUnnest); valueIndex += n; i += rowIndexes2.length - 1; if (DEBUG) { console.log({rowIndex, dRowIndex: rowIndexes2.length, dValueIndex: n, valueIndex, i, rowIndexes}) console.log(` (assignRowsByNamedValue:) rowIndexes: ${rowIndexes.join(&quot;, &quot;)}`) } } } else if (_.isPlainObject(value)) { let valueIndex = 0; const keys = _.keys(value); for (let i = 0; i &lt; rowIndexes.length; i++) { const rowIndex = rowIndexes[i]; const rowIndexes2 = [rowIndex]; const n = assignRowByNamedValuesKey(nestedRows, rowIndex, otherRowIndexes.concat([rowIndexes, rowIndexes2]), name, value, valueIndex, keys, randomEngine, doUnnest); valueIndex += n; i += rowIndexes2.length - 1; } } else { for (let i = 0; i &lt; rowIndexes.length; i++) { const rowIndex = rowIndexes[i]; setColumnValue(nestedRows[rowIndex], name, value); // console.log(JSON.stringify(nestedRows)) } } } } /* * // REQUIRED by: assignRowsByNamedValue * assignRowByNamedValuesKey: * if item is array: * setColumnValue(row, name, key) * branchRowByArray(nestdRows, rowIndex, item) * else if item is object: * setColumnValue(row, name, key) * expandRowsByObject(nestedRows, [rowIndex], item) * else: * setColumnValue(row, name, item) * Returns number of values actually assigned (may be more than one for nested rows) */ function assignRowByNamedValuesKey(nestedRows, rowIndex, otherRowIndexes, name, values, valueKeyIndex, valueKeys, randomEngine, doUnnest) { assert(!_.isUndefined(doUnnest)); if (DEBUG) { console.log(`assignRowByNamedValuesKey: ${name}, ${JSON.stringify(values)}, ${valueKeyIndex}, ${valueKeys}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndex: ${rowIndex}\\n ${JSON.stringify(nestedRows)}`) assertNoDuplicates(otherRowIndexes); } const row = nestedRows[rowIndex]; let n = (doUnnest) ? 0 : 1; if (_.isArray(row)) { // console.log(&quot;0&quot;) const otherRowIndexes2 = otherRowIndexes.concat([_.range(row.length)]); for (let i = 0; i &lt; row.length; i++) { // console.log(` (assignRowByNamedValuesKey) #${i} of ${row.length}`) const n2 = assignRowByNamedValuesKey(row, i, otherRowIndexes2, name, values, valueKeyIndex, valueKeys, randomEngine, doUnnest); if (doUnnest) { n += n2; valueKeyIndex += n2; } // console.log({i, n2, n, valueKeyIndex, row}) } flattenArrayAndIndexes(nestedRows, [rowIndex], otherRowIndexes); } else { // Error.stackTraceLimit = Infinity; // console.log(&quot;A&quot;) let item, key; if (values instanceof Special) { // console.log(&quot;B: &quot;+rowIndex) // console.log(nestedRows[rowIndex]) const result = values.next(nestedRows, rowIndex); // console.log({result}) key = result[0]; item = result[1]; // [key, item] = result; } else { // console.log(&quot;C&quot;) assert(valueKeyIndex &lt; _.size(values), `fewer values (${_.size(values)}) than rows: `+JSON.stringify({name, values})); const valueKey = (valueKeys) ? valueKeys[valueKeyIndex] : valueKeyIndex; key = (valueKeys) ? valueKey : valueKey + 1; item = values[valueKey]; } // console.log(&quot;D&quot;) // console.log({item}) const rowIndexes2 = [rowIndex]; if (_.isArray(item)) { setColumnValue(row, name, key); branchRowByArray(nestedRows, rowIndex, otherRowIndexes, item, randomEngine); } else if (_.isPlainObject(item)) { setColumnValue(row, name, key); expandRowsByObject(nestedRows, rowIndexes2, otherRowIndexes, item, randomEngine); } else { setColumnValue(row, name, item); } // n = rowIndexes2.length n = 1; } if (DEBUG) { console.log(` (assignRowByNamedValuesKey): ${JSON.stringify(nestedRows)}`) } return n; } /* * // REQUIRED by: expandRowsByNamedValue * branchRowsByNamedValue: * size * = (value is array) ? value.length * : (value is object) ? _.size(value) * : 1 * row0 = nestedRows[rowIndex]; * rows2 = Array(size) * for each rowIndex2 in _.range(size): * rows2[rowIndex] = _.cloneDeep(row0) * * expandRowsByNamedValue(rows2, _.range(size), name, value); * nestedRows[rowIndex] = _.flattenDeep(rows2); */ function branchRowsByNamedValue(nestedRows, rowIndexes, otherRowIndexes, name, value, randomEngine) { if (DEBUG) { console.log(`branchRowsByNamedValue: ${name}, ${JSON.stringify(value)}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(nestedRows)}`) } const isSpecial = (value instanceof Special); const size = (_.isArray(value)) ? value.length : (_.isPlainObject(value)) ? _.size(value) : (isSpecial) ? value.valueCount : 1; //flattenArrayAndIndexes(nestedRows, rowIndexes, otherRowIndexes); // Create 'size' copies of each row in rowIndexes. const rows2 = Array(size * rowIndexes.length); const rowIndexesGroups2 = Array(rowIndexes.length); const rowIndexesGroups2Transposed = _.range(size).map(i =&gt; Array(rowIndexes.length)); for (let j = 0; j &lt; rowIndexes.length; j++) { const rowIndex = rowIndexes[j]; rowIndexesGroups2[j] = Array(size); for (let i = 0; i &lt; size; i++) { const k = j * size + i; rowIndexesGroups2[j][i] = k; rows2[k] = _.cloneDeep(nestedRows[rowIndex]); rowIndexesGroups2Transposed[i][j] = k; } } // console.log({rows2, rowIndexesGroups2, rowIndexesGroups2Transposed}); if (_.isArray(value) &amp;&amp; _.every(value, x =&gt; _.isPlainObject(x))) { // Assign indexes const valueIndexes = _.range(1, value.length + 1); assignRowsByNamedValue(rows2, rowIndexesGroups2, rowIndexesGroups2Transposed, name, valueIndexes, randomEngine, false); // Assign objects const otherRowIndexes3 = rowIndexesGroups2Transposed.concat(rowIndexesGroups2); for (let i = 0; i &lt; size; i++) { const rowIndexes3 = _.clone(rowIndexesGroups2Transposed[i]); expandRowsByObject(rows2, rowIndexes3, otherRowIndexes3, value[i], randomEngine); } } else if (_.isPlainObject(value)) { // Assign indexes const valueIndexes = _.keys(value); assignRowsByNamedValue(rows2, rowIndexesGroups2, rowIndexesGroups2Transposed, name, valueIndexes, randomEngine, false); // Assign objects const otherRowIndexes3 = rowIndexesGroups2Transposed.concat(rowIndexesGroups2); for (let i = 0; i &lt; size; i++) { const key = valueIndexes[i]; const rowIndexes3 = _.clone(rowIndexesGroups2Transposed[i]); expandRowsByObject(rows2, rowIndexes3, otherRowIndexes3, value[key], randomEngine); } } else { // Assign to those copies assignRowsByNamedValue(rows2, rowIndexesGroups2, [], name, value, randomEngine, false); } // console.log({rows2, rowIndexesGroups2, rowIndexesGroups2Transposed}); flattenArrayAndIndexes(rows2, [], rowIndexesGroups2); // console.log({rows2, rowIndexesGroups2}); // console.log({nestedRows}) // Transpose back into nestedRows for (let j = 0; j &lt; rowIndexes.length; j++) { const rowIndexes3 = rowIndexesGroups2[j]; const rows3 = rowIndexes3.map(i =&gt; rows2[i]); const rowIndex = rowIndexes[j]; // console.log({rows3, rowIndex}) nestedRows[rowIndex] = rows3; } // console.log({nestedRows}) // console.log({loc: &quot;B&quot;, otherRowIndexes}) // console.log(JSON.stringify(nestedRows)) flattenArrayAndIndexes(nestedRows, rowIndexes, otherRowIndexes); // console.log({loc: &quot;C&quot;, otherRowIndexes}) } function branchRowByArray(nestedRows, rowIndex, otherRowIndexes, values, randomEngine) { if (DEBUG) { console.log(`branchRowByArray: ${JSON.stringify(values)}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndex: ${rowIndex}\\n ${JSON.stringify(nestedRows)}`) assertNoDuplicates(otherRowIndexes); } const size = values.length; // Make replicates of row const row0 = nestedRows[rowIndex]; const rows2 = Array(size); for (let rowIndex2 = 0; rowIndex2 &lt; size; rowIndex2++) { const value = values[rowIndex2]; rows2[rowIndex2] = _.cloneDeep(row0); expandRowsByObject(rows2, [rowIndex2], [], values[rowIndex2], randomEngine); } nestedRows[rowIndex] = _.flattenDeep(rows2); flattenArrayAndIndexes(nestedRows, [rowIndex], otherRowIndexes); if (DEBUG) { console.log(` (branchRowByArray): ${JSON.stringify(nestedRows)}`) } } // Set the given value, but only if the name doesn't start with a period function setColumnValue(row, name, value) { if (DEBUG) { console.log(`setColumnValue: ${name}, ${JSON.stringify(value)}`); console.log(&quot;row: &quot;+JSON.stringify(row)); } if (name.length &gt;= 1 &amp;&amp; name[0] != &quot;.&quot;) { // Recurse into sub-rows if (_.isArray(row)) { // console.log(&quot;isArray&quot;) for (let i = 0; i &lt; row.length; i++) { setColumnValue(row[i], name, value); } } // Set the value in the row else { row[name] = value; // console.log(`row[name] = ${row[name]}`) } } } class Special { constructor({action, draw, reuse, randomEngine}, next, initGroup) { this.action = action; this.draw = draw; this.reuse = reuse; this.randomEngine = randomEngine; this.next = (next || this.defaultNext); this.initGroup = (initGroup || this.defaultInitGroup); this.reset = this.defaultReset; } defaultInitGroup(nestedRows, rowIndexes) { this.nextIndex = 0; this.valueCount = _.size(this.action.values); // Initialize this.indexes switch (this.draw) { case &quot;direct&quot;: this.indexes = _.range(this.valueCount); break; case &quot;shuffle&quot;: if (this.action.shuffleOnce !== true || !this.indexes) { this.indexes = Random.sample(this.randomEngine, _.range(this.valueCount), this.valueCount); } else { // FIXME: if this.valueCount is now larger than this.indexes.length, then generate more indexes } break; } } defaultNext() { // if (DEBUG) { console.log(&quot;defaultNext: &quot;+)} // console.log({this}); if (this.nextIndex &gt;= this.valueCount) { // console.log(`next: this.nextIndex &gt;= this.valueCount, ${this.nextIndex} &gt;= ${this.valueCount}`) switch (this.reuse) { case &quot;repeat&quot;: this.nextIndex = 0; break; case &quot;reverse&quot;: this.indexes = _.reverse(this.indexes); this.nextIndex = 0; break; case &quot;reshuffle&quot;: this.indexes = Random.sample(this.randomEngine, _.range(this.valueCount), this.valueCount); this.nextIndex = 0; // console.log(&quot;shuffled indexes: &quot;+this.indexes) break; default: assert(false, &quot;not enough values supplied to fill the rows: &quot;+JSON.stringify(this.action)); } // console.log(&quot;this.nextIndex = &quot;+this.nextIndex) } let index, key; switch (this.draw) { case &quot;direct&quot;: index = this.indexes[this.nextIndex]; key = index + 1; break; case &quot;shuffle&quot;: index = this.indexes[this.nextIndex]; key = index + 1; break; case &quot;sample&quot;: index = Random.integer(0, this.valueCount - 1)(this.randomEngine); key = index + 1; break; default: assert(false, &quot;unknown 'draw' value: &quot;+JSON.stringify(this.draw)+&quot; in &quot;+JSON.stringify(this.action)); } // console.log({index, key}) const value = this.action.values[index]; if (this.draw !== &quot;sample&quot;) { this.nextIndex++; } return [key, value]; } defaultReset() { if (this.nextIndex) { this.nextIndex = 0; } } } /* function countRows(nestedRows, rowIndexes) { let sum = 0; for (let i = 0; i &lt; rowIndexes.length; i++) { const rowIndex = rowIndexes[i]; const row = nestedRows[rowIndex]; if (_.isPlainObject(row)) { sum++; } else { sum += countRows(row, _.range(row.length)); } } return sum; }*/ /** * If an action handler return 'undefined', it means that the handler took care of the action already. * @type {Object} */ const actionHandlers = { &quot;allocatePlates&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { const action2 = _.cloneDeep(action); return assign(rows, rowIndexes, otherRowIndexes, name, action2, randomEngine, undefined, assign_allocatePlates_initGroup); }, &quot;allocateWells&quot;: (_rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { const rows = action.rows; const cols = action.columns; const rowJump = action.rowJump || 0; // whether to jump over rows (and then return to the skipped ones), and by how much assert(_.isNumber(rows) &amp;&amp; rows &gt; 0, &quot;missing required positive number `rows`&quot;); assert(_.isNumber(cols) &amp;&amp; cols &gt; 0, &quot;missing required positive number `columns`&quot;); assert(_.isNumber(rowJump) &amp;&amp; rowJump &gt;= 0, &quot;`rowJump`, if specified, must be a number &gt;= 0&quot;); const from0 = action.from || 1; let iFrom; if (_.isInteger(from0)) { iFrom = from0 - 1; } else { const [rowFrom, colFrom] = wellsParser.locationTextToRowCol(from0); iFrom = (colFrom - 1) * rows + (rowFrom - 1); // console.log({from0, rowFrom, colFrom, rows, iFrom}) } let values; if (action.wells) { values = wellsParser.parse(action.wells, {}, {rows, columns: cols}); // TODO: handle `from` for both cases of well name or for integer } else { const byColumns = _.get(action, &quot;byColumns&quot;, true); values = _.range(iFrom, rows * cols).map(i =&gt; { const [row0, col] = (byColumns) ? [i % rows, Math.floor(i / rows)] : [Math.floor(i / cols), i % cols]; // Calculate row when jumping const row1 = row0 * (rowJump + 1); const rowLayer = Math.floor(row1 / rows); const row = (row1 + rowLayer) % rows; const s = locationRowColToText(row + 1, col + 1); // console.log({row, col, s}); return s; }); } // console.log({values}) const action2 = _.cloneDeep(action); action2.values = values; // console.log({values}) return assign(_rows, rowIndexes, otherRowIndexes, name, action2, randomEngine); }, &quot;assign&quot;: assign, &quot;case&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { if (DEBUG) { console.log(`=case: ${name}=${JSON.stringify(action)}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(rows)}`) assertNoDuplicates(otherRowIndexes); assertNoDuplicates(otherRowIndexes.concat([rowIndexes])); } const cases = _.isArray(action) ? action : action.cases; const caseMap = _.isArray(cases) ? cases.map((v, i) =&gt; [i + 1, v]) : _.toPairs(cases); // Group the rows according to the first case they satisfy const rowIndexesGroups = caseMap.map(x =&gt; []); for (let j = 0; j &lt; rowIndexes.length; j++) { const rowIndex = rowIndexes[j]; const row = rows[rowIndex]; const table1 = [row]; for (let i = 0; i &lt; caseMap.length; i++) { const [caseName, caseSpec] = caseMap[i]; if (!caseSpec.where || filterOnWhere(table1, caseSpec.where).length === 1) { rowIndexesGroups[i].push(rowIndex); break; } } } if (DEBUG) { console.log({caseMap, rowIndexesGroups}); } const otherRowIndexes2 = otherRowIndexes.concat([rowIndexes]).concat(rowIndexesGroups); for (let i = 0; i &lt; caseMap.length; i++) { const [caseName, caseSpec] = caseMap[i]; const rowIndexes2 = _.clone(rowIndexesGroups[i]); expandRowsByNamedValue(rows, rowIndexes2, otherRowIndexes2, name, caseName, randomEngine) expandRowsByObject(rows, rowIndexes2, otherRowIndexes2, caseSpec.design, randomEngine); } }, &quot;calculate&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { const expr = _.isString(action) ? action : action.expression; const action2 = _.isString(action) ? {} : action; return assign(rows, rowIndexes, otherRowIndexes, name, {}, randomEngine, assign_calculate_next(expr, action2)); }, // TODO: consider renaming to `calculateWellColumn` &quot;calculateColumn&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { return assign(rows, rowIndexes, otherRowIndexes, name, {}, randomEngine, assign_calculateColumn_next(action, {})); }, &quot;calculateRow&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { return assign(rows, rowIndexes, otherRowIndexes, name, {}, randomEngine, assign_calculateRow_next(action, {})); }, &quot;calculateWell&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { return assign(rows, rowIndexes, otherRowIndexes, name, {}, randomEngine, assign_calculateWell_next(action, {})); }, &quot;concat&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { if (DEBUG) { console.log(`=concat: ${name}=${JSON.stringify(action)}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`); console.log(` rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(rows)}`) assertNoDuplicates(otherRowIndexes); assertNoDuplicates(otherRowIndexes.concat([rowIndexes])); } // find groups (either from `groupBy` or just use everything in rowIndexes) const groupBy = _.isArray(action.groupBy) ? action.groupBy : _.isEmpty(action.groupBy) ? [] : [action.groupBy]; const rowIndexesGroups = (!_.isEmpty(groupBy)) ? query_groupBy(rows, rowIndexes, groupBy) : [_.clone(rowIndexes)]; // for each group, create a temporary row with the group variables and then expand the conditions on that row for (let i = 0; i &lt; rowIndexesGroups.length; i++) { // create a temporary row with the group variables const rowIndexesGroup = rowIndexesGroups[i]; const row0 = (_.isEmpty(groupBy)) ? {} : _.pick(rows[rowIndexesGroup[0]], groupBy); const rows2 = [row0]; const rowIndexes2 = [0]; // console.log({groupBy, rowIndexesGroup, row0}) // expand the conditions on that row expandRowsByObject(rows2, rowIndexes2, [], action.design, randomEngine); // Add the rows back to the original table rows.push(...rows2); rowIndexes.push(..._.range(rowIndexes.length, rowIndexes.length + rows2.length)); } return undefined; }, &quot;range&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { const action2 = _.cloneDeep(_.isNull(action) ? {} : action); _.defaults(action2, {from: 1, step: 1}); return assign(rows, rowIndexes, otherRowIndexes, name, action2, randomEngine, undefined, assign_range_initGroup); }, &quot;rotateColumn&quot;: (rows, rowIndexes, otherRowIndexes, name, action, randomEngine) =&gt; { const action2 = _.isString(action) ? ({column: action, n: 1}) : _.cloneDeep(action); return assign(rows, rowIndexes, otherRowIndexes, name, action2, randomEngine, undefined, assign_rotateColumn_initGroup); }, // &quot;sample&quot;: { // // } } function assign(rows, rowIndexes, otherRowIndexes, name, action, randomEngine, next, initGroup) { assert(_.isPlainObject(action), &quot;expect an object for assignment&quot;) // Handle order in which to assign values let draw = &quot;direct&quot;; let reuse = &quot;none&quot;; if (!_.isEmpty(action.order)) { switch (action.order) { case &quot;direct&quot;: case &quot;direct/none&quot;: break; case &quot;direct/repeat&quot;: case &quot;repeat&quot;: draw = &quot;direct&quot;; reuse = &quot;repeat&quot;; break; case &quot;direct/reverse&quot;: case &quot;reverse&quot;: draw = &quot;direct&quot;; reuse = &quot;reverse&quot;; break; case &quot;shuffle&quot;: draw = &quot;shuffle&quot;; reuse = &quot;none&quot;; break; case &quot;reshuffle&quot;: draw = &quot;shuffle&quot;; reuse = &quot;reshuffle&quot;; break; case &quot;shuffle/reshuffle&quot;: draw = &quot;shuffle&quot;; reuse = &quot;reshuffle&quot;; break; case &quot;shuffle/repeat&quot;: draw = &quot;shuffle&quot;; reuse = &quot;repeat&quot;; break; case &quot;shuffle/reverse&quot;: draw = &quot;shuffle&quot;; reuse = &quot;reverse&quot;; break; case &quot;sample&quot;: draw = &quot;sample&quot;; break; default: assert(false, &quot;unrecognized 'order' value: &quot;+action.order); } } if (_.isString(action.calculate)) { next = assign_calculate_next(action.calculate, action) } const randomEngine2 = (_.isNumber(action.randomSeed)) ? Random.engines.mt19937().seed(action.randomSeed) : randomEngine; const value2 = ((_.isArray(action.values)) &amp;&amp; draw === &quot;direct&quot; &amp;&amp; reuse === &quot;none&quot; &amp;&amp; !initGroup) ? action.values : new Special({action, draw, reuse, randomEngine: randomEngine2}, next, initGroup); return handleAssignmentWithQueries(rows, rowIndexes, otherRowIndexes, name, action, randomEngine2, value2); } function handleAssignmentWithQueries(rows, rowIndexes0, otherRowIndexes, name, action, randomEngine, value0) { if (DEBUG) { console.log(`handleAssignmentWithQueries: ${JSON.stringify({name, action, value0})}`); console.log(` otherRowIndexes: ${JSON.stringify(otherRowIndexes)}`) console.log(` rowIndexes: ${JSON.stringify(rowIndexes0)}\\n ${JSON.stringify(rows)}`) assertNoDuplicates(otherRowIndexes); assertNoDuplicates(otherRowIndexes.concat([rowIndexes0])); } const isSpecial = value0 instanceof Special; const hasGroupOrSame = action.groupBy || action.sameBy; if (!action.groupBy &amp;&amp; !action.sameBy &amp;&amp; !action.orderBy) { if (isSpecial) { // console.log({name}) value0.initGroup(rows, rowIndexes0); } return value0; } const rowIndexesGroups = (action.groupBy) ? query_groupBy(rows, rowIndexes0, action.groupBy) : [_.clone(rowIndexes0)]; // console.log({rowIndexesGroups}) for (let i = 0; i &lt; rowIndexesGroups.length; i++) { let rowIndexes = _.clone(rowIndexesGroups[i]); let value = value0; // If 'orderBy' is set, we should re-order the values (if just returning 'value') or rowIndexes (otherwise) if (action.orderBy) { // console.log(&quot;A&quot;) if (_.isArray(value)) { // This is a copy of 'makeComparer', but with more indirection in assignment of row1 and row2 const propertyNames = action.orderBy; function comparer(i1, i2) { const row1 = rows[rowIndexes[i1]]; const row2 = rows[rowIndexes[i2]]; const l = (_.isArray(propertyNames)) ? propertyNames : [propertyNames]; for (let j = 0; j &lt; l.length; j++) { const propertyName = l[j]; const value1 = row1[propertyName]; const value2 = row2[propertyName]; const cmp = naturalSort(value1, value2); if (cmp !== 0) return cmp; } return 0; }; const is1 = stableSort(_.range(rowIndexes.length), comparer); // console.log({is1}); // Allocate a new value array const value1 = new Array(rowIndexes.length); // Insert values into the new array according to the new desired order for (let i = 0; i &lt; rowIndexes.length; i++) { const j = is1[i]; value1[j] = value[i]; } // console.log({is1, rowIndexes, rows, value, value1}); value = value1; } //if (hasGroupOrSame) else { const rowIndexes2 = query_orderBy(rows, rowIndexes, action.orderBy); // console.log({orderBy: action.orderBy, rowIndexes, rowIndexes2}) // console.log({rowIndexes}) rowIndexes = rowIndexes2; } } // const rowIndexes2 = _.clone(rowIndexes); // console.log({rowIndexes, rowIndexesGroups}) const otherRowIndexes2 = otherRowIndexes.concat([rowIndexes0]).concat(rowIndexesGroups); if (DEBUG) { assertNoDuplicates(otherRowIndexes2); } // console.log({otherRowIndexes, rowIndexes, rowIndexesGroups, otherRowIndexes2}) if (action.sameBy) { assignSameBy(rows, rowIndexes, otherRowIndexes2, name, action, randomEngine, value); } else { if (isSpecial) { // console.log({rows, rowIndexes2}) value.initGroup(rows, rowIndexes); } // console.log({rows, rowIndexes2, otherRowIndexes2, name, value}) expandRowsByNamedValue(rows, rowIndexes, otherRowIndexes2, name, value, randomEngine); } } return undefined; } function assignSameBy(rows, rowIndexes, otherRowIndexes, name, action, randomEngine, value) { if (DEBUG) { console.log(`assignSameBy: ${JSON.stringify({name, action, value})}`); console.log(` rowIndexes: ${JSON.stringify(rowIndexes)}\\n ${JSON.stringify(rows)}`) // assertNoDuplicates(otherRowIndexes); assertNoDuplicates(otherRowIndexes.concat([rowIndexes])); } const isArray = _.isArray(value); const isObject = _.isPlainObject(value); const isSpecial = value instanceof Special; const rowIndexesSame = query_groupBy(rows, rowIndexes, action.sameBy); // console.log({rowIndexesSame}) /* for (let i = 0; i &lt; rowIndexesSame.length; i++) { const rowIndexes2 = rowIndexesSame[i]; const rowIndex = rowIndexes2[0]; const rows2 = rowIndexes2.map(i =&gt; rows[i]); rows.splice(rowIndex, 1, ..rows2); for (let j = 0; j &lt; rowIndexesSame.length;) } */ if (isSpecial) { const rowIndexesFirst = rowIndexesSame.map(l =&gt; l[0]); value.initGroup(rows, rowIndexesFirst); } const keys = (isObject) ? _.keys(value) : 0; const table2 = _.zip.apply(_, table2); for (let i = 0; i &lt; rowIndexesSame.length; i++) { const rowIndexes3 = rowIndexesSame[i]; // if (isSpecial) { // value.nextIndex = i; // } const value2 = (isArray) ? value[i] : (isObject) ? value[keys[i]] : (isSpecial) ? value.next(rows, [rowIndexes3[0]])[1] : value; // console.log({i, rowIndexes3, value2, value}) for (let i = 0; i &lt; rowIndexes3.length; i++) { const rowIndex = rowIndexes3[i]; expandRowsByNamedValue(rows, [rowIndex], otherRowIndexes, name, value2, randomEngine); } } } function assign_allocatePlates_initGroup(rows, rowIndexes) { if (DEBUG) { console.log(`assign_allocatePlates_initGroup: ${rows}, ${rowIndexes}`) } const action = this.action; if (_.isUndefined(this.plateIndex)) this.plateIndex = 0; if (_.isUndefined(this.wellsUsed)) this.wellsUsed = 0; // If the wells on the plate should be segmented by some grouping if (action.groupBy) { assert(rowIndexes.length &lt;= action.wellsPerPlate, `too many positions in group for plate to accomodate: ${rowIndexes.length} rows, ${action.wellsPerPlate} wells per plate`); // If they fit on the current plate: if (this.wellsUsed + rowIndexes.length &lt;= action.wellsPerPlate) { this.wellsUsed += rowIndexes.length; } // Otherwise, skip to next plate else { this.plateIndex++; assert(this.plateIndex &lt; action.plates.length, `require more plates than the ${action.plates.length} supplied: ${action.plates.join(&quot;, &quot;)}`); this.wellsUsed = rowIndexes.length; } // TODO: allow for rotating plates for each group rather than assigning each plate until its full // console.log() // console.log({this}) this.action.values = _.fill(Array(rowIndexes.length), action.plates[this.plateIndex]); // console.log({this_action_values: this.action.values}); } else { // assert(rowIndexes.length &lt;= action.plates.length * action.wellsPerPlate, `too many row for plates to accomodate: ${rowIndexes.length} rows, ${action.wellsPerPlate} wells per plate, ${action.plates.length} plates`); // If all the rows can be assigned to the current plate: if (this.wellsUsed + rowIndexes.length &lt;= action.wellsPerPlate) { this.wellsUsed += rowIndexes.length; this.action.values = _.fill(Array(rowIndexes.length), action.plates[this.plateIndex]); } // Otherwise, just allocate each plate until its full else { this.action.values = Array(rowIndexes.length); let i = 0; while (i &lt; rowIndexes.length) { const n = Math.min(rowIndexes.length - i, action.wellsPerPlate - this.wellsUsed); if (n == 0) { this.plateIndex++; assert(this.plateIndex &lt; action.plates.length, `require more plates than the ${action.plates.length} supplied: ${action.plates.join(&quot;, &quot;)}`); this.wellsUsed = 0; } else { for (let j = 0; j &lt; n; j++) { this.action.values[i + j] = action.plates[this.plateIndex]; } this.wellsUsed += n; } i += n; } } // TODO: allow for rotating plates for each group rather than assigning each plate until its full // console.log() // console.log({this}) // console.log({this_action_values: this.action.values}); } this.defaultInitGroup(rows, rowIndexes); } /** * Calculate `expr` using variables in `row`, with optional `action` object specifying `units` and/or `decimals` */ export function calculate(expr, row, action = {}) { const scope = _.mapValues(row, x =&gt; { // console.log({x}) try { const result = math.eval(x); // If evaluation succeeds, but it was just a unit name, then set value as string instead if (result.type === &quot;Unit&quot; &amp;&amp; result.value === null) return x; else { return result; } } catch (e) {} return x; }); assert(!_.isUndefined(expr), &quot;`expression` property must be specified&quot;); // console.log({expr, scope}) // console.log(&quot;scope:&quot;+JSON.stringify(scope, null, '\\t')) let value = math.eval(expr, scope); // console.log({type: value.type, value}) if (_.isString(value) || _.isNumber(value) || _.isBoolean(value)) { return value; } // Get units to use in the end, and the unitless value const {units0, units, unitless} = (() =&gt; { const result = { units0: undefined, units: action.units, unitless: value }; // If the result has units: if (value.type === &quot;Unit&quot;) { result.units0 = value.formatUnits(); if (_.isUndefined(result.units)) result.units = result.units0; const conversionUnits = (_.isEmpty(result.units)) ? result.units0 : result.units; // If the units dissappeared, e.g. when dividing 30ul/1ul = 30: if (_.isEmpty(conversionUnits)) { // TODO: find a better way to get the unit-less quantity from `value` // console.log({action}) // console.log({result, conversionUnits}); result.unitless = math.eval(value.format()); } else { result.unitless = value.toNumeric(conversionUnits); } } return result; })(); // console.log(`unitless: ${JSON.stringify(unitless)}`) // Restrict decimal places // console.log({unitless}) const unitlessText = (_.isNumber(action.decimals)) ? unitless.toFixed(action.decimals) : _.isNumber(unitless) ? unitless : unitless.toNumber(); // Set units const valueText = (!_.isEmpty(units)) ? unitlessText + &quot; &quot; + units : unitlessText; return valueText; } function assign_calculate_next(expr, action) { return function(nestedRows, rowIndex) { const row0 = nestedRows[rowIndex]; const row = (_.isArray(row0)) ? _.head(_.flattenDeep(row0)) : row0; // Build the scope for evaluating the math expression from the current data row const valueText = calculate(expr, row, action); this.nextIndex++; return [this.nextIndex, valueText]; } } function assign_calculateColumn_next(expr, action) { return function(nestedRows, rowIndex) { const row0 = nestedRows[rowIndex]; const row = (_.isArray(row0)) ? _.head(_.flattenDeep(row0)) : row0; // Build the scope for evaluating the math expression from the current data row const valueText = _.get(row, expr, expr); const [r, c] = wellsParser.locationTextToRowCol(valueText); this.nextIndex++; return [this.nextIndex, c]; } } function assign_calculateRow_next(expr, action) { return function(nestedRows, rowIndex) { const row0 = nestedRows[rowIndex]; const row = (_.isArray(row0)) ? _.head(_.flattenDeep(row0)) : row0; // Build the scope for evaluating the math expression from the current data row const valueText = _.get(row, expr, expr); const [r, c] = wellsParser.locationTextToRowCol(valueText); this.nextIndex++; return [this.nextIndex, r]; } } function assign_calculateWell_next(action) { return function(nestedRows, rowIndex) { const row0 = nestedRows[rowIndex]; const row = (_.isArray(row0)) ? _.head(_.flattenDeep(row0)) : row0; // Build the scope for evaluating the math expression from the current data row const scope = _.mapValues(row, x =&gt; { // console.log({x}) try { const result = math.eval(x); // If evaluation succeeds, but it was just a unit name, then set value as string instead if (result.type === &quot;Unit&quot; &amp;&amp; result.value === null) return x; else { return result; } } catch (e) {} return x; }); // console.log(&quot;scope:&quot;+JSON.stringify(scope, null, '\\t')) let wellRow = math.eval(action.row, scope).toNumber(); let wellCol = math.eval(action.column, scope).toNumber(); const wellName = locationRowColToText(wellRow, wellCol); // console.log({wellRow, wellCol, wellName}) this.nextIndex++; return [this.nextIndex, wellName]; } } function assign_range_initGroup(rows, rowIndexes) { // console.log(`assign_range_initGroup:`, {rows, rowIndexes}) const commonHolder = []; // cache for common values, if needed const from = getOrCalculateNumber(this.action, &quot;from&quot;, rowIndexes.length, rows, rowIndexes, commonHolder); const till = getOrCalculateNumber(this.action, &quot;till&quot;, rowIndexes.length, rows, rowIndexes, commonHolder); const end = till + 1; let values; if (_.isNumber(this.action.count)) { const diff = till - from; values = _.range(this.action.count).map(i =&gt; { const d = diff * i / (this.action.count - 1); return from + d; }); } else { values = _.range(from, end, this.action.step); } if (values) { if (_.isNumber(this.action.decimals)) { values = values.map(n =&gt; Number(n.toFixed(this.action.decimals))); } if (_.isString(this.action.units)) { values = values.map(n =&gt; `${n} ${this.action.units}`); } } this.action.values = values; // console.log({this_action_values: this.action.values}); this.defaultInitGroup(rows, rowIndexes); } function assign_rotateColumn_initGroup(rows, rowIndexes) { const l = rowIndexes.map(i =&gt; rows[i][this.action.column]); if (this.action.n &gt; 0) { for (let i = 0; i &lt; this.action.n; i++) { const x = l.pop(); l.unshift(x); } } else { for (let i = 0; i &lt; -this.action.n; i++) { const x = l.shift(); l.push(x); } } this.action.values = l; this.defaultInitGroup(rows, rowIndexes); } /* function assign_range_next(nestedRows, rowIndex) { const commonHolder = []; // cache for common values, if needed const from = getOrCalculateNumber(this.action, &quot;from&quot;, rowIndexes.length, nestedRows, [rowIndex], commonHolder); const till = getOrCalculateNumber(this.action, &quot;till&quot;, rowIndexes.length, nestedRows, [rowIndex], commonHolder); const end = till + 1; let values; if (_.isNumber(this.action.count)) { const diff = till - from; values = _.range(this.action.count).map(i =&gt; { const d = diff * i / (this.action.count - 1); return from + d; }); } else { values = _.range(from, end, this.action.step); } if (values) { if (_.isNumber(this.action.decimals)) { values = values.map(n =&gt; Number(n.toFixed(this.action.decimals))); } if (_.isString(this.action.units)) { values = values.map(n =&gt; `${n} ${this.action.units}`); } } console.log({values}); this.nextIndex++; return [this.nextIndex, values]; } */ function getOrCalculateNumber(action, propertyName, dflt, nestedRows, rowIndexes, commonHolder) { const value = _.get(action, propertyName); if (_.isUndefined(value)) { return dflt; } else if (_.isNumber(value)) { return value; } else if (_.isString(value)) { const options = {}; const next = assign_calculate_next(value, options); const fakethis = {nextIndex: 0}; if (commonHolder.length === 0) { // console.log({nestedRows, rowIndexes}) commonHolder.push(commonHolder.push(getCommonValuesNested(nestedRows, rowIndexes))); } const common = commonHolder[0]; // console.log({common}) const [dummyIndex, result] = next.bind(fakethis)([common], [0]); return result; } } /* const assign_range_next = (expr, action) =&gt; function(nestedRows, rowIndex) { console.log(&quot;assign_range_next: &quot;+JSON.stringify(this)); const n = this.action.from + this.nextIndex * this.action.step; assert(!_.isNumber(this.action.till) || n &lt; this.action.till, &quot;range could not fill rows&quot;); this.nextIndex++; return [this.nextIndex, n]; }*/ export function query_groupBy(rows, rowIndexes, groupBy) { const groupKeys = (_.isArray(groupBy)) ? groupBy : [groupBy]; // console.log({groupBy, groupKeys, rowIndexes, rows}); return _.values(_.groupBy(rowIndexes, rowIndex =&gt; _.map(groupKeys, key =&gt; rows[rowIndex][key]))); } /** * Return an array of rowIndexes which are ordered by the `orderBy` criteria. * @param {array} rows - a flat array of row objects * @param {array} rowIndexes - array of row indexes to consider * @param {string|array} orderBy - the column(s) to order by * @return {array} a sorted ordering of rowIndexes */ export function query_orderBy(rows, rowIndexes, orderBy) { // console.log({rows, rowLen: rows.length, rowIndexes, orderBy}) // console.log(rowIndexes.map(i =&gt; _.values(_.pick(rows[i], orderBy)))) return stableSort(rowIndexes, makeComparer(rows, orderBy)); } function makeComparer(rows, propertyNames) { return function(i1, i2) { const row1 = rows[i1]; const row2 = rows[i2]; if (!row1 || !row2) { console.log({i1, i2, row1, row2}) } const l = (_.isArray(propertyNames)) ? propertyNames : [propertyNames]; for (let j = 0; j &lt; l.length; j++) { const propertyName = l[j]; const value1 = row1[propertyName]; const value2 = row2[propertyName]; const cmp = naturalSort(value1, value2); if (cmp !== 0) return cmp; } return 0; }; } export function query(table, q, SCOPE = undefined) { let table2 = _.clone(table); if (q.where) { // console.log({where: q.where}) table2 = filterOnWhere(table2, q.where, SCOPE); } if (q.shuffle) { table2 = _.shuffle(table); } if (q.orderBy) { table2 = _.orderBy(table2, q.orderBy); } if (q.distinctBy) { const groupKeys = (_.isArray(q.distinctBy)) ? q.distinctBy : [q.distinctBy]; const groups = _.map(_.groupBy(table2, row =&gt; _.map(groupKeys, key =&gt; row[key])), _.identity); //console.log({groupsLength: groups.length}) table2 = _.flatMap(groups, group =&gt; { const first = group[0]; // Find the properties that are the same for all items in the group const uniqueKeys = []; _.forEach(first, (value, key) =&gt; { const isUnique = _.every(group, row =&gt; _.isEqual(row[key], value)); if (isUnique) { uniqueKeys.push(key); } }); return _.pick(first, uniqueKeys); }); } else if (q.unique) { table2 = _.uniqWith(table2, _.isEqual); } if (q.groupBy) { const groupKeys = (_.isArray(q.groupBy)) ? q.groupBy : [q.groupBy]; table2 = _.map(_.groupBy(table2, row =&gt; _.map(groupKeys, key =&gt; row[key])), _.identity); } else { table2 = [table2]; } if (q.select) { table2 = table2.map(rows =&gt; rows.map(row =&gt; _.pick(row, q.select))); } if (q.transpose) { table2 = _.zip.apply(_, table2); } return table2; } const compareFunctions = { &quot;eq&quot;: _.isEqual, &quot;gt&quot;: _.gt, &quot;gte&quot;: _.gte, &quot;lt&quot;: _.lt, &quot;lte&quot;: _.lte, &quot;ne&quot;: (a, b) =&gt; !_.isEqual(a, b), &quot;in&quot;: _.includes }; function filterOnWhere(table, where, SCOPE = undefined) { let table2 = table; if (_.isPlainObject(where)) { _.forEach(where, (value, key) =&gt; { if (_.isPlainObject(value)) { _.forEach(value, (value2, op) =&gt; { // Get compare function assert(compareFunctions.hasOwnProperty(op), `unrecognized operator: ${op} in ${JSON.stringify(value)}`); const fn = compareFunctions[op]; // console.log({op, fn}) table2 = filterOnWhereOnce(table2, key, value2, fn); }); } else { table2 = filterOnWhereOnce(table2, key, value, _.isEqual); } }); } else if (_.isString(where)) { // console.log({where}) table2 = _.filter(table, row =&gt; { const scope1 = _.mapValues(row, x =&gt; { // console.log({x}) try { const result = math.eval(x); // If evaluation succeeds, but it was just a unit name, then set value as string instead if (result.type === &quot;Unit&quot; &amp;&amp; result.value === null) return x; else { return result; } } catch (e) {} return x; }); const scope = _.defaults({}, scope1, SCOPE); // console.log({where, row, scope}) try { const result = math.eval(where, scope); // console.log({result}); return result; } catch (e) { console.log(&quot;WARNING: &quot;+e); console.log(&quot;where: &quot;+JSON.stringify(where)); // console.log({scope}) process.exit() } return false; }); } return table2; } /** * Sub-function that filters table on a single criterion. * @param {array} table - table to filter * @param {string} key - key of column in table * @param {any} x - value to compare to * @param {Function} fn - comparison function * @return {array} filtered table */ function filterOnWhereOnce(table, key, x, fn) { // console.log(&quot;filterOnWhereOnce: &quot;); console.log({key, x, fn}) // If x is an array, do an array comparison if (_.isArray(x)) { return _.filter(table, (row, i) =&gt; fn(row[key], x[i])); } // If we need to else if (_.isString(x)) { if (_.startsWith(x, &quot;\\&quot;&quot;)) { const text = x.substr(1, x.length - 2); return table.filter(row =&gt; fn(row[key], text)); } else { const key2 = x.substr(1); return table.filter(row =&gt; fn(row[key], row[key2])); } } else { return table.filter(row =&gt; fn(row[key], x)); } } /** * Check whether the same underlying array shows up more than once in otherRowIndexes. * This should never be the case, because if we modify one, the &quot;other&quot; will also be modified. */ function assertNoDuplicates(otherRowIndexes) { for (let i = 0; i &lt; otherRowIndexes.length - 1; i++) { for (let j = i + 1; j &lt; otherRowIndexes.length; j++) { assert(otherRowIndexes[i] != otherRowIndexes[j], `same underlying array appears in 'otherRowIndexs' at both ${i} and ${j}: ${JSON.stringify(otherRowIndexes)}`) } } } × Search results Close "},"generateSchemaDocs.js.html":{"id":"generateSchemaDocs.js.html","title":"Source: generateSchemaDocs.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: generateSchemaDocs.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Generate documentation from the schemas in `schemas/*.yaml`. * Running this module will create these files: * * * `tutorials/Object_Types.md` * * `tutorials/Commands.md` * * @module */ import _ from 'lodash'; import fs from 'fs'; import path from 'path'; import yaml from 'yamljs'; /** * Convert a name/schema pair to markdown text. * @param {array} pair - [name, schema] * @return A markdown string. */ function toMarkdown(pair) { const [name, o] = pair; //console.log({name, o}) if (o.module) { return `\\n## &lt;a name=&quot;${name}&quot;&gt;&lt;/a&gt;${name}\\n\\n${o.module}`; } else { return _.flattenDeep([ `### \\`${name}\\``, &quot;&quot;, o.description ? [o.description, &quot;&quot;] : [], &quot;Properties:&quot;, &quot;&quot;, &quot;Name | Type | Argument | Description&quot;, &quot;-----|------|----------|------------&quot;, _.map(o.properties, (p, pName) =&gt; { const isRequired = _.includes(o.required, pName); // const nameText = (isRequired) ? pName : `[${pName}]`; // const nameTypeText = (p.type) ? `${nameText}: ${p.type}` : nameText; // const descriptionText = p.description || &quot;&quot;; // return `* \\`${nameTypeText}\\` -- ${descriptionText}`; return `${pName} | ${p.type || &quot;&quot;} | ${(isRequired) ? &quot;&quot; : &quot;*optional*&quot;} | ${p.description || &quot;&quot;}`; }), (_.isEmpty(o.example)) ? [] : [ &quot;&quot;, &quot;Example:&quot;, &quot;&quot;, o.example, &quot;&quot; ] ]).join('\\n'); } } /** * Take a string, split it on all newlines, prepend each newline with &quot; * &quot;, and then rejoin. * @param {string} s - string to indent * @return {string} - string indented by &quot; * &quot; */ function indentJsdocComment(s) { return s.trim().split(&quot;\\n&quot;).map(s =&gt; &quot; * &quot;+s).join(&quot;\\n&quot;); } /** * Convert a name/schema pair to jsdoc text. * @param {array} pair - [name, schema] * @param {boolean} isCommand - true if pair is a command, in which case the `memberOf` field is handled differently. * @return A markdown string. */ function typeToJsdoc(pair, isCommand = false) { const [name, o] = pair; //console.log({name, o}) const s = _.flattenDeep([ o.description ? [o.description, &quot;&quot;] : [], (isCommand) ? `@typedef &quot;${name}&quot;` : `@class ${name}`, //(isCommand) ? `@memberof ${_.initial(name.split(&quot;.&quot;)).join(&quot;.&quot;)}` : [], //(isCommand) ? `@memberof commands`: &quot;@memberof types&quot;, _.map(o.properties, (p, pName) =&gt; { const isRequired = _.includes(o.required, pName); const nameText = (isRequired) ? pName : `[${pName}]`; const typeText = (p.type) ? `{${_.flatten([p.type]).join(&quot;|&quot;).replace(/ /g, &quot;&quot;)}}` : &quot;&quot;; const descriptionText = (p.description) ? `- ${p.description}` : &quot;&quot;; return `@property ${typeText} ${nameText} ${descriptionText}`; }), (_.isEmpty(o.example)) ? [] : [ &quot;@example&quot;, o.example ] ]).join('\\n').trim().split(&quot;\\n&quot;).map(s =&gt; &quot; * &quot;+s).join(&quot;\\n&quot;); return &quot;/**\\n&quot; + s + &quot;\\n */\\n\\n&quot;; } /** * Convert a name/schema pair to markdown text. * @param {array} pair - [name, schema] * @return A markdown string. */ function commandToJsdoc(pair) { const [name, o] = pair; //console.log({name, o}) if (o.module) { return `\\n/**\\n${indentJsdocComment(o.module)}\\n *\\n * @module ${name}\\n */\\n`; } else { return typeToJsdoc(pair, true); } } // All files in the schema/ directory const filename_l = _.filter(fs.readdirSync(__dirname+&quot;/schemas/&quot;), s =&gt; path.extname(s) === &quot;.yaml&quot;); // Load the schemas from the files const schemas_l = _.map(filename_l, filename =&gt; yaml.load(__dirname+&quot;/schemas/&quot;+filename)); // Merge all schemas together const schemas = _.merge.apply(_, [{}].concat(schemas_l)); // Separate object schemas from command schemas const [objectSchemas, commandSchemas] = _.partition(_.toPairs(schemas), ([name, schema]) =&gt; name[0] === name[0].toUpperCase()); // Generate documentation for object types const objectSchemasText = _.map(objectSchemas, toMarkdown).join('\\n\\n'); fs.writeFileSync(__dirname+&quot;/../tutorials/Object_Types.md&quot;, objectSchemasText); // Generate documentation for commands const commandSchemasText = _.map(commandSchemas, toMarkdown).join('\\n\\n'); fs.writeFileSync(__dirname+&quot;/../tutorials/Commands.md&quot;, commandSchemasText); fs.writeFileSync(__dirname+&quot;/../generated/content/commands.md&quot;, commandSchemasText); // Generate documentation for object types const generatedTypesText = &quot;/**\\n * Namespace for the object types available in Roboliq protocols.\\n * @namespace types\\n * @version v1 \\n */\\n\\n&quot; + _.map(objectSchemas, x =&gt; typeToJsdoc(x)).join('\\n\\n'); fs.writeFileSync(__dirname+&quot;/../generated/types.jsdoc&quot;, generatedTypesText); // Generate documentation for commands const generatedCommandsText = &quot;/**\\n * Namespace for the commands available in Roboliq protocols.\\n * @namespace commands\\n * @version v1 \\n */\\n\\n&quot; + _.map(commandSchemas, commandToJsdoc).join('\\n\\n'); fs.writeFileSync(__dirname+&quot;/../generated/commands.jsdoc&quot;, generatedCommandsText); × Search results Close "},"misc.js.html":{"id":"misc.js.html","title":"Source: misc.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: misc.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * A set of miscellaneous helper functions. * * Some of these are HACKs that should be moved to another module or removed entirely. * * @module */ var _ = require('lodash'); var assert = require('assert'); var Handlebars = require('handlebars'); Handlebars.registerHelper('toJSON', function(obj) { return JSON.stringify(obj); }); /** * queryResults: value returned from llpl.query() * predicateName: name of the predicate that was used for the query * @returns {object} `{parameterName1: parameterValues1, ...}` * @static */ function extractValuesFromQueryResults(queryResults, predicateName) { var acc = _.reduce(queryResults, function(acc, x1) { var x2 = x1[predicateName]; _.forEach(x2, function(value, name) { if (_.isEmpty(acc[name])) acc[name] = [value]; else acc[name].push(value); }); return acc; }, {}); return acc; } function findObjectsValue(key, objects, effects, defaultValue, prefix) { if (effects) { var id = (prefix) ? prefix+&quot;.&quot;+key : key; if (effects.hasOwnProperty(id)) return effects[id]; } return _.get(objects, key, defaultValue); } // NOTE: This is basically a copy of expect.objectsValue function getObjectsValue(key, objects, effects, prefix) { assert(_.isString(key), &quot;getObjectsValue expected a string key, received: &quot;+JSON.stringify(key)); if (effects) { var id = (prefix) ? prefix+&quot;.&quot;+key : key; if (effects.hasOwnProperty(id)) return effects[id]; } var l = key.split('.'); for (var i = 0; !_.isEmpty(objects) &amp;&amp; i &lt; l.length; i++) { if (!objects.hasOwnProperty(l[i])) { var objectName = _.take(l, i + 1).join('.'); if (prefix) objectName = prefix + '.' + objectName; var message = &quot;value `&quot;+objectName+&quot;`: undefined&quot;; // console.log({key, objects}) //console.log(&quot;objects:&quot;, objects) //console.log(message); throw new Error(message);//{name: &quot;ProcessingError&quot;, errors: [message]}; } objects = objects[l[i]]; } return objects; } function getVariableValue(spec, objects, effects, prefix) { if (_.isString(spec)) { if (_.startsWith(spec, '&quot;')) return spec; var found = findObjectsValue(spec, objects, effects); if (!_.isUndefined(found)) { if (found.type === &quot;Variable&quot;) { return found.value; } else { return found; } } } return spec; } function getObjectsOfType(objects, types, prefix) { if (_.isString(types)) types = [types]; if (!prefix) prefix = []; var l = {}; _.forEach(objects, function(o, name) { var prefix1 = prefix.concat([name]); if (_.has(o, &quot;type&quot;) &amp;&amp; _.isString(o.type) &amp;&amp; types.indexOf(o.type) &gt;= 0) { var id = prefix1.join('.'); l[id] = o; } _.forEach(o, function(o2, name2) { if (_.isPlainObject(o2)) { var prefix2 = prefix1.concat([name2]); _.merge(l, getObjectsOfType(o2, types, prefix2)); } }); }); return l; } /** * If spec is a directive, process it and return the result. * * @param {Any} spec Any value. If this is a directive, it will be an object with a single key that starts with '#'. * @param {Object} data An object with properties: directiveHandlers, objects, events. * @return {Any} Return the object, or if it was a directive, the results of the directive handler. */ function handleDirective(spec, data) { // console.log(`handleDirective: `+JSON.stringify(spec)) // console.log(&quot;data1: &quot;+JSON.stringify(data)); const directiveHandlers = data.directiveHandlers || (data.protocol || {}).directiveHandlers; if (_.isPlainObject(spec)) { const keys = _.keys(spec); if (keys.length === 1) { const key0 = keys[0]; const key = (_.startsWith(key0, &quot;#&quot;)) ? key0.substr(1) : (_.endsWith(key0, &quot;()&quot;)) ? key0.substr(0, key0.length - 2) : undefined; // console.log({key0, key}) if (key) { if (directiveHandlers.hasOwnProperty(key)) { var spec2 = spec[key0]; // console.log({spec2, handler: directiveHandlers[key]}) var spec3 = (_.isPlainObject(spec2)) ? _.omit(spec2, 'override') : spec2; const result = { x: directiveHandlers[key](spec3, data) }; if (spec2.hasOwnProperty('override')) { //console.log({result0: result.x}) _.merge(result, {x: spec2.override}); //console.log({result1: result.x}) } return result.x; } else { throw new Error(&quot;unknown directive object: &quot;+key); } } } } else if (_.isString(spec)) { // Inline directives if (_.startsWith(spec, &quot;#&quot;)) { const hash2 = spec.indexOf('#', 1); const key = (hash2 &gt; 0) ? spec.substr(1, hash2 - 1) : spec.substr(1); // console.log({hash2, key}) if (directiveHandlers.hasOwnProperty(key)) { const spec2 = (hash2 &gt; 0) ? spec.substr(hash2 + 1) : undefined; const spec3 = handleDirective(spec2, data); const result = directiveHandlers[key](spec3, data); if (spec.hasOwnProperty('override')) { _.merge(result, spec.override); } return result; } else { throw new Error(&quot;unknown directive string: &quot;+spec); } } // Protocol parameters else if (_.startsWith(spec, &quot;$#&quot;)) { const key = spec.substr(2); if (_.has(data.objects.PARAMS, key)) { const result = data.objects.PARAMS[key]; if (!_.isUndefined(result)) { return result; } else { throw new Error(&quot;undefined parameter value: &quot;+spec); } } else { throw new Error(&quot;undefined parameter: &quot;+spec); } } } return spec; } /** * Recurses into object properties and replaces them with the result of handleDirective. * It will, however, skip properties named 'steps'. * * @param {Any} spec Any value. If this is a directive, it will be an object with a single key that starts with '#'. * @param {Object} data An object with properties: directiveHandlers, objects, events. * @return {Any} Return the object, or if it was a directive, the results of the directive handler. */ function handleDirectiveDeep(x, data) { //return mapDeep(spec, function(spec) { return handleDirective(spec, data); }); if (_.isPlainObject(x)) { if (!x.hasOwnProperty('data')) { x = _.mapValues(x, function(value, key) { return (key === 'steps') ? value : handleDirectiveDeep(value, data); }); } } else if (_.isArray(x)) { x = _.map(x, function(value, i) { return handleDirectiveDeep(value, data); }); } x = handleDirective(x, data); return x; } /** * Recurses into object properties and maps them to the result of fn. * * @static * @param {Any} x Any value. * @param {Function} fn A function (x, key, path) that returns a mapped value. * @return {Any} Return the deeply mapped object. */ function mapDeep(x, fn, key, path = []) { if (_.isPlainObject(x)) { x = _.mapValues(x, function(value, key) { return mapDeep(value, fn, key, path.concat(key)); }); } else if (_.isArray(x)) { x = _.map(x, function(value, i) { return mapDeep(value, fn, i, path.concat(i)); }); } x = fn(x, key, path); return x; } /** * Recurses into object properties and replaces them with the result of fn. * 'x' will be mutated. * * @static * @param {Any} x Any value. * @param {Function} fn A function that returns a transformed value. * @return nothing */ function mutateDeep(x, fn) { //console.log(&quot;x:&quot;, x) if (_.isPlainObject(x)) { for (var key in x) { //console.log(&quot;key:&quot;, key) x[key] = mutateDeep(x[key], fn); } } else if (_.isArray(x)) { for (let i = 0; i &lt; x.length; i++) { x[i] = mutateDeep(x[i], fn); } } return fn(x); } function renderTemplate(template, scope, data) { //console.log(&quot;renderTemplate:&quot;, template) if (_.isString(template)) { return renderTemplateString(template, scope, data); } else if (_.isArray(template)) { return _.map(template, function(x) { return renderTemplate(x, scope, data); }); } else if (_.isPlainObject(template)) { return _.mapValues(template, function(x) { return renderTemplate(x, scope, data); }); } else { return template; } } function renderTemplateString(s, scope, data) { //console.log(&quot;renderTemplateString:&quot;, s) assert(_.isString(s)); if (_.startsWith(s, &quot;${&quot;) &amp;&amp; _.endsWith(s, &quot;}&quot;)) { var name = s.substr(2, s.length - 3); return scope[name]; } else if (_.startsWith(s, &quot;{{&quot;) &amp;&amp; _.endsWith(s, &quot;}}&quot;)) { const s2 = Handlebars.compile(s)(scope); try { return JSON.parse(s2); } catch (e) { } return s2; } else { return Handlebars.compile(s)(scope); } } module.exports = { extractValuesFromQueryResults, getObjectsOfType, getObjectsValue, getVariableValue, handleDirective, handleDirectiveDeep, findObjectsValue, mutateDeep, mapDeep, renderTemplate } × Search results Close "},"parsers_wellsParser.js.html":{"id":"parsers_wellsParser.js.html","title":"Source: parsers/wellsParser.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: parsers/wellsParser.js /** * Module for parsing strings that represent wells and labware. * @module */ var _ = require('lodash'); var assert = require('assert'); var random = require('random-js'); var expect = require('../expectCore.js'); var misc = require('../misc.js'); var wellsParser0 = require('./wellsParser0.js'); /** * Take a well identifier (e.g. A01) and returns an integer array * representing the row and column of that well. * @param {string} location - a well identifier starting with a capital letter and followed by a number (e.g. A01) * @return {array} an integer array of `[row, col]`. The values are 1-based (i.e. row 1 is the first row) * @static */ function locationTextToRowCol(location) { var row = location.charCodeAt(0) - &quot;A&quot;.charCodeAt(0) + 1; var col = parseInt(location.substr(1)); return [row, col]; } /** * Converts a row and column index to a string. * For example, `[1, 1] =&gt; A01`, and `[8, 12] =&gt; H12`. * @param {number} row - row of well * @param {number} col - column of well * @return {string} string representation of location of well on labware * @static */ function locationRowColToText(row, col) { var colText = col.toString(); if (colText.length == 1) colText = &quot;0&quot;+colText; return String.fromCharCode(&quot;A&quot;.charCodeAt(0) + row - 1) + colText; } /** * Parses a text which should represent one or more labwares and wells. * If the `objects` parameter is passed, this function will return an array of the individual wells; * otherwise it will return the raw parser results. * * @param {string} text - text to parse * @param {object} objects - map of protocol objects, in order to find labwares and number of rows and columns on labware. * @param {object} [config] - optional object that contains properties for 'rows' and 'columns', in case we want to expand something like 'A1 down C3' without having specified a plate * @return {array} If the `objects` parameter is passed, this function will return an array of the individual wells; otherwise it will return the raw parser results. * @static */ function parse(text, objects, config) { assert(_.isString(text), &quot;wellsParser.parse() expected a string, received: &quot;+text) var result; try { result = wellsParser0.parse(text); } catch (e) { expect.rethrow(e); } if (!objects) return result; return processParserResult(result, objects, text, config); } /** * Take the raw parser results and return an array of location names, * one entry for each well. * @param {array} result - raw parser results. * @param {object} objects - map of protocol objects, in order to find labwares and number of rows and columns on labware. * @param {string} text - the original text that was parsed; this is merely used for error output. * @param {object} [config] - optional object that contains properties for 'rows' and 'columns', in case we want to expand something like 'A1 down C3' without having specified a plate * @return {array} array of names for each plate + well (e.g. `plate1(C04)`) */ function processParserResult(result, objects, text, config = {}) { var commandHelper = require('../commandHelper.js'); //console.log(&quot;text&quot;, text) //console.log(&quot;result&quot;, result) //console.log(&quot;result:\\n&quot;+JSON.stringify(result, null, ' ')); var ll = _.map(result, function(clause) { const data = {objects}; // Get source or labware objects //console.log({commandHelper}) const parsed = commandHelper.parseParams(clause, data, { properties: { source: {}, labware: {}, //subject: 'Any?' } }); // console.log({clause, parsed}); if (parsed.value.source) { // If this was a source, return its wells if (parsed.value.source.type === 'Source' || parsed.value.source.type === 'Liquid') return [parsed.value.source.wells]; // Handle the case of when a variable is used and here we can substitute in its value else if (_.isString(parsed.value.source) &amp;&amp; parsed.value.source !== clause.source) return parse(parsed.value.source, objects); // Else else { // console.log({clause, parsed}) expect.throw({}, &quot;unrecognized source specifier: &quot;+JSON.stringify(parsed.value.source)); } } else if (parsed.value.labware || (config.rows &amp;&amp; config.columns)) { // Get number of rows and columns let rows, columns; let labwareName; if (parsed.value.labware) { const labware = parsed.value.labware; labwareName = parsed.objectName.labware; var modelName = labware.model; assert(modelName, &quot;`&quot;+labwareName+&quot;.model` missing&quot;); var model = misc.getObjectsValue(modelName, objects); assert(model.rows, &quot;`&quot;+modelName+&quot;.rows` missing&quot;); assert(model.columns, &quot;`&quot;+modelName+&quot;.columns` missing&quot;); rows = model.rows; columns = model.columns; } else { rows = config.rows; columns = config.columns; } var l = []; if (clause.subject === 'all') { for (var col = 1; col &lt;= columns; col++) { for (var row = 1; row &lt;= rows; row++) { l.push([row, col]); } } } else { l.push(locationTextToRowCol(clause.subject)); } if (clause.phrases) { _.forEach(clause.phrases, function(phrase) { switch (phrase[0]) { case &quot;down&quot;: assert(l.length == 1, &quot;`down` can only be used with a single well&quot;); var rc0 = l[0]; var n = phrase[1]; assert(n &gt;= 1, &quot;`down n` must be positive: &quot;+text); var row = rc0[0]; var col = rc0[1]; for (var i = 1; i &lt; n; i++) { row++; if (row &gt; rows) { row = 1; col++; if (col &gt; columns) { throw {name: &quot;RangeError&quot;, message: &quot;`&quot;+text+&quot;` extends beyond range of labware `&quot;+labwareName+&quot;`&quot;}; } } l.push([row, col]) } break; case &quot;down-to&quot;: assert(l.length == 1, &quot;`down` can only be used with a single well&quot;); var rc0 = l[0]; var rc1 = locationTextToRowCol(phrase[1]); assert(rc0[1] &lt; rc1[1] || rc0[0] &lt;= rc1[0], &quot;invalid target for `down`: &quot;+text) assert(rc0[1] &lt;= rc1[1], &quot;column of `&quot;+phrase[1]+&quot;` must be equal or greater than origin: &quot;+text); var row = rc0[0]; var col = rc0[1]; while (row !== rc1[0] || col != rc1[1]) { row++; if (row &gt; rows) { row = 1; col++; if (col &gt; columns) { throw {name: &quot;RangeError&quot;, message: &quot;`&quot;+text+&quot;` extends beyond range of labware `&quot;+labwareName+&quot;`&quot;}; } } l.push([row, col]) } break; case &quot;down-block&quot;: assert(l.length == 1, &quot;`block` can only be used with a single well&quot;); var rc0 = l[0]; var rc1 = locationTextToRowCol(phrase[1]); assert(rc0[0] &lt;= rc1[0], &quot;row of `&quot;+phrase[1]+&quot;` must be equal or greater than origin: &quot;+text); assert(rc0[1] &lt;= rc1[1], &quot;column of `&quot;+phrase[1]+&quot;` must be equal or greater than origin: &quot;+text); var row = rc0[0]; var col = rc0[1]; while (row !== rc1[0] || col != rc1[1]) { row++; if (row &gt; rc1[0]) { row = rc0[0]; col++; } l.push([row, col]) } break; case &quot;right&quot;: assert(l.length == 1, &quot;`right` can only be used with a single well&quot;); var rc0 = l[0]; var n = phrase[1]; assert(n &gt;= 1, &quot;`right n` must be positive: &quot;+text); var row = rc0[0]; var col = rc0[1]; for (var i = 1; i &lt; n; i++) { col++; if (col &gt; columns) { row++; col = 1; if (row &gt; rows) { throw {name: &quot;RangeError&quot;, message: &quot;`&quot;+text+&quot;` extends beyond range of labware `&quot;+labwareName+&quot;`&quot;}; } } l.push([row, col]) } break; case &quot;right-to&quot;: assert(l.length == 1, &quot;`right` can only be used with a single well&quot;); var rc0 = l[0]; var rc1 = locationTextToRowCol(phrase[1]); assert(rc0[0] &lt; rc1[0] || rc0[1] &lt;= rc1[1], &quot;invalid target for `right`: &quot;+text) assert(rc0[0] &lt;= rc1[0], &quot;row of `&quot;+phrase[1]+&quot;` must be equal or greater than origin: &quot;+text); var row = rc0[0]; var col = rc0[1]; while (row !== rc1[0] || col != rc1[1]) { col++; if (col &gt; columns) { col = 1; row++; if (row &gt; rows) { throw {name: &quot;RangeError&quot;, message: &quot;`&quot;+text+&quot;` extends beyond range of labware `&quot;+labwareName+&quot;`&quot;}; } } l.push([row, col]) } break; case &quot;right-block&quot;: assert(l.length == 1, &quot;`block` can only be used with a single well&quot;); var rc0 = l[0]; var rc1 = locationTextToRowCol(phrase[1]); assert(rc0[0] &lt;= rc1[0], &quot;row of `&quot;+phrase[1]+&quot;` must be equal or greater than origin: &quot;+text); assert(rc0[1] &lt;= rc1[1], &quot;column of `&quot;+phrase[1]+&quot;` must be equal or greater than origin: &quot;+text); var row = rc0[0]; var col = rc0[1]; while (row !== rc1[0] || col != rc1[1]) { col++; if (col &gt; rc1[1]) { col = rc0[1]; row++; } l.push([row, col]) } break; case &quot;random&quot;: // Initialize randomizing engine var mt = random.engines.mt19937(); if (phrase.length == 2) { mt.seed(phrase[1]); } else { mt.autoSeed(); } // Randomize the list var rest = _.clone(l); random.shuffle(mt, rest); //console.log(&quot;rest:&quot;, rest); // Now try to not repeated pick the sames rows or columns var l2 = []; var choices = []; while (rest.length &gt; 0) { if (choices.length == 0) choices = _.clone(rest); //console.log(&quot;choices:&quot;, JSON.stringify(choices)); // Pick the first choice in list var rc = _.pullAt(choices, 0)[0]; // Add it to our new list l2.push(rc); // Remove it from 'rest' rest = _.without(rest, rc); // Remove all items from choices with the same row or column _.remove(choices, function(rc2) { return (rc2[0] == rc[0] || rc2[1] == rc[1]); }); } l = l2; break; case &quot;take&quot;: var n = phrase[1]; assert(n &gt;= 0); l = _.take(l, n); break; case &quot;row-jump&quot;: // Number of rows of space to leave between rows var n = phrase[1]; expect.truthy(null, n &gt;= 0, &quot;row-jump value must be &gt;= 0&quot;); var cycleLen = n + 1; var l2 = []; while (l.length &gt; 0) { // Get consecutive rc's that are in the same col var col = l[0][1]; var sameCol = _.takeWhile(l, function(rc) { return rc[1] == col; }); l = _.drop(l, sameCol.length); //console.dir(sameCol); while (sameCol.length &gt; 0) { var row = sameCol[0][0]; var l3 = _.remove(sameCol, function(rc) { return (((rc[0] - row) % cycleLen) === 0); }); //console.log(row, l3, sameCol); l2 = l2.concat(l3); } } l = l2; break; default: assert(false, &quot;unhandled verb: &quot;+phrase[0]); } }); } // Convert the list of row/col back to text return _.map(l, function(rc) { var location = locationRowColToText(rc[0], rc[1]); return (labwareName) ? labwareName+'('+location+')' : location; }); } else if (clause.subject) { assert(_.isEmpty(clause.phrases)); return clause.subject; } else { assert(false); } }); //console.log(&quot;ll:&quot;) //console.log(ll); return _.flatten(ll); } /** * Parses a string which should represent a single well, and return the raw * parser results. * * @param {string} text - text to parse * @return {object} an object representing the raw parser results. * @static */ function parseOne(text) { assert(_.isString(text), &quot;wellsParser.parseOne() expected a string, received: &quot;+JSON.stringify(text)) try { return wellsParser0.parse(text, {startRule: 'startOne'}); } catch (e) { throw e; //throw Error(e.toString()); } } module.exports = { locationRowColToText, locationTextToRowCol, parse, parseOne, processParserResult, }; × Search results Close "},"roboliq.js.html":{"id":"roboliq.js.html","title":"Source: roboliq.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: roboliq.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Roboliq's top module with functions for processing protocols. * @module roboliq */ /** * Protocol specification. * @typedef {Object} Protocol * @property {Object} objects * @property {Object} steps * @property {Object} effects * @property {Array} predicates * @property {Object} directiveHandlers * @property {Object} objectToPredicateConverters * @property {Object} commandHandlers * @property {Object} planHandlers * @property {Object} files * @property {Object} errors * @property {Object} warnings */ /** * Command handler result. * @typedef {Object} CommandHandlerResult * @property {Array} errors - array of error strings * @property {Array} warnings - array of warning strings * @property {Object|Array} expansion - an array or map of sub-steps * @property {Object} effects - a map of object property effects * @property {Object} alternatives - ??? */ Error.stackTraceLimit = Infinity; /** * Well contents. * * Well contents are encoded as an array. * The first element always holds the volume in the well. * If the array has exactly one element, the volume should be 0l. * If the array has exactly two elements, the second element is the name of the substance. * If the array has more than two elements, each element after the volume has the same * structure as the top array and they represent the mixture originally dispensed in the well. * * objects: * plate1: * contents: * A01: [&quot;30ul&quot;, [&quot;25ul&quot;, &quot;water&quot;], [&quot;5ul&quot;, &quot;reagent1&quot;]] * @typedef {array} WellContents */ var _ = require('lodash'); var assert = require('assert'); var fs = require('fs'); import handlebars from 'handlebars'; var jiff = require('jiff'); var jsonfile = require('jsonfile'); import mkdirp from 'mkdirp'; import naturalSort from 'javascript-natural-sort'; var path = require('path'); var yaml = require('yamljs'); import commandHelper from './commandHelper.js'; var expect = require('./expect.js'); var misc = require('./misc.js'); import stripUndefined from './stripUndefined.js'; import * as WellContents from './WellContents.js'; var wellsParser = require('./parsers/wellsParser.js'); import * as Design from './design.js'; const version = &quot;v1&quot;; const nomnom = require('nomnom').options({ infiles: { position: 0, help: 'input files, .json or .js', list: true }, debug: { abbr: 'd', flag: true, help: 'Print debugging info' }, evoware: { help: &quot;Invoke evoware supplier and pass the comma-separated arguements&quot; }, fileData: { full: 'file-data', list: true, help: &quot;Supply filedata on the command line in the form of 'filename:filedata'&quot; }, fileJson: { full: 'file-json', list: true, help: &quot;Supply a JSON file on the command line in the form of 'filename:filedata'&quot; }, loadRoboliqConfig: { full: 'load-roboliq-config', flag: true, default: true }, output: { abbr: 'o', help: 'specify output filename or &quot;&quot; for none; otherwise the default filename is used', metavar: 'FILE' }, outputDir: { abbr: 'O', full: 'output-dir', help: 'specify output directory', metavar: 'DIR' }, parentDir: { abbr: 'P', full: 'parent-dir', help: &quot;specify output's parent directory, under which a new subdirectory will be created with the protocol's name&quot;, metavar: 'DIR' }, print: { abbr: 'p', flag: true, help: 'print output' }, printProtocol: { abbr: 'r', full: 'print-protocol', flag: true, help: 'print combined protocol' }, printDesigns: { full: 'print-designs', flag: true, help: 'print design tables' }, progress: { flag: true, help: 'print progress indicator while processing the protocol' }, quiet: { flag: true, help: &quot;suppress printing of information, erros, and warning&quot; }, subdir: { abbr: 'S', full: 'subdir', help: &quot;specify an extra subdirectory beneath the parent directory; for use when grouping several protocols together.&quot;, metavar: 'DIR' }, throw: { abbr: 'T', flag: true, help: 'throw error when errors encountered during processing (in order to get a backtrace)' }, varset: { help: &quot;Variable set to load&quot;, list: true }, version: { flag: true, help: 'print version and exit', callback: function() { return &quot;version &quot;+version; } }, }); const protocolEmpty = { objects: {}, steps: {}, effects: {}, predicates: [], directiveHandlers: {}, objectToPredicateConverters: {}, schemas: {}, commandHandlers: {}, planAlternativeChoosers: {}, planHandlers: {}, files: {}, fillIns: {}, reports: {}, errors: {}, warnings: {}, COMPILER: {}, }; /** * Loads the raw content at the given URL. * Supported formats are: JSON, YAML, JavaScript, and pre-cached file data. * * @param {string} url - URL to load. * @param {object} filecache - map of cached file data, map from URL to data. * @return content at URL. */ function loadUrlContent(url, filecache) { url = path.posix.join(url); //if (!path.isAbsolute(url)) if (!path.isAbsolute(url)) url = &quot;./&quot; + url; //console.log(&quot;in cache:&quot;, filecache.hasOwnProperty(url)) const absolutePath = path.resolve(url); if (filecache.hasOwnProperty(url)) return filecache[url]; else if (path.extname(url) === &quot;.yaml&quot;) return yaml.load(url); else if (path.extname(url) === &quot;.json&quot;) return jsonfile.readFileSync(url); else { let relativePath = path.relative(__dirname, absolutePath); if (!_.startsWith(relativePath, &quot;.&quot;)) { relativePath = &quot;./&quot; + relativePath; } //console.log({url, absolutePath, relativePath, __dirname}) return require(relativePath); } } /** * Finishing loading/processing an unprocessed protocol: handle imports, directives, and file nodes * @param {Object} a - Previously loaded protocol data * @param {Object} b - The protocol to pre-process * @param {String} [url] - The url of the protocol * @return {Object} protocol with */ function loadProtocol(a, b, url, filecache) { // Require 'roboliq' property expect.truthy({}, b.roboliq, &quot;'roboliq' property must be specified with targetted version number for protocol at URL &quot;+url); //console.log(&quot;loadProtocol:&quot;, url); //if (url.indexOf(&quot;roboliq&quot;) &gt; 0) // console.log(JSON.stringify(b)) // Handle imports var imported = _.cloneDeep(protocolEmpty); if (b.imports) { var urls = _.map(_.flatten([b.imports]), function(imp) { // console.log(&quot;paths:&quot;, path.dirname(url), imp, path.join(path.dirname(url), imp)) const path1 = path.posix.join(path.dirname(url), imp); const path2 = (_.startsWith(path1, &quot;/&quot;)) ? path1 : `./${path1}`; //console.log({url, absolutePath, relativePath, __dirname}) return path2; }); var protocols2 = _.map(urls, function(url2) { // console.log(&quot;url:&quot;, url2) var protocol2 = loadUrlContent(url2, filecache); return loadProtocol(protocolEmpty, protocol2, url2, filecache); }); imported = mergeProtocolList(protocols2); } if (_.isPlainObject(b.files) &amp;&amp; !_.isEmpty(b.files)) { _.merge(filecache, b.files) } /* // Add variables to `objects` // TODO: Remove this in favor of (ellis 2016-11-09) if (b.variables) { _.forEach(b.variables, (value, key) =&gt; { b.objects[key] = _.merge({}, {type: &quot;Variable&quot;}, value); }); }*/ // Add parameters to `objects.PARAMS` if (b.parameters) { // console.log(&quot;parameters&quot;) _.forEach(b.parameters, (param, key) =&gt; { // console.log(&quot;parameter: &quot;+key) // If this parameter needs to be 'calculate'd const value0 = param.calculate || param.value; expect.try({path: key, paramName: &quot;value&quot;}, () =&gt; { const calculate = _.cloneDeep(value0); const data = { objects: {PARAMS: _.merge({}, _.get(a, [&quot;objects&quot;, &quot;PARAMS&quot;]), _.get(b, [&quot;objects&quot;, &quot;PARAMS&quot;]))}, directiveHandlers: _.merge({}, a.directiveHandlers, b.directiveHandlers) }; // console.log({data}) const value = expandDirectivesDeep(calculate, data); // console.log({value0, calculate, value}) param.value = value; }); _.set(b.objects, [&quot;PARAMS&quot;, key], param.value); }); } // Create a clone keeping only valid protocol properties. var c = _.cloneDeep(_.pick(b, &quot;description&quot;, &quot;config&quot;, &quot;parameters&quot;, &quot;objects&quot;, &quot;steps&quot;, &quot;effects&quot;, &quot;predicates&quot;, &quot;directiveHandlers&quot;, &quot;objectToPredicateConverters&quot;, &quot;schemas&quot;, &quot;commandHandlers&quot;, &quot;planAlternativeChoosers&quot;, &quot;planHandlers&quot;, &quot;files&quot;, &quot;errors&quot;, &quot;warnings&quot;, &quot;COMPILER&quot; )); if (_.isUndefined(c.errors)) { c.errors = {}; } // Pre-process properties with ?-suffixes and !-suffixes. if (!c.fillIns) c.fillIns = {}; preProcessQuestionMarks(c, c.objects, ['objects']); preProcessQuestionMarks(c, c.steps, ['steps']); // console.log(&quot;A: &quot;+JSON.stringify(c.fillIns[&quot;objects.plate1.model&quot;])) preProcessExclamationMarks(c, c.objects, ['objects']); preProcessExclamationMarks(c, c.steps, ['steps']); var data = { objects: _.merge({}, a.objects, imported.objects, c.objects), directiveHandlers: _.defaults({}, b.directiveHandlers, imported.directiveHandlers, a.directiveHandlers) }; // Handle directives for predicates var l = [ 'predicates' ]; _.forEach(l, function(key) { // console.log({key, c: c[key]}) misc.mutateDeep(c[key], function(x) { return misc.handleDirective(x, data); }); }); // Deep mutation for two modifications: // 1. Handle file nodes, resolve path relative to current directory, add to &quot;files&quot; key of protocol // 2. Substitute parameter values misc.mutateDeep(c, function(x) { //console.log(&quot;x: &quot;+x) if (_.isString(x)) { // Return filename relative to current directory if (_.startsWith(x, &quot;./&quot;) || _.startsWith(x, &quot;../&quot;)) { var filename = &quot;./&quot; + path.posix.join(path.dirname(url), x); // If the file hasn't been loaded yet: if (!filecache.hasOwnProperty(filename)) { // console.log(&quot;try to load &quot;+filename); try { var filedata = fs.readFileSync(filename); filecache[filename] = filedata; //console.log(&quot;filename: &quot;+filename); //console.log(filedata); //console.log(filedata.toString('utf8')) } catch (e) { c.errors[url] = [`could not load file (${filename})`, e.toString()]; } } return filename; } // Substitute parameter value else if (_.startsWith(x, &quot;$#&quot;)) { // HACK: modified from misc.handleDirective const key = x.substr(2); const value = _.get(c, [&quot;parameters&quot;, key, &quot;value&quot;]) || _.get(imported, [&quot;parameters&quot;, key, &quot;value&quot;]); if (_.isUndefined(value)) { throw new Error(&quot;undefined parameter value: &quot;+x); } return value; } } return x; }); // Merge in the imports var d = mergeProtocols(imported, c); //if (url.indexOf(&quot;roboliq&quot;) &gt; 0) //if (c.objects &amp;&amp; !c.predicates) // console.log(JSON.stringify(c, null, '\\t')); // console.log(&quot;B: &quot;+JSON.stringify(d.fillIns[&quot;objects.plate1.model&quot;])) return d; } /** * Remove properties with '?'-suffix. If the propery value has a 'value!' property, * add a new property to the object without the '?'-suffix and with the given value. * Mutates the object. * Also add the path to the property to the protocol's `fillIns` * @param {Protocol} protocol * @param {any} obj * @param {array} path */ function preProcessQuestionMarks(protocol, obj, path) { // console.log(&quot;preProcessQuestionMarks&quot;) if (_.isPlainObject(obj)) { const pairs0 = _.toPairs(obj); let changed = false; const pairs1 = pairs0.map(pair =&gt; { const [name, value] = pair; if (_.endsWith(name, &quot;?&quot;)) { // console.log(&quot;endsWith: &quot;+name) changed = true; const name1 = name.slice(0, -1); if (value.hasOwnProperty('value!')) { return [name1, value['value!']]; } else { protocol.fillIns[path.concat(name1).join('.')] = value || {}; // console.log(`protocol.fillIns[${path.concat(name1).join('.')}] = ${JSON.stringify(value)}`) return null; } } else { preProcessQuestionMarks(protocol, value, path.concat(name)); return [name, obj[name]]; } }); if (changed) { // Remove all properties pairs0.forEach(pair =&gt; delete obj[pair[0]]); // Add them all back in again, with new names/values _.compact(pairs1).forEach(pair =&gt; obj[pair[0]] = pair[1]); } } else if (_.isArray(obj)) { _.forEach(obj, (value, index) =&gt; { preProcessQuestionMarks(protocol, value, path.concat(index)); }); } } /** * Any properties that have a &quot;!&quot; suffix are renamed to not have that suffix, * overwritting an already existing property if necessary. * Mutates the object. * @param {Protocol} protocol * @param {any} obj * @param {array} path */ function preProcessExclamationMarks(protocol, obj, path) { //console.log(JSON.stringify(obj)); if (_.isPlainObject(obj)) { const pairs0 = _.toPairs(obj); let changed = false; const obj1 = []; for (var i = 0; i &lt; pairs0.length; i++) { const [name, value] = pairs0[i]; if (_.endsWith(name, &quot;!&quot;)) { changed = true; const name1 = name.slice(0, -1); obj1[name1] = value; } // if an object has both ! and non ! properties, the ! property should take precedence else if (!obj1.hasOwnProperty(name)) { preProcessExclamationMarks(protocol, value, path.concat(name)); obj1[name] = obj[name]; } } if (changed) { // Remove all properties pairs0.forEach(pair =&gt; delete obj[pair[0]]); // Add them all back in again, with new names/values const pairs1 = _.toPairs(obj1); pairs1.forEach(pair =&gt; obj[pair[0]] = pair[1]); } } else if (_.isArray(obj)) { _.forEach(obj, (value, index) =&gt; { preProcessExclamationMarks(protocol, value, path.concat(index)); }); } } /** * Merge protocols A &amp; B, returning a new protocol. * * @param {Object} a protocol representing the result of all previous mergeProtocols * @param {Object} b newly loaded protocol to merge into previous protocols * @return {Object} result of merging protocol B into A. */ function mergeProtocols(a, b) { //console.log(&quot;BEFORE&quot;) //console.log(&quot;a.predicates: &quot;+JSON.stringify(a.predicates)); //console.log(&quot;b.predicates: &quot;+JSON.stringify(b.predicates)); var c = _.merge({}, _.omit(a, 'predicates'), _.omit(b, 'predicates')); //console.log(&quot;AFTER&quot;) //console.log(&quot;a.predicates: &quot;+JSON.stringify(a.predicates)); //console.log(&quot;b.predicates: &quot;+JSON.stringify(b.predicates)); c.predicates = a.predicates.concat(b.predicates || []); //console.log(&quot;c:&quot;, c); return c; } /** * Merge a list of protocols. * * @param {array} protocols - list of protocols. * @return {Protocol} merged protocol. */ function mergeProtocolList(protocols) { var protocol = _.cloneDeep(protocolEmpty); _.forEach(protocols, function(b) { protocol = mergeProtocols(protocol, b); }); return protocol; } /** * Post-process protocol: flatten predicate list, parse wells strings for Liquid objects. * * Mutates the passed protocol. * * @param {Object} protocol A protocol. */ function postProcessProtocol(protocol, filecache) { // Make sure predicates is a flat list protocol.predicates = _.flattenDeep(protocol.predicates); // Calculate values for variables postProcessProtocol_variables(protocol, filecache); // For all liquids, if they specify source wells, make sure the source well // has a reference to the liquid in its contents (the contents will be added // if necessary). var liquids = misc.getObjectsOfType(protocol.objects, 'Liquid'); _.forEach(liquids, function(liquid, name) { if (_.isString(liquid.wells)) { try { liquid.wells = wellsParser.parse(liquid.wells, protocol.objects); _.forEach(liquid.wells, function(well) { var pair = WellContents.getContentsAndName(well, protocol); // If well already has contents: if (pair[0]) { assert(_.isEqual(_.tail(pair[0]), [name]), &quot;well &quot;+well+&quot; already contains different contents: &quot;+JSON.stringify(pair[0])); // Don't need to set contents, leave as is with the given volume. } else { var path = pair[1]; _.set(protocol.objects, path, ['Infinity l', name]); } }); } catch (e) { protocol.errors[name+&quot;.wells&quot;] = [e.toString(), e.stack]; //console.log(e.toString()); } } }); } /** * For all variables that have a `calculate` property, handle the calculation and put the * result in the `value` property. * For 'Data' objects: * if it doesn't have a value, call `Design.flattenDesign`; * if its value is a filename, load the file into the value * * Mutates protocol. * * @param {Protocol} protocol - The protocol to inspect. */ function postProcessProtocol_variables(protocol, filecache) { const data = _.clone(protocol); _.forEach(protocol.objects, (obj, key) =&gt; { expect.try({path: key, paramName: &quot;calculate&quot;}, () =&gt; { // console.log(&quot;postProcessProtocol_variables key: &quot;+key); // If this is a variable with a 'calculate' property if (obj.type === &quot;Variable&quot; &amp;&amp; obj.calculate) { const calculate = _.cloneDeep(obj.calculate); const value = expandDirectivesDeep(calculate, data); // console.log(&quot;postProcessProtocol_variables value: &quot;+value); obj.value = value; } }); expect.try({path: key, paramName: &quot;valueFile&quot;}, () =&gt; { if (obj.type === &quot;Data&quot; &amp;&amp; obj.valueFile) { // console.log(&quot;postProcessProtocol_variables files: &quot;+JSON.stringify(filecache[obj.valueFile])); assert(filecache.hasOwnProperty(obj.valueFile), &quot;file not in cache: &quot;+obj.valueFile); const filedata = filecache[obj.valueFile].toString('utf8'); // console.log(&quot;filedata: &quot;+filedata); const rows = filedata.split(&quot;\\n&quot;).map(s =&gt; s.trim()).filter(s =&gt; s != &quot;&quot;); // console.log(&quot;rows: &quot;+rows); const value = rows.map(s =&gt; JSON.parse(s)); // console.log({value}); obj.value = value; } }); }); } // Recursively expand all directives function expandDirectivesDeep(x, data) { if (_.isPlainObject(x)) { for (var key in x) { var value1 = x[key]; if (_.isArray(value1)) { x[key] = _.map(value1, function(x2) { return misc.handleDirectiveDeep(x2, data); }); } else { x[key] = expandDirectivesDeep(value1, data); } } } // Make sure this property exists in order to avoid an exception if (!data.hasOwnProperty(&quot;accesses&quot;)) { data.accesses = []; } return misc.handleDirective(x, data); } /** * Perorms a schema check, makes sure that all objects are valid. * * Throws an error if the protocol isn't valid. * * @param {Protocol} protocol - The protocol to validate. */ function validateProtocol1(protocol, o, path) { // console.log({objects: protocol.objects}) if (_.isUndefined(o)) { o = protocol.objects; path = []; } for (const [name, value] of _.toPairs(o)) { const path2 = path.concat(name); const fullName = path2.join(&quot;.&quot;); const doit = () =&gt; { //console.log({name, value, fullName}) if (name !== 'type' &amp;&amp; name !== &quot;DATA&quot; &amp;&amp; name !== &quot;SCOPE&quot; &amp;&amp; name !== &quot;PARAMS&quot;) { assert(!_.isEmpty(value.type), &quot;Missing `type` property: &quot;+JSON.stringify(value)); if (value.type === &quot;Namespace&quot;) { validateProtocol1(protocol, value, path.concat(name)); } else { const schema = protocol.schemas[value.type]; assert(schema, &quot;Unknown type: &quot;+value.type); if (schema) { const data = { objects: protocol.objects, predicates: protocol.predicates, planAlternativeChoosers: protocol.planAlternativeChoosers, planHandlers: protocol.planHandlers, schemas: protocol.schemas, accesses: [], files: protocol.files, // or filecache? protocol, path: [fullName] }; commandHelper.parseParams(value, data, schema); } } } } expect.context({objectName: fullName}, doit); } } function run(argv, userProtocol, loadRoboliqProcessorYaml = true) { argv = argv || process.argv.slice(2); if (loadRoboliqProcessorYaml &amp;&amp; fs.existsSync(&quot;roboliq-processor.yaml&quot;)) { const env = yaml.load(&quot;roboliq-processor.yaml&quot;); if (env.preload) { argv = env.preload.concat(argv); } if (env.args) { argv = env.args.concat(argv); } } // Validate the command line arguments var opts = nomnom.parse(argv); if (_.isEmpty(opts.infiles) &amp;&amp; !userProtocol) { console.log(nomnom.getUsage()); if (require.main === module) { process.exit(0); } } else { return runWithOpts(opts, userProtocol); } } /** * Process a roboliq protocol. * * @param {array} argv - command line options. * @param {Protocol} [userProtocol] - an optional protocol that can be directly passed into the function rather than supplied via argv; currently this is only for testing purposes. * @return {object} Processing results with properties `output` (the final processed protocol) and `protocol` (the result of merging all input protocols). */ function runWithOpts(opts, userProtocol) { // Configure mathjs to use bignumbers require('mathjs').config({ number: 'BigNumber', // Default type of number precision: 64 // Number of significant digits for BigNumbers }); // Try to process the protocol var result = undefined; try { result = _run(opts, userProtocol); } catch (e) { // If _run throws an exception, we don't get any results, // so try to set `error` in the result or at least print // messages to the console. if (opts.debug || opts.throw) { console.log(&quot;RUN ERROR:&quot;) console.log(e); console.log(e.message); console.log(e.stack); } if (e.isRoboliqError) { result = {}; const errors = expect.RoboliqError.getErrors(e); const path = e.path || &quot;&quot;; _.set(result, `output.errors[${path}]`, errors); //console.log(JSON.stringify(errors)) } else if (!opts.quiet) { console.log(JSON.stringify(e)); } } // If processing finished without exceptions: if (result &amp;&amp; result.output) { if (!opts.quiet) { // Print errors, if any: if (!_.isEmpty(result.output.errors)) { console.log(); console.log(&quot;Errors:&quot;); if (_.isPlainObject(result.output.errors)) { // Find all sub-steps (properties that start with a digit) var keys = _.keys(result.output.errors); // Sort them in &quot;natural&quot; order keys.sort(naturalSort); _.forEach(keys, key =&gt; { const err = result.output.errors[key]; console.log(key+&quot;: &quot;+err.toString()); }); } else { _.forEach(result.output.errors, function(err, id) { if (id) console.log(id+&quot;: &quot;+err.toString()); else console.log(err.toString()); }); } } // Print warnings, if any: if (!_.isEmpty(result.output.warnings)) { console.log(); console.log(&quot;Warnings:&quot;); _.forEach(result.output.warnings, function(err, id) { if (id) console.log(id+&quot;: &quot;+err.toString()); else console.log(err.toString()); }); } } if (opts.debug) { console.log(); console.log(&quot;Output:&quot;); } var outputText = JSON.stringify(result.output, null, '\\t'); if (opts.debug || opts.print) console.log(outputText); // If compilation was suspended, crease a dumpfile for later continuation if (_.get(result, [&quot;protocol&quot;, &quot;COMPILER&quot;, &quot;suspend&quot;])) { result.dump = _.clone(result.protocol); // Resume where this compilation suspended result.dump.COMPILER = { resumeStepId: result.protocol.COMPILER.suspendStepId }; } // If the output is not suppressed, write the protocol to an output file. if (opts.output !== '') { var inpath = _.last(opts.infiles); var basename = path.basename(inpath, path.extname(inpath)); var dir = (opts.outputDir) ? opts.outputDir : (opts.parentDir) ? (opts.subdir) ? path.join(opts.parentDir, opts.subdir, basename) : path.join(opts.parentDir, basename) : path.dirname(inpath); var outpath = opts.output || path.join(dir, basename+&quot;.out.json&quot;); if (!opts.quiet) { console.log(&quot;output written to: &quot;+outpath); } // Write output protocol mkdirp.sync(path.dirname(outpath)); fs.writeFileSync(outpath, JSON.stringify(result.output, null, '\\t')+&quot;\\n&quot;); // Write extra files if parentDir or outputDir was specified // console.log({a: !_.isEmpty(result.output.simulatedOutput), b: opts.parentDir}) if (opts.parentDir || opts.outputDir) { if (!_.isEmpty(result.output.simulatedOutput)) { writeSimulatedOutput(opts, dir, result); } writeHtml(opts, dir, result); } // Write dump data (2016-11-05 ELLIS: What's this for??) if (result.dump) { const dumppath = path.join(path.dirname(output), `${result.dump.COMPILER.resumeStepId}.dump.json`); if (!opts.quiet) { console.log(&quot;dump written to: &quot;+dumppath); } fs.writeFileSync(dumppath, JSON.stringify(result.dump, null, '\\t')+&quot;\\n&quot;); } // Send through the Evoware compiler if (opts.evoware) { const evowareArgs = _.clone(opts.evoware.split(&quot;,&quot;)); assert(evowareArgs.length &gt;= 3, &quot;at least three arguments must be passed to --evoware options: carrier file, table file, and one or more agent names&quot;); // Insert const evowareRun = require(&quot;roboliq-evoware/dist/EvowareMain&quot;).run; evowareArgs.splice(2, 0, outpath); if (!opts.quiet) { console.log(`calling evoware: ${evowareArgs.join(&quot; &quot;)}`); } evowareRun({args: evowareArgs}); } } } return result; } function writeSimulatedOutput(opts, dir, result) { const simulatedDir = path.join(dir, &quot;simulated&quot;); // console.log({simulatedDir}) mkdirp.sync(simulatedDir); _.forEach(result.output.simulatedOutput, (value, filename) =&gt; { const simulatedFile = path.join(simulatedDir, filename); // console.log({filename, simulatedFile}) if (!opts.quiet) { console.log(&quot;saving simulated output: &quot;+simulatedFile); } const ext = path.extname(simulatedFile); if (ext === &quot;.json&quot;) { fs.writeFileSync(simulatedFile, JSON.stringify(value, null, &quot;\\t&quot;)+&quot;\\n&quot;); } else if (ext === &quot;.jsonl&quot;) { const contents = value.map(x =&gt; JSON.stringify(x)).join(&quot;\\n&quot;) + &quot;\\n&quot;; fs.writeFileSync(simulatedFile, contents); } else { fs.writeFileSync(simulatedFile, value); } }); } function writeHtml(opts, dir, result) { const source = fs.readFileSync(__dirname + &quot;/html/index.html&quot;, &quot;utf8&quot;); const template = handlebars.compile(source); const html = template(result.output); const filename = path.join(dir, &quot;index.html&quot;); if (!opts.quiet) { console.log(&quot;saving HTML output: &quot;+filename); } fs.writeFileSync(filename, html); } /** * Process the protocol(s) given by the command line options and an optional * userProtocol passed in separately to the API (currently this is just for testing). * * @param {object} opts - command line arguments as processed by nomnom. * @param {Protocol} [userProtocol] - an optional protocol that can be directly passed into the function rather than supplied via argv; currently this is only for testing purposes. * @return {object} Processing results with properties `output` (the final processed protocol) and `protocol` (same as output, but without tables). */ function _run(opts, userProtocol) { if (opts.debug) { console.log(&quot;opts:&quot;, opts); } const filecache = {}; _.forEach(opts.fileData, function(s) { var pair = splitInlineFile(s); var data = pair[1]; filecache[pair[0]] = data; }); _.forEach(opts.fileJson, function(s) { var pair = splitInlineFile(s); var data = JSON.parse(pair[1]); //console.log(&quot;fileJson:&quot;, s, data); filecache[pair[0]] = data; }); // Add config/roboliq.js to URLs by default. const urls = _.uniq(_.compact( _.compact([ (opts.loadRoboliqConfig) ? __dirname+'/config/roboliq.js' : undefined ]).concat(opts.infiles) )); if (opts.debug) { console.log(&quot;urls:&quot;, urls); } // Load all the protocols in unprocessed form var urlToProtocol_l = _.map(urls, function(url) { return [url, loadUrlContent(url, filecache)]; }); // Append the optional user protocol to the list // (this lets unit tests pass in JSON protocols rather than loading them from files). if (userProtocol) urlToProtocol_l.push([undefined, userProtocol]); // Load varsets // console.log({opts}) _.forEach(opts.varset, varsetString =&gt; { // console.log({varsetString}) let url; let varset; if (_.isPlainObject(varsetString)) { // This is strange, apparently nomnom automatically converted the string to an object! varset = varsetString; } else if (_.startsWith(varsetString, &quot;{&quot;)) { varset = JSON.parse(varsetString); } else { url = varsetString; varset = loadUrlContent(url, filecache); } const varsetProtocol = { roboliq: version, objects: { SCOPE: varset } }; // console.log({varsetProtocol}) urlToProtocol_l.push([url, varsetProtocol]); }); // Reduce the list of URLs by merging or patching them together, starting // with the empty protocol. var protocol = _.reduce( urlToProtocol_l, (protocol, [url, raw]) =&gt; { if (_.isArray(raw)) { return jiff.patch(raw, protocol); } else { var b = loadProtocol(protocol, raw, url || &quot;&quot;, filecache); return mergeProtocols(protocol, b); } }, protocolEmpty ); /*if (opts.debug) { console.log(protocol); }*/ // Add command line options //console.log({opts}) protocol.COMPILER.roboliqOpts = opts; protocol.COMPILER.filecache = filecache; try { postProcessProtocol(protocol, filecache); //console.log(&quot;A&quot;) validateProtocol1(protocol); } catch(e) { if (opts.debug || opts.throw) { console.log(&quot;Error type = &quot;+(typeof e).toString()); } if (e.isRoboliqError) { const prefix = expect.getPrefix(e.context); protocol.errors[&quot;_&quot;] = _.map(e.errors, s =&gt; prefix+s); } else if (_.has(e, &quot;errors&quot;)) { protocol.errors[&quot;_&quot;] = e.errors; } else { protocol.errors[&quot;_&quot;] = _.compact([JSON.stringify(e), e.stack]); } if (opts.throw) { if (_.isPlainObject(e)) console.log(&quot;e:\\n&quot;+JSON.stringify(e)); expect.rethrow(e); } return {protocol: protocol, output: protocol}; } //console.log(&quot;B&quot;) var objectToPredicateConverters = protocol.objectToPredicateConverters; // If initial processing didn't result in any errors, // expand steps and get final objects. const objectsFinal = (_.isEmpty(protocol.errors)) ? expandProtocol(opts, protocol) : protocol.objects; if (opts.debug || opts.printProtocol) { console.log(); console.log(&quot;Protocol:&quot;); console.log(JSON.stringify(protocol, null, '\\t')); /*console.log(); console.log(&quot;Steps:&quot;) console.log(JSON.stringify(protocol.steps, null, '\\t')); console.log(); console.log(&quot;Effects:&quot;) console.log(JSON.stringify(effects, null, '\\t')); */ } if (opts.debug || opts.printDesigns) { const designs = misc.getObjectsOfType(protocol.objects, &quot;Data&quot;); _.forEach(designs, (data, name) =&gt; { console.log(); console.log(`Data &quot;${name}&quot;:`); // console.log(JSON.stringify(design, null, '\\t')) let table; if (data.hasOwnProperty(&quot;value&quot;)) { table = data.value; } else { let design = misc.handleDirectiveDeep(data, protocol); design = commandHelper.substituteDeep(design, protocol, {}, []); table = Design.flattenDesign(design); } Design.printRows(table); }); } // If there were errors, if (!_.isEmpty(protocol.errors)) { //return {protocol: protocol, output: _.pick(protocol, 'errors', 'warnings')}; console.log(&quot;WITH ERRORS&quot;) return {protocol: protocol, output: protocol}; } // Otherwise create tables else { const output = _.merge( {roboliq: version}, _.pick(protocol, &quot;description&quot;, &quot;config&quot;, &quot;parameters&quot;, &quot;objects&quot;, &quot;schemas&quot;, &quot;steps&quot;, &quot;effects&quot;, &quot;reports&quot;, &quot;simulatedOutput&quot;, &quot;warnings&quot;, &quot;errors&quot;, &quot;fillIns&quot;) ); // Handle protocol.COMPILER if (!_.isEmpty(protocol.COMPILER)) { output.COMPILER = _.pick(protocol.COMPILER, &quot;resumeStepId&quot;, &quot;suspendStepId&quot;); } // console.log(&quot;SIMULATED OUTPUT&quot;) // console.log(JSON.stringify(protocol.simulatedOutput)) // process.exit(-1); const tables = { labware: [], sourceWells: [], wellContentsFinal: [] }; // Construct labware table const labwares = misc.getObjectsOfType(objectsFinal, ['Plate', 'Tube']); _.forEach(labwares, function(labware, name) { tables.labware.push(_.merge({}, { labware: name, type: labware.type, model: labware.model, locationInitial: expect.objectsValue({}, name+'.location', protocol.objects), locationFinal: labware.location })); }); // Construct sourceWells table var tabulateWELLSSource = function(o, id) { //console.log(&quot;tabulateWELLSSource&quot;, o, id) if (o.isSource) { /* Example: - source: water well: plate1(A01) volume: 0ul volumeRemoved: 60ul */ var wellName = (id.indexOf(&quot;.contents.&quot;) &gt;= 0) ? id.replace('.contents.', '(')+')' : id.replace('.contents', '()'); var contents = expect.objectsValue({}, id, objectsFinal); var source = (contents.length == 2 &amp;&amp; _.isString(contents[1])) ? contents[1] : wellName; var volumeInitial = misc.findObjectsValue(id, protocol.objects, null, [&quot;0ul&quot;])[0]; var volumeFinal = contents[0]; tables.sourceWells.push({source: source, well: wellName, volumeInitial: volumeInitial, volumeFinal: volumeFinal, volumeRemoved: o.volumeRemoved || &quot;0&quot;}); } }; // For each well in object.__WELLS__, add to the appropriate table var tabulateWELLS = function(objects, prefix) { //console.log(&quot;tabulateWELLS&quot;, prefix) _.forEach(objects, function(x, field) { if (field === 'isSource') { tabulateWELLSSource(objects, prefix.join('.')); } else if (_.isPlainObject(x)) { tabulateWELLS(x, prefix.concat([field])); } }); }; tabulateWELLS(objectsFinal['__WELLS__'] || {}, []); // Construct wellContentsFinal table var tabulateWellContents = function(contents, labwareName, wellName) { //console.log(&quot;tabulateWellContents:&quot;, JSON.stringify(contents), labwareName, wellName); if (_.isArray(contents)) { var map = WellContents.flattenContents(contents); var wellName2 = (wellName) ? labwareName+&quot;(&quot;+wellName+&quot;)&quot; : labwareName; tables.wellContentsFinal.push(_.merge({well: wellName2}, map)); } else if (_.isPlainObject(contents)) { _.forEach(contents, function(contents2, name2) { var wellName2 = _.compact([wellName, name2]).join('.'); tabulateWellContents(contents2, labwareName, wellName2); }); } }; _.forEach(labwares, function(labware, name) { if (labware.contents) { tabulateWellContents(labware.contents, name); } }); // Get tables for all designs const designs = misc.getObjectsOfType(protocol.objects, &quot;Data&quot;); const designTables = _.mapValues(designs, design =&gt; { design = misc.handleDirectiveDeep(design, protocol); design = commandHelper.substituteDeep(design, protocol, {}, []); return Design.flattenDesign(design); }); if (!_.isEmpty(designTables)) tables.designs = designTables; output.tables = tables; return {protocol: protocol, output: output}; } } // Handle fileData and fileJson options, where file data is passed on the command line. function splitInlineFile(s) { var i = s.indexOf(':'); assert(i &gt; 0); var name = &quot;./&quot; + path.posix.join(s.substr(0, i)); var data = s.substr(i + 1); return [name, data]; } /** * This function recurively iterates through all objects, and for each * object whose type has an entry in protocol.objectToPredicateConverters, * it generates the logical predicates and appends them to stateList. * * Mutates stateList. * * @param {string} name - name of current object * @param {object} o - current object * @param {array} stateList - array of logical predicates */ function createStateItems(objectToPredicateConverters, o, name = &quot;&quot;, stateList = []) { //console.log(&quot;name: &quot;+name); if (o.hasOwnProperty(&quot;type&quot;)) { //console.log(&quot;type: &quot;+o.type); const type = o['type']; if (objectToPredicateConverters.hasOwnProperty(type)) { const predicates = objectToPredicateConverters[type](name, o); if (!_.isEmpty(predicates)) { stateList.push(...predicates); } } } var prefix = _.isEmpty(name) ? &quot;&quot; : name + &quot;.&quot;; _.forEach(o, function(value, name2) { //console.log(name2, value); if (_.isPlainObject(value)) { createStateItems(objectToPredicateConverters, value, prefix + name2, stateList); } }); return stateList; } /** * Expand the protocol's steps. * This means that commands are passed to command handlers to possibly * be expanded to lower-level sub-commands. * * Mutates protocol. * * @param {Protocol} The protocol. * @return {object} The final state of objects. */ function expandProtocol(opts, protocol) { var objects0 = _.cloneDeep(protocol.objects); _.merge(protocol, {effects: {}, cache: {}, warnings: {}, errors: {}}); // If we should resume expansion at a particular step: delete protocol.COMPILER.suspend; // console.log({COMPILER: protocol.COMPILER}) if (protocol.COMPILER.resumeStepId) { protocol.COMPILER.skipTo = protocol.COMPILER.resumeStepId; // HACKy... } expandStep(opts, protocol, [], protocol.steps, objects0); return objects0; } /** * Expand the given step by passing a command to its command handler * and recursively expanding sub-steps. * * Mutates protocol. However, since protocol.objects should still hold the * *initial* objects after processing, rather than mutating protocol.objects * during processing, a separate `objects` variable is mutated, which * starts out as a deep copy of protocol.objects. * * @param {Protocol} protocol - the protocol * @param {array} prefix - array of string representing the current step ID (initially []). * @param {object} step - the current step (initially protocol.steps). * @param {object} objects - a mutable copy of the protocol's objects. */ function expandStep(opts, protocol, prefix, step, objects, SCOPE = {}, DATA = []) { // If protocol.COMPILER.suspend is set, compiling should be suspended and continued later if (protocol.COMPILER.suspend) { return; } //console.log(&quot;expandStep: &quot;+prefix+JSON.stringify(step)) var commandHandlers = protocol.commandHandlers; var id = prefix.join('.'); // console.log({id, RESUME: protocol.COMPILER}) if (opts.progress) { console.log(_.compact([&quot;step &quot;+id, step.command, step.description]).join(&quot;: &quot;)); } const accesses = []; // TODO: we should create the context further up in the call chain and // pass that around instead of passing protocol, objects, etc to all these // functions. const data0 = commandHelper.createData(protocol, objects, SCOPE, DATA, prefix, protocol.COMPILER.filecache, step); // console.log(&quot;step &quot;+prefix) // console.log(_.get(data0, &quot;objects.DATA&quot;)) // console.log(_.get(data0, &quot;objects.SCOPE&quot;)) // console.log(&quot; data0: &quot;+JSON.stringify(data0, null, '\\t')) // Check for command and its handler const commandName = step.command; const handler = (commandName) ? commandHandlers[commandName] : undefined; if (commandName &amp;&amp; !handler) { protocol.warnings[id] = [&quot;unknown command: &quot;+step.command]; return; } const step0 = _.omit(step, &quot;data&quot;); { // const prefix2 = prefix.concat([groupIndex + 1]); // const DATA = DATA1; // const SCOPE = SCOPE1; // const data = commandHelper.createData(protocol, objects, SCOPE, DATA, prefix2, protocol.COMPILER.filecache, step0); // const SCOPE2 = data.objects.SCOPE; const params = misc.handleDirectiveDeep(step0, data0); // console.log({params}) // If we're skipping to a specific step // console.log({COMPILER: protocol.COMPILER}) if (protocol.COMPILER.skipTo) { // If the step has been reached: if (protocol.COMPILER.skipTo === id) { protocol.COMPILER.skipTo = undefined; assert(commandName === &quot;system.runtimeLoadVariables&quot;, &quot;Roboliq can only resume compiling at a `system.runtimeLoadVariables` command&quot;); } else { expandSubsteps(opts, protocol, prefix, step, objects, data0.objects.SCOPE, data0.objects.DATA); } } else if (commandName === &quot;system.runtimeLoadVariables&quot;) { protocol.COMPILER.suspend = true; protocol.COMPILER.suspendStepId = id; } else { if (commandName) { expandCommand(protocol, prefix, step, objects, data0.objects.SCOPE, params, commandName, handler, data0.objects.DATA, id); } expandSubsteps(opts, protocol, prefix, step, objects, data0.objects.SCOPE, data0.objects.DATA); } } } function expandSubsteps(opts, protocol, prefix, step, objects, SCOPE, DATA) { // Find all sub-steps (properties that start with a digit) const keys = commandHelper.getStepKeys(step); // Try to expand the substeps for (const key of keys) { expandStep(opts, protocol, prefix.concat(key), step[key], objects, SCOPE, DATA); } } function expandCommand(protocol, prefix, step, objects, SCOPE, params, commandName, handler, DATA, id) { // Take the initial predicates and append predicates for the current state // REFACTOR: this might be a time-consuming process, which could perhaps be // sped up by using Immutablejs and checking which objects have changed // rather than regenerating predicates for all objects. const predicates = protocol.predicates.concat(createStateItems(protocol.objectToPredicateConverters, objects)); const opts = protocol.COMPILER.roboliqOpts || {}; let result = {}; const objects2 = _.merge({}, objects, {SCOPE}); if (!_.isUndefined(DATA)) objects2.DATA = DATA; const data = { objects: objects2, predicates, planAlternativeChoosers: protocol.planAlternativeChoosers, planHandlers: protocol.planHandlers, schemas: protocol.schemas, accesses: [], files: protocol.COMPILER.filecache, protocol, path: prefix, simulatedOutput: protocol.simulatedOutput || {} }; const warnings = []; try { //if (!_.isEmpty(data.objects.SCOPE)) { console.log({SCOPE: data.objects.SCOPE})} // If a schema is given for the command, parse its parameters const schema = protocol.schemas[commandName]; // console.log(&quot;params: &quot;+JSON.stringify(params)) const parsed = (schema) ? commandHelper.parseParams(params, data, schema) : undefined; if (!_.isEmpty(parsed.unknown)) { warnings.push(...parsed.unknown.map(x =&gt; `unknown parameter ${x}`)); } // console.log(&quot;parsed: &quot;+JSON.stringify(parsed, null, '\\t')); // If the handler has an input specification, parse it if (_.isPlainObject(handler.inputSpec)) { const input = commandHelper.parseInputSpec(handler.inputSpec, parsed, data); parsed.input = input; } // Try to run the command handler //console.log(&quot;A&quot;) //console.log(handler) // function isCyclic (obj) { // var seenObjects = []; // // function detect (obj) { // if (obj &amp;&amp; typeof obj === 'object') { // if (seenObjects.indexOf(obj) !== -1) { // return true; // } // seenObjects.push(obj); // for (var key in obj) { // if (obj.hasOwnProperty(key) &amp;&amp; detect(obj[key])) { // // console.log(obj, 'cycle at ' + key); // console.log('cycle at ' + key); // return true; // } // } // } // return false; // } // // return detect(obj); // } // console.log(&quot;A&quot;) result = handler(params, parsed, data) || {}; // console.log(&quot;B&quot;) // console.log(Object.keys(result)) // isCyclic(result); // console.log(&quot;result:&quot;); console.log(result) // console.log(&quot;result: &quot;+JSON.stringify(result)) result = stripUndefined(result); // console.log(&quot;C&quot;) //console.log(&quot;B&quot;) //console.log(&quot;result: &quot;+JSON.stringify(result)) } catch (e) { // console.log(&quot;Some Error:&quot;); // console.log(JSON.stringify(e, null, &quot;\\t&quot;)) if (opts.debug || opts.throw) { console.log(&quot;Error type = &quot;+(typeof e).toString()); } if (e.isRoboliqError) { // console.log(&quot;RoboliqError:&quot;); // console.log(JSON.stringify(e, null, &quot;\\t&quot;)) const prefix = expect.getPrefix(e.context); result = {errors: _.map(e.errors, s =&gt; prefix+s)}; } else if (_.has(e, &quot;errors&quot;)) { result = {errors: e.errors}; } else { result = {errors: _.compact([JSON.stringify(e), e.stack])}; } console.log(`ERROR: `+result.errors.join(&quot;\\n&quot;)); if (opts.throw) { if (_.isPlainObject(e)) console.log(&quot;e:\\n&quot;+JSON.stringify(e)); expect.rethrow(e, {stepName: id}); } } // If debugging, store the result verbatim if (protocol.COMPILER.roboliqOpts.debug) protocol.cache[id] = result; // If there were errors: if (!_.isEmpty(result.errors)) { protocol.errors[id] = result.errors; // Abort expansion of protocol return false; } // If there were warnings if (!_.isEmpty(result.warnings)) { warnings.push(...result.warnings); } if (!_.isEmpty(warnings)) { const suppress = _.get(protocol, &quot;config.suppressWarnings&quot;, []); const warnings2 = warnings.filter(s =&gt; _.every(suppress, code =&gt; !s.startsWith(`[W#${code}]`))); // console.log({config: protocol.config, warnings2}) if (!_.isEmpty(warnings2)) protocol.warnings[id] = warnings2; } // If the command was expanded, merge the expansion into the protocol as substeps: if (!_.isEmpty(result.expansion)) { // If an array was returned rather than an object, put it in the proper form //console.log({expansion: result.expansion, stepified: commandHelper.stepify(result.expansion)}) result.expansion = commandHelper.stepify(result.expansion); result.expansion = commandHelper.substituteDeep(result.expansion, data, data.objects.SCOPE, data.objects.DATA); //console.log({expansion: result.expansion}) _.merge(step, result.expansion); } // If the command has effects if (!_.isEmpty(result.effects)) { //console.log(result.effects); // Add effects to protocol's record of effects protocol.effects[id] = result.effects; //console.log(&quot;mixPlate.contents.C01 #0: &quot;+_.get(objects, &quot;mixPlate.contents.C01&quot;)); // Update object states _.forEach(result.effects, (value, key) =&gt; _.set(objects, key, value)); //console.log(&quot;mixPlate.contents.C01 #1: &quot;+_.get(objects, &quot;mixPlate.contents.C01&quot;)); } // If the command has reports if (!_.isEmpty(result.reports)) { _.set(protocol, [&quot;reports&quot;, id], result.reports); } // If the command has simulated output if (!_.isEmpty(result.simulatedOutput)) { _.forEach(result.simulatedOutput, (value, key) =&gt; { _.set(protocol, [&quot;simulatedOutput&quot;, key], value); }); } } module.exports = { run, runWithOpts, } if (require.main === module) { run(); } × Search results Close "},"stanModel.js.html":{"id":"stanModel.js.html","title":"Source: stanModel.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: stanModel.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * Function to generate an MCMC model for use with [Stan](http://mc-stan.org/). * @module stanModel */ const _ = require('lodash'); const assert = require('assert'); const fs = require('fs'); const wellsParser = require('./parsers/wellsParser'); // PROBLEM WITH beta: // Will need to have a beta for each explicitly tested volume, // but also need to calculate the bias for other volumes // (e.g. we might add 3ul dye and 297ul water to a well, but 297ul isn't one of our test volumes). // We might need to have several lines for assigning to RV_VTIPASP: // // - RV_TIPASP[i1] = d * (1 + beta[pd]) + RV_TIPASP_raw * (sigma_v0 + d * sigma_v1[psub]) // - RV_TIPASP[i2] = d + RV_TIPASP_raw * (sigma_v0 + d * sigma_v1[psub]) // // The first line is for the nodal volumes we want beta estimate for. // The second line is for the volumes where we completely ignore beta. // A third line could be for interpolating volumes between two nodal volumes. // A fourth line could be for extrapolating beta to volumes beyond our nodal volumes. function Ref(name, i) { if (_.isPlainObject(name)) { const rv = name; return { name: rv.type, i: rv.i, idx: rv.idx }; } return { name, i, idx: (_.isNumber(i)) ? i + 1 : undefined }; } function RefRV(i) { return { name: &quot;rvs&quot;, i, idx: (_.isNumber(i)) ? i + 1 : undefined }; } function lookup(model, ref) { return model[ref.name][ref.i]; } // Standard Normal variate using Box-Muller transform. function randn_bm(mean, sigma) { var u = 1 - Math.random(); // Subtraction to flip [0, 1) to (0, 1]. var v = 1 - Math.random(); return mean + sigma * Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v ); } /** * Create the initial empty model. * You will add pipetting and measurement actions will be added to. * @param {number[]} subclassNodes - sorted volumes after which a subclass starts (e.g. for subclasses 3-15,15.01-500,500.01-1000, subclassNodes = [3,15,500,1000]) * @param {number[]} betaDs - volumes for which we want a beta parameter (dispense bias) * @param {number[]} gammaDs - volumes for which we want a gamma parameter (unintended dilution) * @return {object} an object with mostly empty properties representing the model's random variables and labware. */ function createEmptyModel(subclassNodes, betaDs, gammaDs) { assert(!_.isEmpty(subclassNodes)); assert(!_.isEmpty(betaDs)); return { subclassNodes, betaDs, gammaDs, models: {}, // labware models liquids: {}, labwares: {}, wells: {}, tips: {}, // liquidClass/pipettingParameters (p) + dispense volume (d) combinations pds: {}, // liquidClass/pipettingParameters (p) + subclass (sub) combinations psubs: {}, gammas: {}, // Random variables RV_AL: [], RV_A0: [], RV_AV: [], RV_VTIPASP: [], RV_V: [], RV_U: [], RV_C: [], RV_A: [], RV_G0: [], // empty/starting weights RV_G: [], // weight // Pipetting operations pipOps: [], absorbanceMeasurements: [], weightMeasurements: [], }; } function addRv(model, rv) { rv.i = model.rvs.length; rv.idx = model.rvs.length; // FIXME: change this to i + 1 model.rvs.push(rv); return RefRV(rv.i); } function addRv2(model, group, rv) { const list = model[group]; rv.i = list.length; rv.idx = list.length + 1; list.push(rv); return Ref(group, rv.i); } /** * Add a liquid to the model. * @param {object} model - the model * @param {string} k - liquid name * @param {object} spec - concentration specification * @param {string} [spec.type=&quot;fixed&quot;] - set to &quot;fixed&quot; for a concentration, &quot;normal&quot; for a normally distributed concentration. If set to &quot;normal&quot;, you will need to supply the &quot;loc&quot; and &quot;scale&quot; values as input data when running Stan. * @param {number} [spec.value=0] - if fixed, this is the fixed concentration - otherwise the parameters will be estimated. */ function addLiquid(model, k, spec) { const liquidData = getLiquidData(model, k); liquidData.spec = spec; } function getLabwareData(model, l) { // console.log(&quot;getLabwareData: &quot;+l); const m = &quot;FIXME&quot;; if (!model.labwares.hasOwnProperty(l)) { model.labwares[l] = { m }; } return model.labwares[l]; } function getLiquidData(model, k) { if (!model.liquids.hasOwnProperty(k)) { model.liquids[k] = {k, idx: model.liquids.length}; } return model.liquids[k]; } function getWellData(model, well) { if (!model.wells.hasOwnProperty(well)) { const {labware: l, wellId: wellPos} = wellsParser.parseOne(well); model.wells[well] = { l, pos: wellPos }; } return model.wells[well]; } function getTipData(model, t) { if (!model.tips.hasOwnProperty(t)) { model.tips[t] = { }; } return model.tips[t]; } function getRv_al(model, l) { const labwareData = getLabwareData(model, l); if (!labwareData.hasOwnProperty(&quot;ref_al&quot;)) { const ref = addRv2(model, &quot;RV_AL&quot;, {type: &quot;RV_AL&quot;, l}); labwareData.ref_al = ref; } return lookup(model, labwareData.ref_al); } function getRv_a0(model, well) { const wellData = getWellData(model, well); if (!wellData.hasOwnProperty(&quot;ref_a0&quot;)) { const rv = {type: &quot;RV_A0&quot;, well}; const ref = addRv2(model, &quot;RV_A0&quot;, rv); wellData.ref_a0 = ref; } return lookup(model, wellData.ref_a0); } function getRv_av(model, well) { const wellData = getWellData(model, well); if (!wellData.hasOwnProperty(&quot;ref_av&quot;)) { const rv = {type: &quot;RV_AV&quot;, well}; const ref = addRv2(model, &quot;RV_AV&quot;, rv); wellData.ref_av = ref; } return lookup(model, wellData.ref_av); } function getRv_g0(model, l) { const labwareData = getLabwareData(model, l); if (!labwareData.hasOwnProperty(&quot;ref_g0&quot;)) { const rv = {type: &quot;RV_G0&quot;, l}; const ref = addRv2(model, &quot;RV_G0&quot;, rv); labwareData.ref_g0 = ref; } return lookup(model, labwareData.ref_g0); } function absorbance_A0(model, wells) { _.forEach(wells, well =&gt; { const {labware: l, wellId: wellPos} = wellsParser.parseOne(well); const rv_al = getRv_al(model, l); const rv_a0 = getRv_a0(model, well); }); } function absorbance_AV(model, wells) { _.forEach(wells, well =&gt; { const {labware: l, wellId: wellPos} = wellsParser.parseOne(well); const rv_al = getRv_al(model, l); const rv_a0 = getRv_a0(model, well); const rv_av = getRv_av(model, well); }); } /** * Add an absorbance measurement to the model. * @param {object} model - the model * @param {string[]} wells - the names of the measured wells */ function measureAbsorbance(model, wells) { _.forEach(wells, well =&gt; { const {labware: l, wellId: wellPos} = wellsParser.parseOne(well); const wellData = getWellData(model, well); const rv_al = getRv_al(model, l); const rv_a0 = getRv_a0(model, well); // console.log(&quot;wellData: &quot;+JSON.stringify(wellData)) // If the well already has an absorbance RV if (wellData.ref_a) { model.absorbanceMeasurements.push({ref_a: wellData.ref_a, well}); } // If there's some volume in the well else if (wellData.ref_vWell) { const rv_av = getRv_av(model, well); const ref_av = Ref(rv_av); // console.log({wellData}) // If there's some concentration in the well if (wellData.ref_cWell) { const rv_a = {type: &quot;a&quot;, well, l, wellPos, ref_av, ref_vWell: wellData.ref_vWell, ref_cWell: wellData.ref_cWell}; const ref_a = addRv2(model, &quot;RV_A&quot;, rv_a); model.absorbanceMeasurements.push({ref_a}); wellData.ref_a = ref_a; } // Otherwise the liquid is clear: else { const rv_a = {type: &quot;a&quot;, well, l, wellPos, ref_av}; const ref_a = addRv2(model, &quot;RV_A&quot;, rv_a); model.absorbanceMeasurements.push({ref_a}); wellData.ref_a = ref_a; } } // Otherwise, just measure A0 else { const ref_a0 = Ref(rv_a0); const rv_a = {type: &quot;a&quot;, well, l, wellPos, ref_a0}; const ref_a = addRv2(model, &quot;RV_A&quot;, rv_a); wellData.ref_a = ref_a; model.absorbanceMeasurements.push({ref_a}); } }); } /** * Add a weight measurement to the model. * @param {object} model - the model * @param {string} l - the labware name */ function measureWeight(model, l) { // console.log(&quot;measureWeight: &quot;+l) const labwareData = getLabwareData(model, l); // console.log({labwareData}) let ref_g; // If we already have an RV for the current weight, use it. if (labwareData.ref_g) { ref_g = labwareData.ref_g; } // Otherwise, calculate a new RV else { // Ensure we have a variable for the empty/starting weight of the plate const rv_g0 = getRv_g0(model, l); const ref_g0 = Ref(rv_g0); // Find wells on the plate const wells = _.filter(model.wells, wellData =&gt; wellData.l == l &amp;&amp; wellData.ref_vWell); // Get their volumes const ref_vs = wells.map(x =&gt; x.ref_vWell); const rv_g = {type: &quot;RV_G&quot;, l, ref_g0, ref_vs}; // console.log({rv_g}) ref_g = addRv2(model, &quot;RV_G&quot;, rv_g); labwareData.ref_g = ref_g; } // console.log({ref_g}) model.weightMeasurements.push({ref_g}); } /** * Assign a liquid to a well in the model. * @param {object} model - the model * @param {string} well - the well name * @param {string} k - the liquid name */ function assignLiquid(model, well, k) { const liquidData = getLiquidData(model, k); const wellData = getWellData(model, well); wellData.k = k; wellData.idx_k = liquidData.idx; } /** * Add an aspiration operation to the model. * @param {object} model - the model * @param {object} args * @param {string} args.p - the name of the pipetting parameters * @param {number|string} args.t - the tip identifier * @param {number} args.d - volume in microliters * @param {string} args.well - the well name */ function aspirate(model, {p, t, d, well}) { // create: RV for volume aspirated into tip // create: RV for concentration in tip // create: RV for new volume in src // input: previous volume of src // input: variable for k's concentration - we'll need a random variable for the original sources and a calculated variable for what we pipette together const wellData = getWellData(model, well); const labwareData = getLabwareData(model, wellData.l); const tipData = getTipData(model, t); const ref_vWell0 = wellData.ref_vWell; // volume of well before aspirating // console.log({p, t, d, well, wellData, tipData}) // Need a variable for the well/liquid concentration. // If one doesn't already exist, we'll need to create one. // If well's liquid is known: // if it's concentration is fixed, // add a RV_C item, but not an RV_C_raw. // if the concentration is user-defined or estimated, // add both RV_C_raw and RC_C items. // Otherwise add an RV_C item with fixed value 0 (and no RV_C_raw). if (!wellData.hasOwnProperty(&quot;ref_cWell&quot;)) { let ref_c; if (wellData.hasOwnProperty(&quot;k&quot;)) { const liquidData = getLiquidData(model, wellData.k); if (_.get(liquidData.spec, &quot;type&quot;) === &quot;fixed&quot;) { if (liquidData.spec.value &gt; 0) { const rv_c = {type: &quot;c&quot;, k: liquidData.k, value: liquidData.spec.value, of: liquidData.k}; ref_c = addRv2(model, &quot;RV_C&quot;, rv_c); } } else { // const rv_c_raw = {type: &quot;c&quot;, k, value: liquidData.spec.value}; // const ref_c_raw = addRv2(model, &quot;RV_C_raw&quot;, rv_c_raw); const rv_c = {type: &quot;c&quot;, k: liquidData.k, alpha_k: `alpha_k_${liquidData.k}`, of: liquidData.k}; ref_c = addRv2(model, &quot;RV_C&quot;, rv_c); } } else { const rv_c = {type: &quot;c&quot;, value: 0, well, of: well}; ref_c = addRv2(model, &quot;RV_C&quot;, rv_c); } wellData.ref_cWell = ref_c; } const ref_cWell0 = wellData.ref_cWell; // concentration of well before aspirating // Add new psub (liquid class + subclass) data const sub = (model.subclassNodes[0] == d) ? 1 : _.findIndex(model.subclassNodes, v =&gt; d &lt;= v); assert(sub &gt; 0, `didn't find subclass: ${JSON.stringify({sub, d, x: model.subclassNodes})}`); const psub = p+sub; if (!model.psubs.hasOwnProperty(psub)) { const idx = _.size(model.psubs) + 1; model.psubs[psub] = {idx, psub, p, sub}; } const idx_psub = model.psubs[psub].idx; // Add new pd (liquid class + dispense volume) data, if d is in betaDs let idx_pd; if (_.includes(model.betaDs, d)) { const pd = p+d; if (!model.pds.hasOwnProperty(pd)) { const idx = _.size(model.pds) + 1; model.pds[pd] = {idx, idx_psub, psub, pd, p, sub, d}; } idx_pd = model.pds[pd].idx; // console.log({p, d, idx_pd}) } else { // console.log({d, betaDs: model.betaDs.join(&quot;,&quot;)}) } const idx_pip = model.pipOps.length; const rv_vTipAsp = {type: &quot;vTipAsp&quot;, idx_pip, idx_psub, idx_pd}; // TODO: this is currently just calculated, so it'd be better not to have a // RV_raw entry for this, because that adds a superfluous parameter to the // model. We should differentiate between RV's that are calculated and RV's // that require their own parameter. const ref_vTipAsp = addRv2(model, &quot;RV_VTIPASP&quot;, rv_vTipAsp); tipData.ref_vTipAsp = ref_vTipAsp; tipData.ref_cTipAsp = ref_cWell0; // // If we have information about the source concentration, // // then track the concentration in the tip too. // if (!_.isUndefined(ref_cWell0)) { // const idx_cTipAsp = model.rvs.length; // const rv_cTipAsp = {idx: idx_cTipAsp, type: &quot;cTipAsp&quot;, ref_cWell0, idx_d}; // model.rvs.push(rv_cTipAsp); // tipData.ref_cTipAsp = RefRV(idx_cTipAsp); // } // If we already have information about well volume, // then update it by removing the aliquot. if (ref_vWell0) { const rv_vWellAsp = {type: &quot;vWellAsp&quot;, well, ref_vWell0, ref_vTipAsp}; const ref_vWellAsp = addRv2(model, &quot;RV_V&quot;, rv_vWellAsp); wellData.ref_vWell = ref_vWellAsp; } wellData.ref_a = undefined; labwareData.ref_g = undefined; const asp = { d // p, t, d, well, k, // idx_volTot0, idx_conc0, // idx_v, idx_c, idx_volTot, }; model.pipOps.push(asp); } /** * Add a dispense operation to the model. * @param {object} model - the model * @param {object} args * @param {string} args.p - the name of the pipetting parameters * @param {number|string} args.t - the tip identifier * @param {number} args.d - volume in microliters * @param {string} args.well - the well name */ function dispense(model, {p, t, d, well}) { if (d === 0) return; // input: RV for volume aspirated into tip // input: RV for concentration in tip // input: previous volume of dst // input: previous conc of dst // create: RV for new volume of dst // create: RV for new conc of dst const wellData = getWellData(model, well); const labwareData = getLabwareData(model, wellData.l); const tipData = getTipData(model, t); const ref_vWell0 = wellData.ref_vWell; // volume of well before dispensing const ref_cWell0 = wellData.ref_cWell; // concentration of well before dispensing const ref_vTipAsp = tipData.ref_vTipAsp; // volume in tip const ref_cTipAsp = tipData.ref_cTipAsp; // concentration in tip // Unintended dilution let ref_uWellDis; if (_.includes(model.gammaDs, d)) { const pd = p + d; if (!model.gammas.hasOwnProperty(pd)) { const idx = _.size(model.gammas) + 1; model.gammas[pd] = {idx, pd, p, d}; } const idx_gamma = model.gammas[pd].idx; const rv_uWellDis = {type: &quot;RV_U&quot;, well, idx_gamma}; ref_uWellDis = addRv2(model, &quot;RV_U&quot;, rv_uWellDis); } // Add aliquot to well const rv_vWellDis = {type: &quot;vWellDis&quot;, well, ref_vWell0, ref_vTipAsp, ref_uWellDis}; const ref_vWellDis = addRv2(model, &quot;RV_V&quot;, rv_vWellDis); tipData.ref_vTipAsp = undefined; wellData.ref_vWell = ref_vWellDis; // If we have information about the tip concentration, // then update the concentration in the destination well too. if (ref_cTipAsp || ref_cWell0) { const rv_cWellDis = {type: &quot;cWellDis&quot;, ref_vWell0, ref_cWell0, ref_vWell1: ref_vWellDis, ref_vTipAsp, ref_cTipAsp, ref_uWellDis, well, of: well}; const ref_cWellDis = addRv2(model, &quot;RV_C&quot;, rv_cWellDis); wellData.ref_cWell = ref_cWellDis; tipData.ref_cTipAsp = undefined; } wellData.ref_a = undefined; labwareData.ref_g = undefined; const asp = { d // p, t, d, well, k, // idx_volTot0, idx_conc0, // idx_v, idx_c, idx_volTot, }; model.pipOps.push(asp); } /** * Print the Stan model to stdout, and save a `basename`.R file that holds indexes to associate the random variables back to labware. * @param {string} model - the model * @param {string} [basename=&quot;stanModel&quot;] - the basename for the R output */ function printModel(model, basename) { const output = { data: [], transformedData: { definitions: [], statements: [] }, parameters: [], transformedParameters: { definitions: [], statements: [] }, model: [], R: [] }; handle_transformed_data(model, output); handle_transformed_parameters(model, output); handle_model_psubs(model, output); handle_model_pds(model, output); handle_model_weightMeasurements(model, output); console.log(); console.log(&quot;data {&quot;); output.data.forEach(s =&gt; console.log(s)); console.log(&quot; real&lt;lower=0&gt; sigma_a_scale;&quot;); if (model.RV_AL.length &gt; 0) { //const NL = model.RV_AL.length; const NM = _.size(model.models) || 1; console.log(makeVectorOrRealVariable(&quot;alpha_l_loc&quot;, NM, &quot;&lt;lower=0&gt;&quot;)); console.log(makeVectorOrRealVariable(&quot;alpha_l_scale&quot;, NM, &quot;&lt;lower=0&gt;&quot;)); } if (model.RV_AV.length &gt; 0) { const NM = _.size(model.models) || 1; console.log(makeVectorOrRealVariable(&quot;alpha_v_loc&quot;, NM, &quot;&quot;)); console.log(makeVectorOrRealVariable(&quot;alpha_v_scale&quot;, NM, &quot;&lt;lower=0&gt;&quot;)); console.log(makeVectorOrRealVariable(&quot;sigma_alpha_v_scale&quot;, NM, &quot;&lt;lower=0&gt;&quot;)); } _.forEach(model.liquids, liquidData =&gt; { if (_.get(liquidData.spec, &quot;type&quot;) === &quot;normal&quot;) { console.log(` real&lt;lower=0&gt; alpha_k_${liquidData.k}_loc; // concentration of liquid ${liquidData.k}`); console.log(` real&lt;lower=0&gt; alpha_k_${liquidData.k}_scale; // concentration of liquid ${liquidData.k}`); } }); if (model.absorbanceMeasurements.length &gt; 0) { console.log(); console.log(` vector&lt;lower=0&gt;[${model.absorbanceMeasurements.length}] A; // Absorbance measurements`); } console.log(&quot;}&quot;); console.log(); console.log(&quot;transformed data {&quot;); output.transformedData.definitions.forEach(s =&gt; console.log(s)); console.log(); output.transformedData.statements.forEach(s =&gt; console.log(s)); console.log(&quot;}&quot;); console.log(); console.log(&quot;parameters {&quot;); output.parameters.forEach(s =&gt; console.log(s)); if (model.RV_AL.length &gt; 0) { console.log(&quot; vector[NM] alpha_l_raw;&quot;); const NM = 1; const times = (NM == 1) ? &quot;*&quot; : &quot;.*&quot;; output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[NM] alpha_l = alpha_l_loc + alpha_l_raw ${times} alpha_l_scale;`); } if (model.RV_AL.length &gt; 1) { console.log(&quot; vector&lt;lower=0,upper=1&gt;[NM] sigma_alpha_l;&quot;); } console.log(&quot; vector&lt;lower=0,upper=1&gt;[NM] sigma_alpha_i;&quot;); if (model.RV_AV.length &gt; 0) { console.log(&quot; vector[NM] alpha_v_raw;&quot;); console.log(&quot; vector&lt;lower=0&gt;[NM] sigma_alpha_v_raw;&quot;); const times = (model.RV_AL.length == 1 || (_.size(model.models) || 1) == 1) ? &quot;*&quot; : &quot;.*&quot;; // console.log({times, NL: model.RV_AL.length, NM: model.models.length}) output.transformedParameters.definitions.push(` vector[NM] alpha_v = alpha_v_loc + alpha_v_raw ${times} alpha_v_scale;`); output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[NM] sigma_alpha_v = sigma_alpha_v_raw ${times} sigma_alpha_v_scale;`); } console.log(); if (model.RV_AL.length &gt; 0) console.log(` vector[${model.RV_AL.length}] RV_AL_raw;`); if (model.RV_A0.length &gt; 0) console.log(` vector[${model.RV_A0.length}] RV_A0_raw;`); if (model.RV_AV.length &gt; 0) console.log(` vector[${model.RV_AV.length}] RV_AV_raw;`); if (model.RV_VTIPASP.length &gt; 0) console.log(` vector[${model.RV_VTIPASP.length}] RV_VTIPASP_raw;`); // if (model.RV_C_raw.length &gt; 0) console.log(` vector[${model.RV_C_raw.length}] RV_C_raw;`) // console.log(&quot; vector[NRV] RV_raw;&quot;); _.forEach(model.liquids, liquidData =&gt; { if (_.get(liquidData.spec, &quot;type&quot;) === &quot;normal&quot;) { // console.log(` real&lt;lower=${liquidData.spec.lower || 0}, upper=${liquidData.spec.upper}&gt; alpha_k_${liquidData.k}; // concentration of liquid ${liquidData.k}`); console.log(` real alpha_k_${liquidData.k}_raw; // unscaled concentration variance of liquid ${liquidData.k}`); output.transformedParameters.definitions.push(` real alpha_k_${liquidData.k} = alpha_k_${liquidData.k}_loc + alpha_k_${liquidData.k}_raw * alpha_k_${liquidData.k}_scale;`); } }); if (model.absorbanceMeasurements.length &gt; 0) { console.log(&quot; real&lt;lower=0&gt; sigma_a_raw;&quot;); } console.log(&quot;}&quot;); console.log(); console.log(&quot;transformed parameters {&quot;); output.transformedParameters.definitions.forEach(s =&gt; console.log(s)); console.log(); output.transformedParameters.statements.forEach(s =&gt; console.log(s)); console.log(&quot;}&quot;); console.log(); console.log(&quot;model {&quot;); output.model.forEach(s =&gt; console.log(s)); if (model.RV_AL.length &gt; 0) console.log(&quot; RV_AL_raw ~ normal(0, 1);&quot;); if (model.RV_A0.length &gt; 0) console.log(&quot; RV_A0_raw ~ normal(0, 1);&quot;); if (model.RV_AV.length &gt; 0) console.log(&quot; RV_AV_raw ~ normal(0, 1);&quot;); if (model.RV_VTIPASP.length &gt; 0) console.log(&quot; RV_VTIPASP_raw ~ normal(0, 1);&quot;); // if (model.RV_C_raw.length &gt; 0) console.log(&quot; RV_C_raw ~ normal(0, 1);&quot;); // console.log(&quot; RV_raw ~ normal(0, 1);&quot;); if (model.absorbanceMeasurements.length &gt; 0) { console.log(&quot; sigma_a_raw ~ exponential(1);&quot;); if (model.RV_AV.length &gt; 0) { console.log(&quot; alpha_v_raw ~ normal(0, 1);&quot;); console.log(&quot; sigma_alpha_v_raw ~ exponential(1);&quot;); } console.log(); const idxsRv = model.absorbanceMeasurements.map(x =&gt; x.ref_a.idx); // console.log(` A ~ normal(RV_A[{${idxsRv}}], RV_A[{${idxsRv}}] * sigma_a);`); console.log(` A ~ normal(RV_A[A_i_A], RV_A[A_i_A] * sigma_a);`); } console.log(&quot;}&quot;); fs.writeFileSync((basename || &quot;stanModel&quot;)+&quot;.R&quot;, output.R.join(&quot;\\n&quot;)+&quot;\\n&quot;); } // There's appears to be a bug in RStan such that 1-element vectors // are not passed to stan. So we need to turn 1-element vectors into reals. function makeVectorOrRealVariable(name, n, modifier, value) { const type = (_.isString(n) || n &gt; 1) ? `vector${modifier}[${n}]` : `real${modifier}`; return ` ${type} ${name}${_.isUndefined(value) ? &quot;&quot; : &quot; = &quot;+value};`; } /*function makeVectorVariable(name, n, modifier, value) { const type = `vector${modifier}[${n}]`; return ` ${type} ${name}${_.isUndefined(value) ? &quot;&quot; : &quot; = &quot;+value};`; }*/ function handle_transformed_data(model, output) { output.transformedData.definitions.push(` int NM = 1; // number of labware models`); output.transformedData.definitions.push(` int NL = ${_.size(model.labwares)}; // number of labwares`); output.transformedData.definitions.push(` int NI = ${_.size(model.wells)}; // number of wells`); output.transformedData.definitions.push(` int NT = ${_.size(model.tips)}; // number of tips`); // output.transformedData.definitions.push(` int NRV = ${_.size(model.rvs)}; // number of latent random variables`); output.transformedData.definitions.push(` int NJ = ${model.pipOps.length}; // number of pipetting operations`); _.forEach(model.liquids, liquidData =&gt; { if (_.get(liquidData.spec, &quot;type&quot;) === &quot;fixed&quot;) { output.transformedData.definitions.push(` real alpha_k_${liquidData.k} = ${liquidData.spec.value}; // concentration of liquid ${liquidData.k}`); } }); if (!_.isEmpty(model.pipOps)) { // console.log(` real d[NJ] = {${model.pipOps.map(x =&gt; x.d.toFixed(1))}};`); output.transformedData.definitions.push(` vector&lt;lower=0&gt;[NJ] d; // desired volumes`); output.transformedData.statements.push(` {`); output.transformedData.statements.push(` real d0[NJ] = {${model.pipOps.map(x =&gt; x.d.toFixed(1))}};`); output.transformedData.statements.push(` for (i in 1:NJ) d[i] = d0[i];`); output.transformedData.statements.push(` }`); } } function addCentralizedParameter_sigma(name, n, nScales, output) { assert(n &gt; 0); assert(nScales == 1 || nScales == n); // Scale if (nScales == 1) { output.data.push(` real&lt;lower=0&gt; ${name}_scale;`); } else if (nScales &gt; 1) { output.data.push(` vector&lt;lower=0&gt;[${nScales}] ${name}_scale;`); } if (n == 1) { output.parameters.push(` real&lt;lower=0&gt; ${name}_raw;`); } else if (n &gt; 1) { output.parameters.push(` vector&lt;lower=0&gt;[${n}] ${name}_raw;`); } if (n == 1) { output.transformedParameters.definitions.push(` real&lt;lower=0&gt; ${name} = ${name}_raw * ${name}_scale;`); } else if (n &gt; 1) { if (nScales == 1) { output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${n}] ${name} = ${name}_raw * ${name}_scale;`); } else { output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${n}] ${name} = ${name}_raw .* ${name}_scale;`); } } output.model.push(` ${name}_raw ~ exponential(1);`); } /** * Add variables for a centralized mean * @param {string} name - name of variable * @param {boolean} withLoc - whether to include a location data variable * @param {integer} n - array size, or 1 for a scalar * @param {integer} nScales - number of scale parameters; 1 = same scale for each item in array; n = one scale parameter for each item. * @param {string} [nName] - optional name for array size (to be used in place of n in some places) * @param {string} limits - a limits modifier (&quot;&quot; if no limits) */ function addCentralizedParameter_mean(name, withLoc, n, nScales, nName, limits, output) { assert(n &gt; 0); assert(nScales == 1 || nScales == n); // Location if (withLoc) { output.data.push(makeVectorOrRealVariable(`${name}_loc`, nScales, limits)); } // Scale output.data.push(makeVectorOrRealVariable(`${name}_scale`, nScales, &quot;&lt;lower=0&gt;&quot;)); const n2 = (_.isString(nName) &amp;&amp; !_.isEmpty(nName)) ? nName : n; // Raw output.parameters.push(makeVectorOrRealVariable(`${name}_raw`, n2, &quot;&quot;)); const times = (n == 1 || nScales == 1) ? &quot;*&quot; : &quot;.*&quot;; const value = `${name}_loc + ${name}_raw ${times} ${name}_scale`; output.transformedParameters.definitions.push(makeVectorOrRealVariable(name, n2, limits, value)); output.model.push(` ${name}_raw ~ normal(0, 1);`); } function handle_model_psubs(model, output) { const n = _.size(model.psubs); if (n == 0) return; addCentralizedParameter_sigma(&quot;sigma_v0&quot;, 1, 1, output); addCentralizedParameter_sigma(&quot;sigma_v1&quot;, n, 1, output); output.R.push(&quot;dfModel_psubs = tibble(&quot;); output.R.push(` idx = c(${_.map(model.psubs, &quot;idx&quot;).join(&quot;, &quot;)}),`); output.R.push(` p = c(\\&quot;${_.map(model.psubs, &quot;p&quot;).join('&quot;, &quot;')}\\&quot;),`); output.R.push(` sub = c(${_.map(model.psubs, &quot;sub&quot;).join(&quot;, &quot;)})`); output.R.push(&quot;)&quot;); } function handle_model_pds(model, output) { const n = _.size(model.pds); if (n == 0) return; output.transformedData.definitions.push(` int NBETA = ${n}; // number of liquidClass+majorD combinations for beta`); // The second argument shouldn't be 'true', because it doesn't make // sense to have a single location variable for all betas. // Either none of them should have location, or all of them. // The problem with all of them having betas is that it's not so simple // for the user to know which order the location variables should be specified // in. addCentralizedParameter_mean(&quot;beta&quot;, true, n, 1, &quot;NBETA&quot;, &quot;&quot;, output); output.R.push(&quot;dfModel_pds = tibble(&quot;); output.R.push(` idx = c(${_.map(model.pds, &quot;idx&quot;).join(&quot;, &quot;)}),`); output.R.push(` idx_psub = c(${_.map(model.pds, &quot;idx_psub&quot;).join(&quot;, &quot;)}),`); output.R.push(` p = c(\\&quot;${_.map(model.pds, &quot;p&quot;).join('&quot;, &quot;')}\\&quot;),`); output.R.push(` sub = c(${_.map(model.pds, &quot;sub&quot;).join(&quot;, &quot;)}),`); output.R.push(` d = c(${_.map(model.pds, &quot;d&quot;).join(&quot;, &quot;)})`); output.R.push(&quot;)&quot;); } function handle_model_weightMeasurements(model, output) { const n = model.weightMeasurements.length; if (n == 0) return; output.data.push(` vector&lt;lower=0&gt;[${n}] G; // weight measurements`); addCentralizedParameter_sigma(&quot;sigma_g&quot;, 1, 1, output); output.data.push(` real&lt;lower=0&gt; rho; // density of liquid`); output.parameters.push(` vector&lt;lower=0&gt;[${model.RV_G0.length}] RV_G0; // empty/starting weights`); output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${n}] RV_G; // empty/starting weights`); _.forEach(model.RV_G, rv_g =&gt; { const idx_g0 = rv_g.ref_g0.idx; const idxs_v = rv_g.ref_vs.map(x =&gt; x.idx); let s = ` RV_G[${rv_g.idx}] = RV_G0[${idx_g0}]`; if (!_.isEmpty(rv_g.ref_vs)) s = s + ` + rho * sum(RV_V[{${idxs_v}}])`; s += `; // weight of ${rv_g.l}`; output.transformedParameters.statements.push(s); }); const idxs_g = model.weightMeasurements.map(x =&gt; x.ref_g.idx); output.model.push(` G ~ normal(RV_G[{${idxs_g}}], sigma_g);`); } function handle_transformed_parameters(model, output) { /* if (!_.isEmpty(model.betas)) { output.transformedParameters.definitions.push(&quot;&quot;); output.transformedParameters.definitions.push(&quot; vector[NBETA] beta0 = beta0_raw * beta_scale;&quot;); output.transformedParameters.definitions.push(&quot; vector[NBETA] beta1 = beta1_raw * beta_scale;&quot;); output.transformedParameters.definitions.push(&quot; vector&lt;lower=0&gt;[NBETA] sigma_v = sigma_v_raw * sigma_v_scale;&quot;); const rvs_gamma = _.values(model.betas).filter(rv =&gt; rv.withGamma); if (!_.isEmpty(rvs_gamma)) { output.transformedData.definitions.push(` int&lt;lower=0&gt; NGAMMA = ${rvs_gamma.length};`); output.transformedData.definitions.push(` int&lt;lower=1&gt; gamma_i_raw[NGAMMA] = ${rvs_gamma.map(rv =&gt; rv.idx)};`); output.transformedParameters.definitions.push(&quot; vector&lt;lower=0&gt;[NBETA] gamma = 0;&quot;); // need the same number of gamma variables as betas, but we probably have fewer gamma_raw parameters, since it's difficult to identify gamma in many experiments with small volumes. output.transformedParameters.definitions.push(&quot; real sigma_gamma = sigma_gamma_raw * sigma_gamma_scale;&quot;); output.transformedParameters.statements.push(&quot;&quot;); output.transformedParameters.statements.push(&quot; for (i in 1:NGAMMA) gamma[gamma_i_raw[i]] = max({0, gamma_raw[i] * sigma_gamma});&quot;); } } */ output.transformedParameters.definitions.push(&quot; real&lt;lower=0&gt; sigma_a = sigma_a_raw * sigma_a_scale;&quot;); // output.transformedParameters.definitions.push(` vector[NRV] RV;`); handle_transformed_parameters_RV_al(model, output); handle_transformed_parameters_RV_a0(model, output); handle_transformed_parameters_RV_av(model, output); handle_transformed_parameters_RV_vTipAsp(model, output); handle_transformed_parameters_RV_U(model, output); handle_transformed_parameters_RV_V(model, output); handle_transformed_parameters_RV_C(model, output); handle_transformed_parameters_RV_A(model, output); } function handle_transformed_parameters_RV_al(model, output) { const rvs = model.RV_AL; if (rvs.length == 0) return; const idxs_m = Array(rvs.length); for (let i = 0; i &lt; rvs.length; i++) { const rv = rvs[i]; idxs_m[i] = 0 + 1; } output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_AL; // average absorbance of labware`); output.transformedParameters.statements.push(&quot;&quot;); output.transformedParameters.statements.push(&quot; // AL[l] ~ normal(alpha_l[m], sigmal_alpha_l[m])&quot;) if (model.RV_AL.length &gt; 1) { output.transformedParameters.statements.push(` RV_AL = alpha_l[{${idxs_m}}] + RV_AL_raw .* sigma_alpha_l[{${idxs_m}}];`); } else { output.transformedParameters.statements.push(` RV_AL = alpha_l[{${idxs_m}}];`); } } function handle_transformed_parameters_RV_a0(model, output) { const rvs = model.RV_A0; const idxs_al = Array(rvs.length); const idxs_m = Array(rvs.length); for (let i = 0; i &lt; rvs.length; i++) { const rv = rvs[i]; const wellData = model.wells[rv.well]; const labwareData = model.labwares[wellData.l]; idxs_al[i] = labwareData.ref_al.idx; idxs_m[i] = 0 + 1; } output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A0_i_AL[${idxs_al.length}] = {${idxs_al}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A0_i_m[${idxs_m.length}] = {${idxs_m}};`) output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_A0; // absorbance of empty wells`); output.transformedParameters.statements.push(&quot;&quot;); output.transformedParameters.statements.push(&quot; // A0[i] ~ normal(AL[m[i]], sigma_alpha_i[m[i]])&quot;); output.transformedParameters.statements.push(` RV_A0 = RV_AL[RV_A0_i_AL] + RV_A0_raw .* sigma_alpha_i[RV_A0_i_m];`); } function handle_transformed_parameters_RV_av(model, output) { const rvs = model.RV_AV; if (rvs.length == 0) return; const idxs_a0 = Array(rvs.length); // const idxs_l = Array(rvs.length); const idxs_m = Array(rvs.length); for (let i = 0; i &lt; rvs.length; i++) { const rv = rvs[i]; const wellData = model.wells[rv.well]; idxs_a0[i] = wellData.ref_a0.idx; // const labwareData = model.labwares[wellData.l]; // // console.log({rv, wellData, labwareData}) // idxs_l[i] = labwareData.idx_al; idxs_m[i] = 0 + 1; } output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_AV_i_A0[${idxs_a0.length}] = {${idxs_a0}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_AV_i_m[${idxs_m.length}] = {${idxs_m}};`) // There's a bug in Rstan for data vectors of length 1, so this check is necessary... // const NM = model.models.length || 1; // CONTINUE // if (NM == 1) { // output.transformedParameters.definitions.push(` vector[NM] alpha_v = alpha_v_loc + alpha_v_raw * alpha_v_scale;`); // output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[NM] sigma_alpha_v = sigma_alpha_v_raw * sigma_alpha_v_scale;`); // } // else if (NM &gt; 1) { // output.transformedParameters.definitions.push(` vector[NM] alpha_v = alpha_v_loc + alpha_v_raw .* alpha_v_scale;`); // output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[NM] sigma_alpha_v = sigma_alpha_v_raw .* sigma_alpha_v_scale;`); // } output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_AV; // absorbance of water-filled wells`); output.transformedParameters.statements.push(&quot;&quot;); output.transformedParameters.statements.push(&quot; // AV[i] ~ normal(A0[i] + alpha_v[m[i]], sigma_alpha_v[m[i]])&quot;); output.transformedParameters.statements.push(` RV_AV = RV_A0[RV_AV_i_A0] + alpha_v[RV_AV_i_m] + RV_AV_raw .* sigma_alpha_v[RV_AV_i_m];`); } function handle_transformed_parameters_RV_vTipAsp(model, output) { const rvs = model.RV_VTIPASP; if (rvs.length == 0) return; const idxs_pip = rvs.map(rv =&gt; rv.idx_pip + 1); const idxs_psubsId = rvs.map(rv =&gt; rv.idx_psub); const rvs_withBeta = rvs.filter(rv =&gt; _.isNumber(rv.idx_pd)); const idxs_withBeta = rvs_withBeta.map(rv =&gt; rv.idx); const idxs_withBeta_beta = rvs_withBeta.map(rv =&gt; rv.idx_pd); output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_VTIPASP; // volume aspirated into tip`); output.transformedParameters.statements.push(&quot;&quot;); output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_VTIPASP_i_d[${idxs_pip.length}] = {${idxs_pip}};`); if (_.size(model.psubs) &gt; 1) { output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_VTIPASP_i_psub[${idxs_pip.length}] = {${idxs_psubsId}};`); } output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_VTIPASP_i_withBeta[${idxs_withBeta.length}] = {${idxs_withBeta}};`); output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_VTIPASP_i_withBeta_beta[${idxs_withBeta_beta.length}] = {${idxs_withBeta_beta}};`); output.transformedParameters.statements.push(` {`); output.transformedParameters.statements.push(` // - RV_TIPASP[i1] = d * (1 + beta[pd]) + RV_TIPASP_raw * (sigma_v0 + d * sigma_v1[psub])`); output.transformedParameters.statements.push(` // - RV_TIPASP[i2] = d + RV_TIPASP_raw * (sigma_v0 + d * sigma_v1[psub])`); output.transformedParameters.statements.push(` vector[${model.RV_VTIPASP.length}] temp = d[RV_VTIPASP_i_d];`); output.transformedParameters.statements.push(` temp[RV_VTIPASP_i_withBeta] = temp[RV_VTIPASP_i_withBeta] .* (1 + beta[RV_VTIPASP_i_withBeta_beta]);`); const times = (_.size(model.psubs) &gt; 1) ? &quot;.*&quot; : &quot;*&quot;; output.transformedParameters.statements.push(` RV_VTIPASP = temp + RV_VTIPASP_raw .* (sigma_v0 + temp ${times} sigma_v1${(_.size(model.psubs) &gt; 1) ? &quot;[RV_VTIPASP_i_psub]&quot; : &quot;&quot;}); // volume aspirated into tip`); output.transformedParameters.statements.push(` }`); } function handle_transformed_parameters_RV_U(model, output) { const rvs = model.RV_U; if (rvs.length == 0) return; const n = _.size(model.gammas); output.transformedData.definitions.push(` int NGAMMA = ${n}; // Number of gamma parameters`); addCentralizedParameter_mean(&quot;gamma&quot;, true, n, 1, &quot;NGAMMA&quot;, &quot;&lt;lower=0&gt;&quot;, output); addCentralizedParameter_sigma(&quot;cv_gamma&quot;, 1, 1, output); output.parameters.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_U_raw; // unintended dilution due to extra water dispense volumes`); output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_U = gamma[{${rvs.map(rv =&gt; rv.idx_gamma)}}] .* (1 + RV_U_raw * cv_gamma); // unintended dilution due to extra water dispense volumes`) output.model.push(` RV_U_raw ~ normal(0, 1);`); } function handle_transformed_parameters_RV_V(model, output) { const rvs = model.RV_V; if (rvs.length == 0) return; output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_V; // concentrations`); output.transformedParameters.statements.push(&quot;&quot;); _.forEach(rvs, (rv, i) =&gt; { if (rv.type === &quot;vWellAsp&quot;) { // if (rv.ref_vWell0) { // VolTot_t[j] = sum of volumes output.transformedParameters.statements.push(` RV_V[${rv.idx}] = RV_V[${rv.ref_vWell0.idx}] - RV_VTIPASP[${rv.ref_vTipAsp.idx}]; // volume in ${rv.well} after aspirating`); // } // else { // // VolTot_t[j] = sum of volumes // output.transformedParameters.statements.push(` RV[${idx + 1}] = -RV_VTIPASP[${rv.ref_vTipAsp.idx}]; // volume aspirated from well`); // } } else if (rv.type == &quot;vWellDis&quot;) { // Summands for well volume const l = []; if (rv.ref_vWell0) { l.push(`RV_V[${rv.ref_vWell0.idx}]`); } l.push(`RV_VTIPASP[${rv.ref_vTipAsp.idx}]`); if (rv.ref_uWellDis) { l.push(`RV_U[${rv.ref_uWellDis.idx}]`); } // Add volume to well as sum of volumes output.transformedParameters.statements.push(` RV_V[${rv.idx}] = ${l.join(&quot; + &quot;)}; // volume in ${rv.well} after dispensing`); } }); } function handle_transformed_parameters_RV_C(model, output) { const rvs = model.RV_C; if (rvs.length == 0) return; output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_C; // concentrations`); output.transformedParameters.statements.push(&quot;&quot;); _.forEach(rvs, (rv, i) =&gt; { if (rv.type === &quot;c&quot;) { if (rv.hasOwnProperty(&quot;value&quot;)) { output.transformedParameters.statements.push(` RV_C[${i+1}] = ${rv.value}; // concentration of ${rv.of}`); } else if (rv.hasOwnProperty(&quot;alpha_k&quot;)) { output.transformedParameters.statements.push(` RV_C[${i+1}] = ${rv.alpha_k}; // concentration of ${rv.of}`); } } else if (rv.type == &quot;cWellDis&quot;) { // console.log({rv}) // C_t[j] = (c[i,j-1] * v[i,j-1] + cTip * vTip) / (v[i,j-1] + vTip) if (rv.ref_cWell0 &amp;&amp; rv.ref_cTipAsp) { const cWell0 = `RV_C[${rv.ref_cWell0.idx}]`; output.transformedParameters.statements.push(` RV_C[${rv.idx}] = (${cWell0} * RV_V[${rv.ref_vWell0.idx}] + RV_C[${rv.ref_cTipAsp.idx}] * RV_VTIPASP[${rv.ref_vTipAsp.idx}]) / RV_V[${rv.ref_vWell1.idx}]; // concentration of ${rv.of}`); } else if (rv.ref_cWell0) { const cWell0 = `RV_C[${rv.ref_cWell0.idx}]`; output.transformedParameters.statements.push(` RV_C[${rv.idx}] = (${cWell0} * RV_V[${rv.ref_vWell0.idx}]) / RV_V[${rv.ref_vWell1.idx}]; // concentration of ${rv.of}`); } else if (rv.ref_uWellDis) { output.transformedParameters.statements.push(` RV_C[${rv.idx}] = (RV_C[${rv.ref_cTipAsp.idx}] * RV_VTIPASP[${rv.ref_vTipAsp.idx}]) / RV_V[${rv.ref_vWell1.idx}]; // concentration of ${rv.of}`); } else { output.transformedParameters.statements.push(` RV_C[${rv.idx}] = RV_C[${rv.ref_cTipAsp.idx}]; // concentration of ${rv.of}`); } } }); } function handle_transformed_parameters_RV_A(model, output) { const rvs = model.RV_A; if (rvs.length == 0) return; output.transformedParameters.definitions.push(` vector&lt;lower=0&gt;[${rvs.length}] RV_A; // absorbance measurements`); output.transformedParameters.statements.push(&quot;&quot;); // A ~ normal(Av + vWell * cWell, (Av + vWell * cWell) * sigma_a) // A0 readouts const rvs_A0 = rvs.filter(rv =&gt; rv.ref_a0); if (rvs_A0.length &gt; 0) { const idxs = rvs_A0.map(rv =&gt; rv.idx); const idxs_A0 = rvs_A0.map(rv =&gt; rv.ref_a0.idx); output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i1[${idxs.length}] = {${idxs}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i1_A0[${idxs_A0.length}] = {${idxs_A0}};`) output.transformedParameters.statements.push(` RV_A[RV_A_i1] = RV_A0[RV_A_i1_A0]; // absorbance of empty wells`); } // AV readouts const rvs_AV = rvs.filter(rv =&gt; rv.ref_av &amp;&amp; !rv.ref_cWell); if (rvs_AV.length &gt; 0) { const idxs = rvs_AV.map(rv =&gt; rv.idx); const idxs_AV = rvs_AV.map(rv =&gt; rv.ref_av.idx); output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i2[${idxs.length}] = {${idxs}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i2_AV[${idxs_AV.length}] = {${idxs_AV}};`) output.transformedParameters.statements.push(` RV_A[RV_A_i2] = RV_AV[RV_A_i2_AV]; // absorbance of water-filled wells`); } // A readouts const rvs_A = rvs.filter(rv =&gt; rv.ref_cWell); if (rvs_A.length &gt; 0) { const idxs = rvs_A.map(rv =&gt; rv.idx); const idxs_AV = rvs_A.map(rv =&gt; rv.ref_av.idx); const idxs_V = rvs_A.map(rv =&gt; rv.ref_vWell.idx); const idxs_C = rvs_A.map(rv =&gt; rv.ref_cWell.idx); output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i3[${idxs.length}] = {${idxs}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i3_AV[${idxs_AV.length}] = {${idxs_AV}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i3_V[${idxs_V.length}] = {${idxs_V}};`) output.transformedData.definitions.push(` int&lt;lower=1&gt; RV_A_i3_C[${idxs_C.length}] = {${idxs_C}};`) output.transformedParameters.statements.push(` RV_A[RV_A_i3] = RV_AV[RV_A_i3_AV] + RV_V[RV_A_i3_V] .* RV_C[RV_A_i3_C]; // absorbance of wells with dye`); } // Indexes for A ~ normal(...) model if (model.absorbanceMeasurements.length &gt; 0) { const idxs_A = model.absorbanceMeasurements.map(x =&gt; x.ref_a.idx); output.transformedData.definitions.push(` int&lt;lower=1&gt; A_i_A[${idxs_A.length}] = {${idxs_A}};`) output.R.push(&quot;df_RV_A = tribble(&quot;); output.R.push(&quot; ~l, ~well, ~a, ~A, ~A0, ~AV, ~V, ~C&quot;); _.forEach(model.absorbanceMeasurements, (x, i) =&gt; { const ref_a = x.ref_a; const rv = model.RV_A[ref_a.i]; if (rv.ref_a0) { output.R.push(` ,&quot;${rv.l}&quot;, &quot;${rv.wellPos}&quot;, ${i + 1}, ${rv.idx}, ${rv.ref_a0.idx}, NA, NA, NA`) } else if (rv.ref_av &amp;&amp; !rv.ref_cWell) { output.R.push(` ,&quot;${rv.l}&quot;, &quot;${rv.wellPos}&quot;, ${i + 1}, ${rv.idx}, NA, ${rv.ref_av.idx}, NA, NA`) } else if (rv.ref_cWell) { output.R.push(` ,&quot;${rv.l}&quot;, &quot;${rv.wellPos}&quot;, ${i + 1}, ${rv.idx}, NA, ${rv.ref_av.idx}, ${rv.ref_vWell.idx}, ${rv.ref_cWell.idx}`) } }); output.R.push(&quot;)&quot;); } } module.exports = { createEmptyModel, addLiquid, assignLiquid, measureAbsorbance, measureWeight, aspirate, dispense, printModel, }; × Search results Close "},"WellContents.js.html":{"id":"WellContents.js.html","title":"Source: WellContents.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: WellContents.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ /** * A module of functions for querying and manipulating well contents. * @module WellContents */ import _ from 'lodash'; var assert = require('assert'); var math = require('mathjs'); import expect from './expectCore.js'; var misc = require('./misc.js'); var wellsParser = require('./parsers/wellsParser.js'); export const emptyVolume = math.unit(0, 'ul'); export const unknownVolume = math.eval('Infinity l'); /** * Validate well contents. Throws an error if they aren't valid. * * @param {array} contents - The well contents. */ export function checkContents(contents) { if (_.isUndefined(contents)) { // ok } else if (!_.isArray(contents)) { assert(false, &quot;expected well contents to be represented by an array: &quot;+JSON.stringify(contents)); } else if (contents.length == 0) { // ok } else { //console.log(contents) var volume = math.eval(contents[0]); if (contents.length == 1) { // FIXME: remove 'false, ' from here! assert.equal(volume.toNumber('l'), 0, &quot;when the contents array has only one element, that element must be 0: &quot;+JSON.stringify(contents)); } else if (contents.length == 2) { assert(_.isString(contents[1]), &quot;second element of contents should be a string: &quot;+JSON.stringify(contents)); } else { for (var i = 1; i &lt; contents.length; i++) { //try { checkContents(contents[i]); //} catch (e) { // //} } } } } /** * Tries to find the contents array for the given syringe. * * @param {string} syringeName name of the syringe * @param {object} data the data object passed to command handlers * @param {object} effects an optional effects object for effects which have taken place during the command handler and aren't in the data object * @return {WellContents} the contents array if found, otherwise null *//* export function getSyringeContents(syringeName, data, effects) { //console.log({syringeName}) const contentsName = `${syringeName}.contents`; // Check for well or labware contents in effects object if (!_.isEmpty(effects)) { if (effects.hasOwnProperty(contentsName)) return effects[contentsName]; } let contents = misc.findObjectsValue(contentsName, data.objects, effects); checkContents(contents); return contents; }*/ /** * Tries to find the contents array for the given well. * * @param {string} wellName name of the well * @param {object} data the data object passed to command handlers * @param {object} effects an optional effects object for effects which have taken place during the command handler and aren't in the data object * @return {WellContents} the contents array if found, otherwise null */ export function getWellContents(wellName, data, effects) { //console.log({wellName}) var wellInfo = wellsParser.parseOne(wellName); assert(wellInfo.wellId, &quot;missing `wellId`: &quot;+JSON.stringify(wellInfo)); var labwareContentsName = wellInfo.labware+&quot;.contents&quot;; var wellContentsName = wellInfo.labware+&quot;.contents.&quot;+wellInfo.wellId; // Check for well or labware contents in effects object if (!_.isEmpty(effects)) { if (effects.hasOwnProperty(wellContentsName)) return effects[wellContentsName]; if (effects.hasOwnProperty(labwareContentsName)) return effects[labwareContentsName]; } var contents = misc.findObjectsValue(wellContentsName, data.objects, effects); if (!_.isEmpty(contents)) return contents; contents = misc.findObjectsValue(labwareContentsName, data.objects, effects); if (_.isArray(contents)) { expect.try({objectName: wellName}, () =&gt; checkContents(contents)); return contents; } return []; } /** * Get the volume of the contents array. * @param {array} contents The well contents array * @return {object} the mathjs volume if found, otherwise 0ul */ export function getVolume(contents) { checkContents(contents); if (!_.isEmpty(contents)) { const volume = math.eval(contents[0]); if (math.unit('l').equalBase(volume)) return volume; } return emptyVolume; } /** * Check whether the contents are empty. * They are empty if the contents are undefined, an empty array, * or the array begins with a number that mathjs considers equal to 0. * * @param {WellContents} contents * @return {Boolean} true if the contents are empty */ export function isEmpty(contents) { const volume = getVolume(contents); return math.equal(volume.toNumber('l'), 0); } /** * Get the volume of the given well. * @param {string} wellName name of the well * @param {object} data the data object passed to command handlers * @param {object} effects an optional effects object for effects which have taken place during the command handler and aren't in the data object * @return {object} the mathjs volume if found, otherwise 0ul */ export function getWellVolume(wellName, data, effects) { var contents = getWellContents(wellName, data, effects); if (!_.isEmpty(contents)) { var volume = math.eval(contents[0]); if (math.unit('l').equalBase(volume)) return volume; } return emptyVolume; } /** * Get an object representing the effects of pipetting. * @param {string} wellName fully qualified object name of the well * @param {object} data The data object passed to command handlers. * @param {object} effects The effects object for effects which have taken place during the command handler and aren't in the data object * @return {array} [content, contentName], where content will be null if not found */ export function getContentsAndName(wellName, data, effects) { //console.log(&quot;getContentsAndName&quot;, wellName) if (!effects) effects = {}; //var i = wellName.indexOf('('); //var wellId = if (i &gt;= 0) {} var wellInfo = wellsParser.parseOne(wellName); var labwareName; //console.log(&quot;wellInfo&quot;, wellInfo); if (wellInfo.source) { labwareName = wellInfo.source; } else { assert(wellInfo.wellId); labwareName = wellInfo.labware; // Check for contents of well var contentsName = labwareName+&quot;.contents.&quot;+wellInfo.wellId; //console.log(&quot;contentsName&quot;, contentsName, effects[contentsName], _.get(data.objects, contentsName)) var contents = effects[contentsName] || misc.findObjectsValue(contentsName, data.objects, effects); checkContents(contents); if (contents) return [contents, contentsName]; } // Check for contents of labware //console.log(&quot;labwareName&quot;, labwareName); var contentsName = labwareName+&quot;.contents&quot;; //console.log(&quot;contentsName&quot;, contentsName) var contents = effects[contentsName] || misc.findObjectsValue(contentsName, data.objects, effects); // If contents is an array, then we have the correct contents; // Otherwise, we have a map of well contents, but no entry for the current well yet if (_.isArray(contents)) { checkContents(contents); return [contents, contentsName]; } return [undefined, wellInfo.labware+&quot;.contents.&quot;+wellInfo.wellId]; } /** * Convert the contents array encoding to a map of substances to amounts * @param {array} contents The well contents array * @return {object} map of substance name to the volume or amount of that substance in the well */ export function flattenContents(contents) { if (_.isUndefined(contents)) { return {}; } checkContents(contents); //console.log(&quot;flattenContents:&quot;, contents); assert(_.isArray(contents), &quot;Expected 'contents' to be an array: &quot;+JSON.stringify(contents)); // The first element always holds the volume in the well. // If the array has exactly one element, the volume should be 0l. if (contents.length &lt;= 1) { return {}; } // If the array has exactly two elements, the second element is the name of the substance. else if (contents.length == 2) { assert(_.isString(contents[1]), &quot;second element of contents should be a string: &quot;+JSON.stringify(contents)); var volume = math.eval(contents[0]).format({precision: 14}); return _.fromPairs([[contents[1], volume]]); } // If the array has more than two elements, each element after the volume has the same // structure as the top array and they represent the mixture originally dispensed in the well. else { /*const maps = _(contents).tail().map(contents2 =&gt; { const flattened = flattenContents(contents2); //console.log({flattened}); const x = _.mapValues(flattened, value =&gt; math.eval(value)) //console.log({x}); return x; }).value();*/ var maps = _.map(_.tail(contents), contents =&gt; _.mapValues(flattenContents(contents), value =&gt; math.eval(value))); //console.log(&quot;maps: &quot;+JSON.stringify(maps)); var merger = function(a, b) { return (_.isUndefined(a)) ? b : math.add(a, b); }; var mergeArgs = _.flatten([{}, maps, merger]); //console.log(&quot;mergeArgs: &quot;+mergeArgs); var merged = _.mergeWith.apply(_, mergeArgs); //console.log(&quot;merged: &quot;+JSON.stringify(merged)); var total = math.eval(contents[0]); var subTotal = _.reduce(merged, function(total, n) { return math.add(total, n); }, emptyVolume); //console.log(&quot;total: &quot;+total); //console.log(&quot;subTotal: &quot;+subTotal); //var factor = math.fraction(total, subTotal); try { const result = _.mapValues(merged, function(v) { //console.log({v, totalNumber: total.toNumber(&quot;l&quot;)}) const numerator = math.multiply(v, total.toNumber(&quot;l&quot;)); const result = math.divide(numerator, subTotal.toNumber(&quot;l&quot;)) return result.format({precision: 4}); }); return result; } catch (e) { console.log({total: total.toNumber(&quot;l&quot;), subTotal: subTotal.toNumber(&quot;l&quot;), factor}) console.log(JSON.stringify(contents)) throw e; } } } export function mergeContents(contents) { const flat = flattenContents(contents); const pairs = _.toPairs(flat); if (pairs.length === 0) { return []; } else if (pairs.length === 1) { const l = pairs[0]; return [l[1], l[0]]; } else { const volumes1 = _.values(flat); const volumes2 = volumes1.map(s =&gt; math.eval(s)); const sum = math.sum(volumes2); const contents2 = [sum.format({precision: 14})].concat(pairs.map(l =&gt; [l[1], l[0]])); return contents2; } } /** * Add source contents to destination contents at the given volume. * @param {array} srcContents - current contents of the source well * @param {array} dstContents - current contents of the destination well * @param {string} volume - a string representing the volume to transfer * @return {array} an array whose first element is the new source contents and whose second element is the new destination contents. */ export function transferContents(srcContents, dstContents, volume) { assert(_.isArray(srcContents)); checkContents(srcContents); if (_.isString(volume)) volume = math.eval(volume); const volumeText = volume.format({precision: 14}); //console.log({dstContents}) if (_.isUndefined(dstContents) || _.isEmpty(dstContents) || !_.isArray(dstContents)) dstContents = []; //console.log({dstContents}) checkContents(dstContents); const srcContentsToAppend = [volumeText].concat(_.tail(srcContents)); let dstContents2; // If the destination is empty: if (dstContents.length &lt;= 1) { dstContents2 = srcContentsToAppend; } else { const dstVolume = math.eval(dstContents[0]); const totalVolumeText = math.add(dstVolume, volume).format({precision: 14}); // If the destination currently only contains one substance: if (dstContents.length === 2) { dstContents2 = [totalVolumeText, dstContents, srcContentsToAppend]; } // Otherwise add source to destination contents else { const dstSumOfComponents = math.sum(_.map(_.tail(dstContents), l =&gt; math.eval(l[0]))); if (math.equal(dstVolume, dstSumOfComponents)) { dstContents2 = _.flatten([totalVolumeText, _.tail(dstContents), [srcContentsToAppend]]); } else { dstContents2 = _.flatten([totalVolumeText, [dstContents], [srcContentsToAppend]]); } } } //console.log(&quot;dstContents&quot;, dstContents); // Decrease volume of source const srcVolume0 = math.eval(srcContents[0]); const srcVolume1 = math.chain(srcVolume0).subtract(volume).done(); const srcContents2 = [srcVolume1.format({precision: 14})].concat(_.tail(srcContents)); checkContents(srcContents2); checkContents(dstContents2); return [srcContents2, dstContents2]; } × Search results Close "},"roboliqSchemas.js.html":{"id":"roboliqSchemas.js.html","title":"Source: roboliqSchemas.js","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Source: roboliqSchemas.js /** * Roboliq: Automation for liquid-handling robots * @copyright 2017, ETH Zurich, Ellis Whitehead * @license GPL-3.0 */ // REFACTOR: it might make sense to remove this file, but it's currently used in commandHelper.js const roboliqSchemas = { Number: {type: 'number'}, Object: {type: 'object'}, //String: {type: 'string'}, }; export default roboliqSchemas; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Global Members _ Roboliq: Automation for liquid-handling robots Copyright: 2017, ETH Zurich, Ellis Whitehead License: GPL-3.0 Source: config/ourlab_luigi.js, line 7 &lt;constant&gt; _ Roboliq: Automation for liquid-handling robots Copyright: 2017, ETH Zurich, Ellis Whitehead License: GPL-3.0 Source: expectCore.js, line 7 _ Roboliq: Automation for liquid-handling robots Copyright: 2017, ETH Zurich, Ellis Whitehead License: GPL-3.0 Source: expect.js, line 7 module:commands/timer :Protocol Type: Protocol Source: commands/timer.js, line 345 &lt;constant&gt; roboliqSchemas Roboliq: Automation for liquid-handling robots Copyright: 2017, ETH Zurich, Ellis Whitehead License: GPL-3.0 Source: roboliqSchemas.js, line 9 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Modules Namespaces equipment fluorescenceReader pipetter timer transporter × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Namespaces Namespaces equipment fluorescenceReader pipetter timer transporter × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Roboliq ProcessorRoboliq takes biological protocols and compiles them for robotic lab automation. This documentation was generated with JSDoc. It contains programmer documentation about the functions used in Roboliq's protocol processor. Additional documentation Manual -- the Roboliq manual Processor API -- programmer documentation for Roboliq's protocol processor Evoware API -- programmer documentation for Roboliq's Evoware backend Setupnpm installDevelopmentTo run the tests: npm testTo update the parsers (e.g for well locations): npm run pegjsTo generate the HTML documentation: npm run jsdoc × Search results Close "},"equipment.html":{"id":"equipment.html","title":"Namespace: equipment","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Namespace: equipment equipment Namespace for the equipment commands. Version: v1 Source: commands/equipment.js, line 7 × Search results Close "},"fluorescenceReader.html":{"id":"fluorescenceReader.html","title":"Namespace: fluorescenceReader","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Namespace: fluorescenceReader fluorescenceReader Namespace for the fluorescenceReader commands. Version: v1 Source: commands/fluorescenceReader.js, line 7 Type Definitions measurePlate Measure the fluorescence of a plate. Properties: Name Type Argument Description command string &quot;fluorescenceReader.measurePlate&quot; agent string &lt;optional&gt; Agent identifier equipment string &lt;optional&gt; Equipment identifier program Object Program object for measurement outputFile string Filename for output object string Plate identifier site string &lt;optional&gt; Site identifier in reader destinationAfter string &lt;optional&gt; Site to move the plate to after measurement Source: commands/fluorescenceReader.js, line 34 × Search results Close "},"module-commandHelper.html":{"id":"module-commandHelper.html","title":"Module: commandHelper","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commandHelper A collection of helper functions for command handlers. Source: commandHelper.js, line 7 Methods &lt;inner&gt; asArray(x) Ensure that the value is an array. If the value is already an array, return it directly. If the value is undefined, return an empty array. Otherwise, return the value wrapped in an array. Parameters: Name Type Description x any value Source: commandHelper.js, line 33 Returns: an array Type array &lt;inner&gt; calculateWithMathjs() Calculate expr using variables in context, with optional spec object specifying units and/or decimals Source: commandHelper.js, line 195 &lt;inner&gt; createData(protocol, objects, SCOPE, DATA, path, files) Create the 'data' object that gets passed into many commandHelper functions. TODO: Rather than calling it 'data', we should probably rename it to 'context'. Parameters: Name Type Description protocol Protocol objects object = {} - current objects SCOPE object = {} - current SCOPE DATA array = [] - current DATA table path array = [] - current processing path (usually a step ID, e.g. step 1.2 would be given by [1, 2]) files object = {} - map of filename to loaded filedata Source: commandHelper.js, line 52 Returns: the 'data' object that gets passed into many commandHelper functions Type object &lt;inner&gt; dereferenceVariable(data, name) Recursively lookup variable by name or path and return the final value. Parameters: Name Type Description data object protocol data name string name or path of object to lookup in data.objects Source: commandHelper.js, line 689 Returns: result of the lookup, if successful; otherwise undefined. Type any &lt;inner&gt; fixPredicateUndefines(predicates) Helper function for queryLogic() that replaces undefined property values with the name of the property prefixed by '?'. Parameters: Name Type Description predicates Array Array of llpl predicates Source: commandHelper.js, line 1165 &lt;inner&gt; g(data, path, dflt) Try to get a value from data.objects with the given name. Parameters: Name Type Description data object Data object with 'objects' property path array | string Name of the object value to lookup dflt any default value to return Source: commandHelper.js, line 641 Returns: The value at the given path, if any Type Any &lt;inner&gt; getCommon(value) If value is an array and every element of the array is the same, return the first value of the array. Otherwise just return the value. Parameters: Name Type Description value any value to inspect Source: commandHelper.js, line 769 &lt;inner&gt; getParsedValue(parsed, data, paramName, propertyName, defaultValue) Get a property value from an object in the parsed parameters. If no value could be found (and no default was given) then an exception will be thrown. Parameters: Name Type Description parsed object the parsed parameters object, as passed into a command handler data object protocol data paramName string parameter name (which should reference an object) propertyName string name of the object's property to retrieve defaultValue any default value if property not found Source: commandHelper.js, line 1078 Returns: the property value Type any &lt;inner&gt; getStepKeys(o) Return array of step keys in order. Any keys that begin with a number will be included, and they will be sorted in natural order. Parameters: Name Type Description o object | array an object or array of steps Source: commandHelper.js, line 1325 Returns: an ordered array of keys that represent steps Type array &lt;inner&gt; lookupInputPath(path, parsed, data) Lookup nested paths. Parameters: Name Type Description path array [description] parsed object [description] data object [description] Source: commandHelper.js, line 1269 Returns: [description] Type any Example * &quot;object&quot;: gets parameter value. * &quot;?object&quot;: optionally gets parameter value. * &quot;object*&quot;: looks up object. * &quot;object*location&quot;: looks up object, gets `location` property. * &quot;object*location*&quot;: looks up object, gets `location` property, looks up location. * &quot;object*location*type&quot;: looks up object, looks up its `location` property, gets type property. * &quot;something**&quot;: double de-reference * &quot;object*(someName)&quot;: looks up object, gets someName value, gets object's property with that value. (this is not currently implemented) &lt;inner&gt; lookupPath(path, params, data) Lookup nested paths. Parameters: Name Type Description path array [description] params object [description] data object [description] Source: commandHelper.js, line 1199 Returns: [description] Type any Example This example will first lookup `object` in `params`, then lookup the result in `data.objects`, then get the value of `model`, then lookup it value for `evowareName`: ``` [[&quot;@object&quot;, &quot;model&quot;], &quot;evowareName&quot;] ``` &lt;inner&gt; lookupValue0(result, path, data, value0) Try to lookup value0 in objects set. This function is recursive - if the value refers to a variable, the variables value will also be dereferenced. When a variable is looked up, its also added to result.objectName[path]. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object data object protocol data value0 any The value from the user. Source: commandHelper.js, line 664 Returns: A new value, if value0 referred to something in data.objects. Type any &lt;inner&gt; parseInputSpec() Parse input spec and return object with the same properties as the spec, but with values looked up. Source: commandHelper.js, line 1244 &lt;inner&gt; parseParams(params, data, schema) Parse command parameters according to a schema. If parsing fails, an exception will be thrown. Otherwise, the returned result contains two properties: value and objectName. Both properties are maps that reflect the structure of the given schema. The value map contains the parsed values -- object references are replaced by the actual object (in data), quantities are replaced by mathjs objects, well specifications are replaced by an array of well references, etc. The objectName map contains any object names that were referenced; in contrast to the value map (which is a tree of properties like params), objectName is a flat map, where the keys are string representations of the object paths (separated by '.'). Any object names that were looked up will also be added to the data.accesses list. Parameters: Name Type Description params object the parameters passed to the command data object protocol data schema object JSON Schema description, with roboliq type extensions Source: commandHelper.js, line 321 Returns: the parsed parameters, if successfully parsed. Type object &lt;inner&gt; processDuration(result, path, x0, data) Try to process a value as a time duration. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x0 object the value to process data object protocol data Source: commandHelper.js, line 1053 &lt;inner&gt; processLength(result, path, x, data) Try to process a value as a length. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 829 &lt;inner&gt; processObjectOfType(result, path, x, data, type, allowArray) Tries to process and object with the given type, whereby this simply means checking that the value is a plain object with a property type whose value is the given type. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data type string type of object expected allowArray boolean false if we should not look into an array for an object Source: commandHelper.js, line 883 &lt;inner&gt; processOneOfBasicType(result, path, value, fnCheck, expectedTypeName) Accept either a single value whose type is checked with fnCheck(), or an array with each element equal to the first - in that case, set the result value to the first element of the array. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object value any the value to process fnCheck function a function that returns true if the value has the correct type expectedTypeName string name of the expected type, for constructing the error message if fnCheck fails Source: commandHelper.js, line 748 &lt;inner&gt; processOneOrArray(result, path) Try to call fn on value0. If that works, return the value is made into a singleton array. Otherwise try to process value0 as an array. fn should accept parameters (result, path, value0) and set the value in result.value at the given path. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object Source: commandHelper.js, line 785 &lt;inner&gt; processParamsBySchema(result, path, params, schema, data) Try to process the given params with the given schema. Updates the result object. Updates data.accesses if object lookups are performed. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object params object the part of the original parameters refered to by path schema object JSON Schema description, with roboliq extensions data object protocol data Source: commandHelper.js, line 350 &lt;inner&gt; processSiteOrStay(result, path, x, data) Try to process a value as the keyword &quot;stay&quot; or as a Site reference. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 904 &lt;inner&gt; processSource(result, path, x, data) Try to process a value as a source reference. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 922 &lt;inner&gt; processSources(result, path, x, data) Try to process a value as an array of source references. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 938 &lt;inner&gt; processString(result, path, params, data) Try to process a value as a string. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object params object the part of the original parameters refered to by path data object protocol data Source: commandHelper.js, line 847 &lt;inner&gt; processTemperature(result, path, x, data) Try to process a value as a temperature. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 980 &lt;inner&gt; processValue0AsEnum(result, path, value0, schema, data) Try to process the value as an enum. Parameters: Name Type Description result object result structure for values and objectNames path array path in params value0 any the value to process schema object schema data object protocol data Source: commandHelper.js, line 474 &lt;inner&gt; processValue0BySchema(result, path, value0, schema, data) Try to convert value0 (a &quot;raw&quot; value, no yet looked up) to the given type. If schema is undefined, return value. If schema.enum: return processValue0AsEnum() If schema.type is undefined but there are schema.properties, assume schema.type = &quot;object&quot;. If type is undefined or empty, return value. If type is an array, try processing for each element of the array Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object value0 any the value to process schema object JSON Schema description, with roboliq extensions data object protocol data Source: commandHelper.js, line 429 &lt;inner&gt; processValue0BySchemaType(result, path, value0, schema, data) A sub-function of processValue0BySchema(). Try to process the value as a named type. Parameters: Name Type Description result object result structure for values and objectNames path array path in params value0 any the value to process schema object schema data object protocol data Source: commandHelper.js, line 489 &lt;inner&gt; processValue0OnTypes(result, path, value0, schema, types, data) A sub-function of processValue0BySchema(). Try to process the value as a named type. Parameters: Name Type Description result object result structure for values and objectNames path array path in params value0 any the value to process schema object schema types array a list of types to try data object protocol data Source: commandHelper.js, line 588 &lt;inner&gt; processValueAsArray(result, path, value0, schema, data) Try to process a value as an array. Parameters: Name Type Description result object result structure for values and objectNames path array path in params value0 any the value to process schema object schema of the array items data object protocol data Source: commandHelper.js, line 614 &lt;inner&gt; processVolume(result, path, x, data) Try to process a value as a volume. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 999 &lt;inner&gt; processWell(result, path, x, data) Try to process a value as a well reference. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 1018 &lt;inner&gt; processWells(result, path, x, data) Try to process a value as an array of wells. Parameters: Name Type Description result object the resulting object to return, containing objectName and value representations of params. path array path in the original params object x object the value to process data object protocol data Source: commandHelper.js, line 1037 &lt;inner&gt; queryLogic(data, predicates, predicateName) Query the logic database with the given predicates. If solutions are found, choose one of the alternatives. Parameters: Name Type Description data Object Command data predicates Array Array of llpl predicates predicateName String Name of the predicate we're interested in Source: commandHelper.js, line 1140 Returns: an array where the first item is the chosen solution, and the second item includes all alternatives. If no solution was found, then both items will be undefined. Type Array &lt;inner&gt; queryLogicGeneral(data, predicates, queryExtract) Query the logic database with the given predicates and return the values of interest. Parameters: Name Type Description data Object Command data predicates Array Array of llpl predicates queryExtract String A jmespath query string to extract values of interest from the llpl result list Source: commandHelper.js, line 1102 Returns: Array of objects holding valid values Type Array &lt;inner&gt; stepify(steps) Return an object that conforms to the expected format for steps. Parameters: Name Type Description steps array | object input in format of an array of steps, a single step, or propertly formatted steps. Source: commandHelper.js, line 1348 Returns: an object with only numeric keys, representing a sequence of steps. Type object &lt;inner&gt; substituteDeep(x, data) Recursively replace $-SCOPE, $$-DATA, and template strings in x. The recursion has the following exceptions: skip objects with any of these properties: data, @DATA, @SCOPE skip steps properties skip directives Parameters: Name Type Description x any the variable to perform substitutions on data object protocol data Source: commandHelper.js, line 108 Returns: the value with possible substitutions Type any &lt;inner&gt; updateSCOPEDATA() Process '@DATA', '@SCOPE', and 'data' properties for a step, The returned data table will be the first to exist of '@DATA', 'DATA', and 'objects.DATA' The returned scope will be the merger of data.objects.SCOPE, SCOPE, '@SCOPE', and common DATA values. and return updated {DATA, SCOPE}. Source: commandHelper.js, line 1374 × Search results Close "},"module-commands_absorbanceReader.html":{"id":"module-commands_absorbanceReader.html","title":"Module: commands/absorbanceReader","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/absorbanceReader Absorbance Reader commands module. Version: v1 Source: commands/absorbanceReader.js, line 7 Members &lt;static&gt; commandHandlers Handlers for absorbanceReader commands. Source: commands/absorbanceReader.js, line 31 × Search results Close "},"module-commands_centrifuge.html":{"id":"module-commands_centrifuge.html","title":"Module: commands/centrifuge","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/centrifuge Centrifuge commands module (see Commands#centrifuge or command specification). THIS SECTION IS FOR TESTING ONLY: loadEvowareCarrierData module:commandHelper module:commands/centrifuge END OF SECTION See roboliq#Protocol. Version: v1 Source: commands/centrifuge.js, line 7 Members &lt;static&gt; commandHandlers Handlers for centrifuge commands. Source: commands/centrifuge.js, line 297 &lt;static&gt; objectToPredicateConverters Create predicates for objects of type = &quot;Centrifuge&quot; Source: commands/centrifuge.js, line 33 × Search results Close "},"module-commands_equipment.html":{"id":"module-commands_equipment.html","title":"Module: commands/equipment","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/equipment Equipment commands module. Version: v1 Source: commands/equipment.js, line 13 Members &lt;static&gt; commandHandlers Handlers for equipment commands. Source: commands/equipment.js, line 41 &lt;static&gt; planHandlers Plan handler to allow other modules to use equipment._close and equipment._openSite as planning actions. Source: commands/equipment.js, line 131 × Search results Close "},"module-commands_fluorescenceReader.html":{"id":"module-commands_fluorescenceReader.html","title":"Module: commands/fluorescenceReader","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/fluorescenceReader Fluorescence Reader commands module. Version: v1 Source: commands/fluorescenceReader.js, line 13 Members &lt;static&gt; commandHandlers Handlers for fluorescenceReader commands. Source: commands/fluorescenceReader.js, line 33 × Search results Close "},"module-commands_incubator.html":{"id":"module-commands_incubator.html","title":"Module: commands/incubator","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/incubator Incubator commands module (see Commands#incubator or command specification). See roboliq#Protocol. Version: v1 Source: commands/incubator.js, line 7 Members &lt;static&gt; commandHandlers Handlers for incubator commands. Source: commands/incubator.js, line 46 &lt;static&gt; objectToPredicateConverters Create predicates for objects of type = &quot;Incubator&quot; Source: commands/incubator.js, line 27 × Search results Close "},"module-commands_pipetter.html":{"id":"module-commands_pipetter.html","title":"Module: commands/pipetter","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/pipetter Pipetter commands module. Version: v1 Source: commands/pipetter.js, line 13 Members &lt;static, constant&gt; commandHandlers Handlers for pipetter commands. Source: commands/pipetter.js, line 794 Methods &lt;inner&gt; getLabwareWell( [labwareName] [, well]) Takes a labware name and a well and returns a fully specified well. If the wells is undefined, return undefined. Parameters: Name Type Argument Description labwareName string &lt;optional&gt; name of labware for wells that don't have specified labware. well array &lt;optional&gt; well identifier, with or without labware explicitly specified. Source: commands/pipetter.js, line 51 Returns: fully specified well (e.g. on labware). Type array &lt;inner&gt; getLabwareWellList( [labwareName] [, wells]) Takes a labware name and a list of wells and returns a list of wells. If the list of wells is empty or undefined, an empty array is returned. Parameters: Name Type Argument Description labwareName string &lt;optional&gt; name of labware for wells that don't have specified labware. wells array &lt;optional&gt; list of wells, with or without labware explicitly specified. Source: commands/pipetter.js, line 66 Returns: a list of wells on labware. Type array × Search results Close "},"module-commands_pipetter_groupingMethods.html":{"id":"module-commands_pipetter_groupingMethods.html","title":"Module: commands/pipetter/groupingMethods","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/pipetter/groupingMethods Functions to break pipeetting items into groups that should be handled simultaneously. Possible methods include: each item is its own group groups are built until no more syringes would be available based on the item's tipModel (but syringe doesn't need to be assigned yet) groups are built (with limited look-ahead) where alternatives are investigated when a group splits over two columns have a fixed assignment between wells and syringes (i.e. row n = tip (n % 4)) for the sake of managing differences between tips Source: commands/pipetter/groupingMethods.js, line 1 Methods &lt;static&gt; groupingMethod1(items) Place each item into its own group. Parameters: Name Type Description items array Array of pipetting items. Source: commands/pipetter/groupingMethods.js, line 21 Returns: An array of groups of items; each group is a sublist of items from the original array. Type array &lt;static&gt; groupingMethod2(items, syringes, tipModelToSyringes) Groups are built until no more syringes would be available based on the item's tipModel (but syringe doesn't need to be assigned yet). Also break groups on program changes. TODO: break group if a previous dispense well is used as a source well. NOTE: if 'tipModelToSyringes' is supplied, this algorithm will not work predictably if the sets of syringes partially overlap with each other (complete overlap is fine). Parameters: Name Type Description items array Array of pipetting items. syringes array Array of integers representing the available syringe indexes tipModelToSyringes object An optional map from tipModel to syringes that can be used with the given tipModel. If the map contains syringes that aren't listed in the 'syringes' array, they won't be used. Source: commands/pipetter/groupingMethods.js, line 37 Returns: An array of groups of items; each group is a sublist of items from the original array. Type array &lt;static&gt; groupingMethod3(items, syringes, tipModelToSyringes) Groups are built until no more syringes would be available based on the item's tipModel (but syringe doesn't need to be assigned yet). It tries to group by layer by putting as many items from the same layer into the group before moving onto the next item. Breaks are forced on: program changes when a previous dispense well is used as a source well NOTE: if 'tipModelToSyringes' is supplied, this algorithm will not work predictably if the sets of syringes partially overlap with each other (complete overlap is fine). Parameters: Name Type Description items array Array of pipetting items. syringes array Array of integers representing the available syringe indexes tipModelToSyringes object An optional map from tipModel to syringes that can be used with the given tipModel. If the map contains syringes that aren't listed in the 'syringes' array, they won't be used. Source: commands/pipetter/groupingMethods.js, line 97 Returns: An array of groups of items; each group is a sublist of items from the original array. Type array × Search results Close "},"module-commands_pipetter_pipetterUtils.html":{"id":"module-commands_pipetter_pipetterUtils.html","title":"Module: commands/pipetter/pipetterUtils","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/pipetter/pipetterUtils A module of helper functions for the pipetter commands. Source: commands/pipetter/pipetterUtils.js, line 1 Methods &lt;static&gt; getEffects_pipette(params, data, effects) Get an object representing the effects of pipetting, aspirating, or dispensing. Parameters: Name Type Description params object The parameters for the pipetter._aspirate command. data object The data object passed to command handlers. effects object an optional effects object for effects which have taken place during the command handler and aren't in the data object Source: commands/pipetter/pipetterUtils.js, line 41 Returns: The effects caused by the _aspirate, _dispense or _pipette command. Type object &lt;static&gt; getSyringeName(syringeName, data) Get fully qualified syringe object name Parameters: Name Type Description syringeName string | integer name or number of syringe data object The data object passed to command handlers. Source: commands/pipetter/pipetterUtils.js, line 20 Returns: fully qualified syringe object name, if found Type string × Search results Close "},"module-commands_pipetter_sourceMethods.html":{"id":"module-commands_pipetter_sourceMethods.html","title":"Module: commands/pipetter/sourceMethods","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/pipetter/sourceMethods Methods for assigning which source well to use when a source liquid is available in multiple wells. Details: Assign source well by group for items without assigned source wells; if multiple syringes need to access the same source, and that source has multiple wells, then possible methods include: pick first one rotate through source wells in order rotate through source wells in order of max volume try a simple geometrical assignment considering whether there are more tips or wells; if that fails, use previous method same as above, but if wells &gt; tips, try starting at first (wells - tips) wells and see which one produces the greatest minimum final volume Source: commands/pipetter/sourceMethods.js, line 1 Methods &lt;static&gt; sourceMethod1(group, data) Pick the first well in a source set and ignore the others. The 'sourceWell' property of each item in 'group' will be set. Parameters: Name Type Description group array Array of pipetting items that are grouped together data object Data passed to the commandHandler Source: commands/pipetter/sourceMethods.js, line 34 &lt;static&gt; sourceMethod3(group, data, effects) Rotate through source wells in order of max volume. The 'sourceWell' property of each item in 'group' will be set. Parameters: Name Type Description group array Array of pipetting items that are grouped together data object Data passed to the commandHandler effects object (Optional) Map from variable to effects Source: commands/pipetter/sourceMethods.js, line 77 × Search results Close "},"module-commands_simulatedHelpers.html":{"id":"module-commands_simulatedHelpers.html","title":"Module: commands/simulatedHelpers","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/simulatedHelpers Helper functions for simulating measurements. Source: commands/simulatedHelpers.js, line 7 × Search results Close "},"module-commands_timer.html":{"id":"module-commands_timer.html","title":"Module: commands/timer","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/timer Timer commands module. Source: commands/timer.js, line 13 Members &lt;static&gt; commandHandlers Handlers for timer commands. Source: commands/timer.js, line 81 &lt;static&gt; objectToPredicateConverters Create predicates for objects of type = &quot;Timer&quot; Source: commands/timer.js, line 30 × Search results Close "},"module-commands_transporter.html":{"id":"module-commands_transporter.html","title":"Module: commands/transporter","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: commands/transporter Transporter commands module. Version: v1 Source: commands/transporter.js, line 13 Members &lt;static&gt; commandHandlers Handlers for transporter commands. Source: commands/transporter.js, line 577 &lt;static&gt; objectToPredicateConverters Create predicates for objects of type = &quot;Transporter&quot; Source: commands/transporter.js, line 30 &lt;static&gt; planHandlers Plan handler to allow other modules to use transporter._movePlate as a planning action. Source: commands/transporter.js, line 753 Methods &lt;inner&gt; makeMoveLidFromContainerToSiteParams() Take the parsed parameters passed to transporter.moveLidFromContainerToSite and create the parameter list for the task moveLidFromContainerToSite in makeMoveLidFromContainerToSiteMethod(). If any of the following parameters are not specified, then they will also be a part of the created parameters: agent, equipment, program Source: commands/transporter.js, line 146 &lt;inner&gt; makeMoveLidFromSiteToContainerParams() Take the parsed parameters passed to transporter.moveLidFromSiteToContainer and create the parameter list for the task moveLidFromSiteToContainer in makeMoveLidFromSiteToContainerMethod(). If any of the following parameters are not specified, then they will also be a part of the created parameters: agent, equipment, program Source: commands/transporter.js, line 325 &lt;inner&gt; moveLidFromContainerToSite() Transport a lid from a container to a destination site. Source: commands/transporter.js, line 44 &lt;inner&gt; moveLidFromSiteToContainer() Transport a lid from an origin site to a container. Source: commands/transporter.js, line 220 × Search results Close "},"module-config_roboliq.html":{"id":"module-config_roboliq.html","title":"Module: config/roboliq","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: config/roboliq Roboliq's default configuration. Source: config/roboliq.js, line 7 × Search results Close "},"module-config_roboliqDirectiveHandlers.html":{"id":"module-config_roboliqDirectiveHandlers.html","title":"Module: config/roboliqDirectiveHandlers","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: config/roboliqDirectiveHandlers Roboliq's default directives. Source: config/roboliqDirectiveHandlers.js, line 7 Methods &lt;inner&gt; directive_factorialMerge(spec) Merge an array of objects, or combinatorially merge an array of arrays of objects. Parameters: Name Type Description spec Array The array of objects or arrays of objects to merge. Source: config/roboliqDirectiveHandlers.js, line 256 Returns: The object or array resulting from combinatorial merging. Type Object | Array &lt;inner&gt; genMerge2(spec, data, obj0, index, acc) Helper function for factorial merging of arrays of objects. For example, the first element of the first array is merged with the first element of the second array, added to the acc list, then the first element of the first array is merged with the second element of the second array, and so on. Parameters: Name Type Description spec array array of objects, may be nested arbitrarily deep, i.e. array of arrays of objects data object [description] obj0 object accumulated result of the current merge, will be added to acc once the end of the spec list is reached index number index of current item in spec acc array accumulated list of merged objects Source: config/roboliqDirectiveHandlers.js, line 282 Returns: Returns a factorial list of merged objects. Type array × Search results Close "},"module-design.html":{"id":"module-design.html","title":"Module: design","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: design Functions for processing design specifications. In particular, it can take concise design specifications and expand them into a long table of factor values. Source: design.js, line 9 Members &lt;inner, constant&gt; actionHandlers :Object If an action handler return 'undefined', it means that the handler took care of the action already. Type: Object Source: design.js, line 858 Methods &lt;static&gt; calculate() Calculate expr using variables in row, with optional action object specifying units and/or decimals Source: design.js, line 1256 &lt;static&gt; expandConditions(conditions, table0) If conditions is an array, then each element will be processed individually and then the results will be merged together. Parameters: Name Type Description conditions object | array an object of conditions or an array of such objects. table0 array the initial rows to start expanding conditions on (default [{}]) Source: design.js, line 360 &lt;static&gt; expandRowsByNamedValue() // REQUIRED by: expandRowsByObject expandRowsByNamedValue: TODO: turn the name/value into an action in order to allow for more sophisticated expansion if has star-suffix, call branchRowsByNamedValue else call assignRowsByNamedValue Source: design.js, line 400 &lt;static&gt; flattenArrayAndIndexes(rows, rowIndexes [, otherRowIndexes], rowIndexesOffset) Is like _.flattenDeep, but only for the given rows, and it mutates both the rows array and rowIndexes array in-place. Parameters: Name Type Argument Description rows array array to flatten rowIndexes array array of row indexes to flatten otherRowIndexes array &lt;optional&gt; a second, optional array of row indexes that should have the same modifications made to it as rowIndexes rowIndexesOffset integer index in rowIndexes to start at Source: design.js, line 299 &lt;static&gt; flattenArrayM(rows) Is like _.flattenDeep, but it mutates the array in-place. Parameters: Name Type Description rows array array to flatten Source: design.js, line 276 &lt;static&gt; flattenDesign(design) Turn a design specification into a design table. Parameters: Name Type Description design object the design specification. Source: design.js, line 183 &lt;static&gt; printMarkdown(rows) Print a markdown pipe table Parameters: Name Type Description rows array array of rows Source: design.js, line 140 &lt;static&gt; printRows(rows [, hideRedundancies]) Print a text representation of the table Parameters: Name Type Argument Description rows array array of rows hideRedundancies Boolean &lt;optional&gt; suppress printing of values that haven't changed from the previous row Source: design.js, line 42 &lt;static&gt; printTAB(rows) Print a TAB-formatted representation of the table Parameters: Name Type Description rows array array of rows Source: design.js, line 99 &lt;static&gt; query_orderBy(rows, rowIndexes, orderBy) Return an array of rowIndexes which are ordered by the orderBy criteria. Parameters: Name Type Description rows array a flat array of row objects rowIndexes array array of row indexes to consider orderBy string | array the column(s) to order by Source: design.js, line 1523 Returns: a sorted ordering of rowIndexes Type array &lt;inner&gt; assertNoDuplicates() Check whether the same underlying array shows up more than once in otherRowIndexes. This should never be the case, because if we modify one, the &quot;other&quot; will also be modified. Source: design.js, line 1701 &lt;inner&gt; expandRowsByObject() expandRowsByObject: for each key/value pair, call expandRowsByNamedValue Source: design.js, line 381 &lt;inner&gt; filterOnWhereOnce(table, key, x, fn) Sub-function that filters table on a single criterion. Parameters: Name Type Description table array table to filter key string key of column in table x any value to compare to fn function comparison function Source: design.js, line 1675 Returns: filtered table Type array × Search results Close "},"module-generateSchemaDocs.html":{"id":"module-generateSchemaDocs.html","title":"Module: generateSchemaDocs","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: generateSchemaDocs Generate documentation from the schemas in schemas/*.yaml. Running this module will create these files: tutorials/Object_Types.md tutorials/Commands.md Source: generateSchemaDocs.js, line 7 Methods &lt;inner&gt; commandToJsdoc(pair) Convert a name/schema pair to markdown text. Parameters: Name Type Description pair array [name, schema] Source: generateSchemaDocs.js, line 104 Returns: A markdown string. &lt;inner&gt; indentJsdocComment(s) Take a string, split it on all newlines, prepend each newline with &quot; * &quot;, and then rejoin. Parameters: Name Type Description s string string to indent Source: generateSchemaDocs.js, line 66 Returns: string indented by &quot; * &quot; Type string &lt;inner&gt; toMarkdown(pair) Convert a name/schema pair to markdown text. Parameters: Name Type Description pair array [name, schema] Source: generateSchemaDocs.js, line 27 Returns: A markdown string. &lt;inner&gt; typeToJsdoc(pair, isCommand) Convert a name/schema pair to jsdoc text. Parameters: Name Type Default Description pair array [name, schema] isCommand boolean false true if pair is a command, in which case the memberOf field is handled differently. Source: generateSchemaDocs.js, line 76 Returns: A markdown string. × Search results Close "},"module-misc.html":{"id":"module-misc.html","title":"Module: misc","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: misc A set of miscellaneous helper functions. Some of these are HACKs that should be moved to another module or removed entirely. Source: misc.js, line 7 Methods &lt;static&gt; extractValuesFromQueryResults() queryResults: value returned from llpl.query() predicateName: name of the predicate that was used for the query Source: misc.js, line 29 Returns: {parameterName1: parameterValues1, ...} Type object &lt;static&gt; mapDeep(x, fn) Recurses into object properties and maps them to the result of fn. Parameters: Name Type Description x Any Any value. fn function A function (x, key, path) that returns a mapped value. Source: misc.js, line 232 Returns: Return the deeply mapped object. Type Any &lt;static&gt; mutateDeep(x, fn) Recurses into object properties and replaces them with the result of fn. 'x' will be mutated. Parameters: Name Type Description x Any Any value. fn function A function that returns a transformed value. Source: misc.js, line 256 Returns: nothing &lt;inner&gt; handleDirective(spec, data) If spec is a directive, process it and return the result. Parameters: Name Type Description spec Any Any value. If this is a directive, it will be an object with a single key that starts with '#'. data Object An object with properties: directiveHandlers, objects, events. Source: misc.js, line 121 Returns: Return the object, or if it was a directive, the results of the directive handler. Type Any &lt;inner&gt; handleDirectiveDeep(spec, data) Recurses into object properties and replaces them with the result of handleDirective. It will, however, skip properties named 'steps'. Parameters: Name Type Description spec Any Any value. If this is a directive, it will be an object with a single key that starts with '#'. data Object An object with properties: directiveHandlers, objects, events. Source: misc.js, line 204 Returns: Return the object, or if it was a directive, the results of the directive handler. Type Any × Search results Close "},"module-parsers_wellsParser.html":{"id":"module-parsers_wellsParser.html","title":"Module: parsers/wellsParser","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: parsers/wellsParser Module for parsing strings that represent wells and labware. Source: parsers/wellsParser.js, line 1 Methods &lt;static&gt; locationRowColToText(row, col) Converts a row and column index to a string. For example, [1, 1] =&gt; A01, and [8, 12] =&gt; H12. Parameters: Name Type Description row number row of well col number column of well Source: parsers/wellsParser.js, line 34 Returns: string representation of location of well on labware Type string &lt;static&gt; locationTextToRowCol(location) Take a well identifier (e.g. A01) and returns an integer array representing the row and column of that well. Parameters: Name Type Description location string a well identifier starting with a capital letter and followed by a number (e.g. A01) Source: parsers/wellsParser.js, line 20 Returns: an integer array of [row, col]. The values are 1-based (i.e. row 1 is the first row) Type array &lt;static&gt; parse(text, objects [, config]) Parses a text which should represent one or more labwares and wells. If the objects parameter is passed, this function will return an array of the individual wells; otherwise it will return the raw parser results. Parameters: Name Type Argument Description text string text to parse objects object map of protocol objects, in order to find labwares and number of rows and columns on labware. config object &lt;optional&gt; optional object that contains properties for 'rows' and 'columns', in case we want to expand something like 'A1 down C3' without having specified a plate Source: parsers/wellsParser.js, line 51 Returns: If the objects parameter is passed, this function will return an array of the individual wells; otherwise it will return the raw parser results. Type array &lt;static&gt; parseOne(text) Parses a string which should represent a single well, and return the raw parser results. Parameters: Name Type Description text string text to parse Source: parsers/wellsParser.js, line 345 Returns: an object representing the raw parser results. Type object &lt;inner&gt; processParserResult(result, objects, text [, config]) Take the raw parser results and return an array of location names, one entry for each well. Parameters: Name Type Argument Description result array raw parser results. objects object map of protocol objects, in order to find labwares and number of rows and columns on labware. text string the original text that was parsed; this is merely used for error output. config object &lt;optional&gt; optional object that contains properties for 'rows' and 'columns', in case we want to expand something like 'A1 down C3' without having specified a plate Source: parsers/wellsParser.js, line 74 Returns: array of names for each plate + well (e.g. plate1(C04)) Type array × Search results Close "},"module-roboliq.html":{"id":"module-roboliq.html","title":"Module: roboliq","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: roboliq Roboliq's top module with functions for processing protocols. Source: roboliq.js, line 7 Methods &lt;inner&gt; _run(opts [, userProtocol]) Process the protocol(s) given by the command line options and an optional userProtocol passed in separately to the API (currently this is just for testing). Parameters: Name Type Argument Description opts object command line arguments as processed by nomnom. userProtocol Protocol &lt;optional&gt; an optional protocol that can be directly passed into the function rather than supplied via argv; currently this is only for testing purposes. Source: roboliq.js, line 886 Returns: Processing results with properties output (the final processed protocol) and protocol (same as output, but without tables). Type object &lt;inner&gt; createStateItems(name, o, stateList) This function recurively iterates through all objects, and for each object whose type has an entry in protocol.objectToPredicateConverters, it generates the logical predicates and appends them to stateList. Mutates stateList. Parameters: Name Type Description name string name of current object o object current object stateList array array of logical predicates Source: roboliq.js, line 1170 &lt;inner&gt; expandProtocol(The) Expand the protocol's steps. This means that commands are passed to command handlers to possibly be expanded to lower-level sub-commands. Mutates protocol. Parameters: Name Type Description The Protocol protocol. Source: roboliq.js, line 1204 Returns: The final state of objects. Type object &lt;inner&gt; expandStep(protocol, prefix, step, objects) Expand the given step by passing a command to its command handler and recursively expanding sub-steps. Mutates protocol. However, since protocol.objects should still hold the initial objects after processing, rather than mutating protocol.objects during processing, a separate objects variable is mutated, which starts out as a deep copy of protocol.objects. Parameters: Name Type Description protocol Protocol the protocol prefix array array of string representing the current step ID (initially []). step object the current step (initially protocol.steps). objects object a mutable copy of the protocol's objects. Source: roboliq.js, line 1231 &lt;inner&gt; loadProtocol(a, b [, url]) Finishing loading/processing an unprocessed protocol: handle imports, directives, and file nodes Parameters: Name Type Argument Description a Object Previously loaded protocol data b Object The protocol to pre-process url String &lt;optional&gt; The url of the protocol Source: roboliq.js, line 228 Returns: protocol with Type Object &lt;inner&gt; loadUrlContent(url, filecache) Loads the raw content at the given URL. Supported formats are: JSON, YAML, JavaScript, and pre-cached file data. Parameters: Name Type Description url string URL to load. filecache object map of cached file data, map from URL to data. Source: roboliq.js, line 198 Returns: content at URL. &lt;inner&gt; mergeProtocolList(protocols) Merge a list of protocols. Parameters: Name Type Description protocols array list of protocols. Source: roboliq.js, line 499 Returns: merged protocol. Type Protocol &lt;inner&gt; mergeProtocols(a, b) Merge protocols A &amp; B, returning a new protocol. Parameters: Name Type Description a Object protocol representing the result of all previous mergeProtocols b Object newly loaded protocol to merge into previous protocols Source: roboliq.js, line 479 Returns: result of merging protocol B into A. Type Object &lt;inner&gt; postProcessProtocol(protocol) Post-process protocol: flatten predicate list, parse wells strings for Liquid objects. Mutates the passed protocol. Parameters: Name Type Description protocol Object A protocol. Source: roboliq.js, line 514 &lt;inner&gt; postProcessProtocol_variables(protocol) For all variables that have a calculate property, handle the calculation and put the result in the value property. For 'Data' objects: if it doesn't have a value, call Design.flattenDesign; if its value is a filename, load the file into the value Mutates protocol. Parameters: Name Type Description protocol Protocol The protocol to inspect. Source: roboliq.js, line 560 &lt;inner&gt; preProcessExclamationMarks(protocol, obj, path) Any properties that have a &quot;!&quot; suffix are renamed to not have that suffix, overwritting an already existing property if necessary. Mutates the object. Parameters: Name Type Description protocol Protocol obj any path array Source: roboliq.js, line 438 &lt;inner&gt; preProcessQuestionMarks(protocol, obj, path) Remove properties with '?'-suffix. If the propery value has a 'value!' property, add a new property to the object without the '?'-suffix and with the given value. Mutates the object. Also add the path to the property to the protocol's fillIns Parameters: Name Type Description protocol Protocol obj any path array Source: roboliq.js, line 391 &lt;inner&gt; runWithOpts(argv [, userProtocol]) Process a roboliq protocol. Parameters: Name Type Argument Description argv array command line options. userProtocol Protocol &lt;optional&gt; an optional protocol that can be directly passed into the function rather than supplied via argv; currently this is only for testing purposes. Source: roboliq.js, line 690 Returns: Processing results with properties output (the final processed protocol) and protocol (the result of merging all input protocols). Type object &lt;inner&gt; validateProtocol1(protocol) Perorms a schema check, makes sure that all objects are valid. Throws an error if the protocol isn't valid. Parameters: Name Type Description protocol Protocol The protocol to validate. Source: roboliq.js, line 617 Type Definitions CommandHandlerResult Command handler result. Type: Object Properties: Name Type Description errors Array array of error strings warnings Array array of warning strings expansion Object | Array an array or map of sub-steps effects Object a map of object property effects alternatives Object ??? Source: roboliq.js, line 28 Protocol Protocol specification. Type: Object Properties: Name Type Description objects Object steps Object effects Object predicates Array directiveHandlers Object objectToPredicateConverters Object commandHandlers Object planHandlers Object files Object errors Object warnings Object Source: roboliq.js, line 12 WellContents Well contents. Well contents are encoded as an array. The first element always holds the volume in the well. If the array has exactly one element, the volume should be 0l. If the array has exactly two elements, the second element is the name of the substance. If the array has more than two elements, each element after the volume has the same structure as the top array and they represent the mixture originally dispensed in the well. objects: plate1: contents: A01: [&quot;30ul&quot;, [&quot;25ul&quot;, &quot;water&quot;], [&quot;5ul&quot;, &quot;reagent1&quot;]] Type: array Source: roboliq.js, line 39 × Search results Close "},"module-stanModel.html":{"id":"module-stanModel.html","title":"Module: stanModel","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: stanModel Function to generate an MCMC model for use with Stan. Source: stanModel.js, line 7 Methods &lt;inner&gt; addCentralizedParameter_mean(name, withLoc, n, nScales [, nName], limits) Add variables for a centralized mean Parameters: Name Type Argument Description name string name of variable withLoc boolean whether to include a location data variable n integer array size, or 1 for a scalar nScales integer number of scale parameters; 1 = same scale for each item in array; n = one scale parameter for each item. nName string &lt;optional&gt; optional name for array size (to be used in place of n in some places) limits string a limits modifier (&quot;&quot; if no limits) Source: stanModel.js, line 713 &lt;inner&gt; addLiquid(model, k, spec) Add a liquid to the model. Parameters: Name Type Description model object the model k string liquid name spec object concentration specification Properties Name Type Argument Default Description type string &lt;optional&gt; &quot;fixed&quot; set to &quot;fixed&quot; for a concentration, &quot;normal&quot; for a normally distributed concentration. If set to &quot;normal&quot;, you will need to supply the &quot;loc&quot; and &quot;scale&quot; values as input data when running Stan. value number &lt;optional&gt; 0 if fixed, this is the fixed concentration - otherwise the parameters will be estimated. Source: stanModel.js, line 118 &lt;inner&gt; aspirate(model, args) Add an aspiration operation to the model. Parameters: Name Type Description model object the model args object Properties Name Type Description p string the name of the pipetting parameters t number | string the tip identifier d number volume in microliters well string the well name Source: stanModel.js, line 319 &lt;inner&gt; assignLiquid(model, well, k) Assign a liquid to a well in the model. Parameters: Name Type Description model object the model well string the well name k string the liquid name Source: stanModel.js, line 303 &lt;inner&gt; createEmptyModel(subclassNodes, betaDs, gammaDs) Create the initial empty model. You will add pipetting and measurement actions will be added to. Parameters: Name Type Description subclassNodes Array.&lt;number&gt; sorted volumes after which a subclass starts (e.g. for subclasses 3-15,15.01-500,500.01-1000, subclassNodes = [3,15,500,1000]) betaDs Array.&lt;number&gt; volumes for which we want a beta parameter (dispense bias) gammaDs Array.&lt;number&gt; volumes for which we want a gamma parameter (unintended dilution) Source: stanModel.js, line 60 Returns: an object with mostly empty properties representing the model's random variables and labware. Type object &lt;inner&gt; dispense(model, args) Add a dispense operation to the model. Parameters: Name Type Description model object the model args object Properties Name Type Description p string the name of the pipetting parameters t number | string the tip identifier d number volume in microliters well string the well name Source: stanModel.js, line 442 &lt;inner&gt; measureAbsorbance(model, wells) Add an absorbance measurement to the model. Parameters: Name Type Description model object the model wells Array.&lt;string&gt; the names of the measured wells Source: stanModel.js, line 216 &lt;inner&gt; measureWeight(model, l) Add a weight measurement to the model. Parameters: Name Type Description model object the model l string the labware name Source: stanModel.js, line 265 &lt;inner&gt; printModel(model [, basename]) Print the Stan model to stdout, and save a basename.R file that holds indexes to associate the random variables back to labware. Parameters: Name Type Argument Default Description model string the model basename string &lt;optional&gt; &quot;stanModel&quot; the basename for the R output Source: stanModel.js, line 505 × Search results Close "},"module-WellContents.html":{"id":"module-WellContents.html","title":"Module: WellContents","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Module: WellContents A module of functions for querying and manipulating well contents. Source: WellContents.js, line 7 Methods &lt;static&gt; checkContents(contents) Validate well contents. Throws an error if they aren't valid. Parameters: Name Type Description contents array The well contents. Source: WellContents.js, line 27 &lt;static&gt; flattenContents(contents) Convert the contents array encoding to a map of substances to amounts Parameters: Name Type Description contents array The well contents array Source: WellContents.js, line 209 Returns: map of substance name to the volume or amount of that substance in the well Type object &lt;static&gt; getContentsAndName(wellName, data, effects) Get an object representing the effects of pipetting. Parameters: Name Type Description wellName string fully qualified object name of the well data object The data object passed to command handlers. effects object The effects object for effects which have taken place during the command handler and aren't in the data object Source: WellContents.js, line 165 Returns: [content, contentName], where content will be null if not found Type array &lt;static&gt; getVolume(contents) Get the volume of the contents array. Parameters: Name Type Description contents array The well contents array Source: WellContents.js, line 120 Returns: the mathjs volume if found, otherwise 0ul Type object &lt;static&gt; getWellContents(wellName, data, effects) Tries to find the contents array for the given well. Parameters: Name Type Description wellName string name of the well data object the data object passed to command handlers effects object an optional effects object for effects which have taken place during the command handler and aren't in the data object Source: WellContents.js, line 89 Returns: the contents array if found, otherwise null Type WellContents &lt;static&gt; getWellVolume(wellName, data, effects) Get the volume of the given well. Parameters: Name Type Description wellName string name of the well data object the data object passed to command handlers effects object an optional effects object for effects which have taken place during the command handler and aren't in the data object Source: WellContents.js, line 149 Returns: the mathjs volume if found, otherwise 0ul Type object &lt;static&gt; isEmpty(contents) Check whether the contents are empty. They are empty if the contents are undefined, an empty array, or the array begins with a number that mathjs considers equal to 0. Parameters: Name Type Description contents WellContents Source: WellContents.js, line 137 Returns: true if the contents are empty Type Boolean &lt;static&gt; transferContents(srcContents, dstContents, volume) Add source contents to destination contents at the given volume. Parameters: Name Type Description srcContents array current contents of the source well dstContents array current contents of the destination well volume string a string representing the volume to transfer Source: WellContents.js, line 292 Returns: an array whose first element is the new source contents and whose second element is the new destination contents. Type array × Search results Close "},"pipetter.html":{"id":"pipetter.html","title":"Namespace: pipetter","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Namespace: pipetter pipetter Namespace for the pipetter commands. Version: v1 Source: commands/pipetter.js, line 7 × Search results Close "},"timer.html":{"id":"timer.html","title":"Namespace: timer","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Namespace: timer timer Namespace for the timer commands. Version: v1 Source: commands/timer.js, line 7 Type Definitions _sleep Sleep for a given duration using a specific timer. Handler should return effects that the timer is not running. Properties: Name Type Description command string &quot;timer._sleep&quot; agent string Agent identifier equipment string Equipment identifier duration number Number of seconds to sleep Source: commands/timer.js, line 82 _start Start the given timer. Handler should return effects that the timer is running. Properties: Name Type Description command string &quot;timer._start&quot; agent string Agent identifier equipment string Equipment identifier Source: commands/timer.js, line 102 _stop Stop the given timer. Handler should return effects that the timer is not running. Properties: Name Type Description command string &quot;timer._stop&quot; agent string Agent identifier equipment string Equipment identifier Source: commands/timer.js, line 120 _wait Wait until the given timer has reacher the given elapsed time. Handler should: expect that the timer (identified by the equipment parameter) is running return effects that the timer is not running Properties: Name Type Description command string &quot;timer._wait&quot; agent string Agent identifier equipment string Equipment identifier till number Number of seconds to wait till from the time the timer was started stop boolean Whether to stop the timer after waiting, or let it continue Source: commands/timer.js, line 138 doAndWait A control construct to perform the given sub-steps and then wait until a certain amount of time has elapsed since the beginning of this command. Properties: Name Type Argument Description command string &quot;timer.doAndWait&quot; agent string &lt;optional&gt; Agent identifier equipment string &lt;optional&gt; Equipment identifier duration number Number of seconds this command should last steps Array | Object Sub-steps to perform Source: commands/timer.js, line 162 sleep Sleep for a given duration. Properties: Name Type Argument Description command string &quot;timer.sleep&quot; agent string &lt;optional&gt; Agent identifier equipment string &lt;optional&gt; Equipment identifier duration number Number of seconds to sleep Source: commands/timer.js, line 202 start Start a timer. Properties: Name Type Argument Description command string &quot;timer.start&quot; agent string &lt;optional&gt; Agent identifier equipment string &lt;optional&gt; Equipment identifier Source: commands/timer.js, line 238 stop Stop a running timer. Properties: Name Type Argument Description command string &quot;timer.stop&quot; agent string &lt;optional&gt; Agent identifier equipment string &lt;optional&gt; Equipment identifier Source: commands/timer.js, line 273 × Search results Close "},"transporter.html":{"id":"transporter.html","title":"Namespace: transporter","body":" roboliq-processor Namespaces equipmentfluorescenceReaderpipettertimertransporter Modules commandHelpercommands/absorbanceReadercommands/centrifugecommands/equipmentcommands/fluorescenceReadercommands/incubatorcommands/pipettercommands/pipetter/groupingMethodscommands/pipetter/pipetterUtilscommands/pipetter/sourceMethodscommands/simulatedHelperscommands/timercommands/transporterconfig/roboliqconfig/roboliqDirectiveHandlersdesigngenerateSchemaDocsmiscparsers/wellsParserroboliqstanModelWellContents Global _roboliqSchemas Namespace: transporter transporter Namespace for the transporter commands. Version: v1 Source: commands/transporter.js, line 7 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
