http://stackoverflow.com/questions/3900307/cleaner-way-to-update-nested-structures

Big goals:
	Weizmann: first fully functional translation of example evolab script
	BSSE: program working script for CompleteYeastTransformation.esc
	Weizmann: get all basic example scripts working
	Weizmann: get commands in ALL_COMMANDS.conf working
	Evoware: connect to Evoware's API to control operation

Evoware commands:
x	asperate
x	dispense
x	wash
x	mix
	wait
	shake
	transfer
	trash
Evoware peripheral commands:
	seal
	peel
	pcr
	filter
	centrifuge
	...
Roboliq commands:
x	pipette liquid
x	clean
	pipette(List[SrcDestVolume])
	copy plate
	mix
	wait
	shake
	transfer
	PCR
	filter/centrifuge
	plate (put drops on a larger plate)
Evoware interaction:
	load evoware configuration
4b	create program to monitor overall script progress
4c	send scripts to evoware
4d	recognize when evoware script is done
4e	run some command when evoware script is done
4f	T2_Wait: continue script after specified wait
	T2_
	get data from evoware and peripherals
	user interaction (such as when doing a PCR and don't have a connected PCR machine)
User interface:
	Show user which decisions need/can be made
	Let user specify stuff
Get documentation from Tecan:
	carrier.cfg
	evoware.opt
	evoware.inf
		how can we tell whether the tips are fixed or disposable?
	*.esc: table layout format
Tuval/Yair:
	configuration files for their robots
	send them my code
	send them list of implemented RoboEase commands
	get date for coming to Weizmann
	ask for PCR protocols
Code:
	always wash/decon right after pipetting is done in order to prevent drying
	evoware: if the next command is not a pipetting command, move the LiHa back home
	evoware: if the next command is not a RoMa command, move the RoMa back home
	Example05: need to mix reagents
	pipetting mix command: efficient use of multiple sources going to one destination
	figure out how to compile external scripts conveniently (http://www.familie-kneissl.org/Members/martin/blog/reflection-from-scala-heaven-and-hell)
	allow for composition and chaining of protocols
	create a few interfaces: RobotModel (i.e. Evoware, Hamilton), Lab (has a RobotModel, a compiler, ...)
	create roboliq-C-weizmann and move relevant files from roboease-evoware there
	better organization of the objects needed for a given lab to compile commands or roboease:
		RoboliqSystem:
			devices
			processors
		EvowarePartModels should be loaded at startup
		Evoware table variables need to be created before customization
		EvowareTable needs to be created too, but not until translation
		EvowareSettings contains other info (e.g. wash programs) required for translation
		EvowareSystem contains all of the above, and:
			def createTranslator()
		BsseSystem:
			our devices, processors, models, table vars, table, settings, evoware translator
	compiler: make batching a part of processing L2 or L1 commands rather than performing the batching in L3
	protocol: let user create wells, not just plates?
	protocol: let user work with well groups; this is more general than wells and plates?
	protocol: let user specify specific wells on a plate?
	evoware: create EvowareCompiler.compile()
	evoware: move to roboliq.robots.evoware package
	evoware: replace Site with SiteObj (but rename SiteObj to Site)
	bsse: move to robloiq.labs.bsse package
*	devices: final wash in Pipette isn't happening because the tip states are set as clean, for some reason
*	devices: Example02: why are 1000ul being aspirated?
4	devices: implement transfer
		create means for user to capture plate location in the protocol and then use that position as an argument later (like to return a plate to an original position)
5	devices: implement wait
6	devices: implement shaker
7	devices: Pipette/Mix: add L4 option to first move the target plates to new locations, in case they cannot be accessed in their current locations
		add function to device for determining whether a given location can be accessed by the device
		add function to device for determining whether a given plate can be used by the device, and if not, which plate to transfer the contents to
		also, in plate setup, if plate's type hasn't been fixed yet, indicate which plate types are compatible with this device
	devices: replace PipetteDevice.areTipsDisposable with a flag in TipConfig?
	devices: PipetteDevice: return error message when we can't return a PipettePolicy
	devices: add bTipPermanent to Tip or TipConfig
	devices: PipettePolicy: rework this concept
		I don't really like the fact that we need to choose the Evoware liquid class in the L3 processor already...
		-- is there a good way to delay this to the EvowareTranslator?
		-- the problem is that we already need to know in L3 whether the tips will contact the destination liquid.
		PipettePolicy will also need to know the tip type; then EvowareMapper can decide on it's liquid class based on the parameters of PipettePolicy
*	devices: L3P_Wash: use extra wash volume
	devices: L3P_Pipette: drop tip after last use instead of waiting until end of pipetting
	devices: L3P_Pipette: don't match tips to dests at the beginning: delay the pairing until tip state is known in order to prefer tips with less volume
		From our translation of Rotem_Script01.conf:
		Aspirate(127,"PIE_AUT","900","900","600","300","300","300","300",0,0,0,0,0,41,2,1,"0608¯000000",0,0);
		Dispense(7,"PIE_AUTAIR","300","300","300",0,0,0,0,0,0,0,0,0,29,1,1,"0C080000 000000000",0,0);
		Dispense(3,"PIE_AUTAIR","300","300",0,0,0,0,0,0,0,0,0,0,29,2,1,"0C080000000000000",0,0);
		Dispense(127,"PIE_AUTAIR","300","300","300","300","300","300","300",0,0,0,0,0,29,2,1,"0C0800000000¯00000",0,0);
	devices: L3P_Pipette:
		From Rotem_Script03.conf: DIST_REAGENT2 DDW P14:A1+33 OLIGO_DDW_LIST DEFAULT TIPTYPE:1000,TIPMODE:KEEPTIP
		becomes:
		L3C_Pipette(BUF12:A1+8, Rotem_RGT2:A1+33, List(396.0, 1536.46, 1536.46, 397.5, 397.5, 397.5, 397.5, 397.5, 1683.0, 1049.4, 415.8, 1049.4, 
		396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0, 396.0))
		and this following translation is of interest: 
		L2C_Aspirate(Tip1-2, ArrayBuffer(758.0, 124.40000000000009), PIE_TROUGH_AUTAIR, BUF12:E1+2)
		L2C_Aspirate(Tip4, 124.40000000000009, PIE_TROUGH_AUTAIR, BUF12:E1)
		L2C_Dispense(Tip1-2,4, ArrayBuffer(758.0, 124.40000000000009, 124.40000000000009), PIE_TROUGH_AUTAIR, Rotem_RGT2:A2+2,D2)
		the aspirate could have been performed in a single step
	devices: create tests for PipetteHelperL3
	translator: need to split scripts into multiple files when plate is moved
	translator: improvement of above would be to only split scripts when a labware conflict would occur
	roboease: test liquid class, tip options, mix options
	roboease: create PipetteDevice subclass for Weizmann roboease scripts
*	roboease: PROMPT
	roboease: TRANSFER
.	roboease: TABLE
	roboease: add comments about tip usage to output
	roboease: somehow add default liquid class to a liquid (for example, add a Map[Liquid, String] to WeizmannPipetteDevice)
	roboease-evoware: pipette: default tip policy of always discarding
	roboease-evoware: print out appropriate header
	roboease translation errors:
		Rotem_Script03.conf: need to be able to pipette volumes which are larger than tips used
	roboease: try using parboiled as a replacement for scala's parser combinator (https://github.com/sirthias/parboiled/wiki)
	BsseRobot.batch*spirate() needs to batch on volume too?
	each token has a source reference so that we can ultimately find the line/col of sourcecode which a particular token came from
	KnowledgeBase:
		need to rework this concept
		we have several sources of knowledge:
			knowledge about objects specified in the protocol
			knowledge supplied by the user's customization of the protocol
			knowledge provided by protocol commands
			additional routines to find good defaults where possible
		should create an immutable KnowledgeMap in order to preserve a clear order in which the above sources are evaluated
		the first two should be fixed before evaluating the protocol commands
		we could then run multiple loops over the commands as long as they are still adding knowledge
	Tables:
		load in the evoware table; it should create roboliq objects for locations, PlateModels, plates
	Plates:
		we have various plate models
		we might need to have separate model objects for the roboliq and evoware layers
		we would like to choose the appropriate plate model for new plates we use, but also let the user specify it
		plate compatibilities should be specified for input plates
		plate compatibilities refers to which devices it can be used with, and how
		Plate
		PlateModelId
		PlateModel
		EvowarePlateModel extends PlateFamily
	Device and compilation concepts:
		Compiler
		CommandCompiler
		Device
		DeviceState
		DeviceKnowledge
		RobotState
		RobotKnowledge
		CompilerContext

		The compiler is given CompileHandlers which handle compilation of commands

		RobotState:
			RobotState contains a map of Device -> DeviceState

		RobotKnowledge:

		Objects:
			Obj -- simple placeholder
			ObjConfigL3 -- mutable configuration data for an object
			ObjStateL3 -- state data about an object on the L3 level of abstraction
			ObjConfigL1 -- immutable L1 data about an object
			ObjStateL1 -- variables which may change over time
		Devices:
			Device
			DeviceStateL3
			DeviceStateL1
		
		When compiling a command, we may need the following context information:
			Compiler (if we need to compile additional commands and score the results)
			Devices
			DeviceStates/DeviceKnowledge
			locations of parts

		Construction of Compiler object:
			create devices we want
			create RobotState object
			add initial device states for all devices to RobotState
			--
			create CommandCompilers
			create Compiler
			register CommandCompilers with Compiler
			--
			create initial device knowledge for all devices

	Knowledge Base:
		parts carry almost no data (at most a string label and a numeric id)
		two forms of data:
			partially specified
			fully specified
		the data object for a given part is created by a factory function in order to allow the user to add new parts; or alternatively, handlers can be registered
		the conversion from partially specified info to fully specified is also taken care of by the handlers
	Compiling 2011-08-23:
		L4 preprocessing: Knowledgebase
			purpose: fill in unknown parameter values
		L4 -> L3: Obj, RobotState
			purpose: translate from unfixed to fixed commands
		L3 -> L2: ObjConfig, RobotState, compile
			purpose: break down into simpler commands
		L2 -> L1: ObjConfig, RobotState
			purpose: update state and create state-ignorant commands
		L1 -> L0: ObjConfig

		L4/L3: same commands, except L4 uses Obj parameters, and L3 uses ObjConfig parameters
		L3: high-level commands (with all parameters)
		L2: commands which update state; these could also be the commands that are used for scoring
		L2/L1: same commands, except that all useful state information is added to the L1 command
		L1: commands used for native translation (do not rely on state)
	Compiling:
		L3 -> L2: knowledgebase
		L2 -> L1: initial robot state
		L1 -> L0: nothing?
		given a set of L3 commands:
			find new defaults to add to kb
			concretize existing kb
			add knowledge from all nodes in tree
			for each command in top list
				compile
				abort on error
				otherwise add knowledge from all new nodes
				process each translated item in the same way
			if knowledge has been updated
				repeat process
		CompileNode
			cmd
			result
			children
	Alternative compiling levels:
		NEED TO SPLIT CONFIG AND STATE FOR OBJSETUP AGAIN IN ORDER TO KEEP TRACK OF STATE IN HIGHER LEVEL COMMANDS?  Maybe not, since commands which need state could possibly delay translation until L1 state is available...?
		compilation cycles:
			each compilation run produces a linear list of commands rather than a tree
			L3 command can either replace itself with a list of other L3 commands or translate L2 commands
				NOTE: this might be too restrictive.  How about letting L2 commands translate to a list of both L2 and L1 commands?
			steps:
				optionally replace L3 commands with other L3 commands
				add knowledge from L3 commands
				abort if knowledge is not complete
				translate each L3 command to L2 commands (use ObjConfig parameters instead of Obj) then to L1 commands, abort on first error
				
		processor hierarchy:
			challenges:
				I'd like to be able to compile the commands in a preliminary way without a specific robot implementation
				this might mean that we need two types of state objects: ObjState and RobotState
				we also want to run through a protocol to see how much liquid is aspirated from a source well in order to know what the initial volume
				this means that we need two runs, and only the second run produces errors when well volume goes below 0
				we could pass ObjState params instead of ObjConfig, but then we'd need to compile every command before adding a new one
	Pipetting:
		state should only be updated by the underlying robot/device implementation based on L1 commands
		createCycles can try dispensing until an invalid state is reached, then revert to the previous state and start the next cycle
		cycles:
			start with assumption that tips are clean
			get first tip/dest set and associate source liquid with tip
			get pipetting policy and liquid class for each dispense
			create L1 dispense command
			update tip liquid attributes for it's post-dispense state
			add volume dispensed to amount required for tip
			peek at next tip/dest set, and check whether:
				each tip can still access the same set of source wells
				each tip can accommodate the additional volume
				dispense does not require cleaning
	Pipetting, new algorithm:
		create list of dispenses and mixes to perform
		prepend Placeholder to list

		get list of all tips used in dispenses
		if tips are disposable:
			get new tips, unless tipOverride says not to
		else
			wash all used tips with intensity Thorough, unless overridden


		for each dispense/mix:
			push state
			update state

			bPreDispenseClean = ...
			bTipsFull = if tips don't have enough space to accommodate additional aspirate
			bPreAspirateClean = ...
			check whether aspirate is required:
				either there 
	tip handling in Wash vs Dispose:
		fixed tips:
			do nothing, rinse, thorough wash, decontaminate, decontaminate with pre-rinse
		disposable tips:
			do nothing, replace (drop tip, wash syringe, get new tip), drop only
	L3C_Aspirate:
		parameters:
			tips, wells, volumes, policies
			clean degrees
			tip handling (tip type, action: none/new/force-replace)
		for disposable tips:
			if tip already present:
				if require different tip type || action == force-replace, force replacement
			else force-replacement
	Tip handling overrides:
		tip replacement action for each clean point
		tip wash action for each clean point
	Tip wash actions:
		cell | dna | other
		contamination levels: none, minor, major
		what about distinction between inside and outside?
		how to define a liquid so that we know what default tip handling actions to take for both disposable and permanent tips?
		contamination should be a map over an enumeration value so that additional contamination types can be easily added
	Wash programs:
		Later in development, I'd like for wash programs to target specific contaminants
		One challenge then would be how to keep new contaminants in sync with existing wash programs
		Maybe by having new contaminants subclass existing ones when appropriate

		decide on wash program based on the desired wash intensity and the contamination of the tips

		L3: must be implemented for a specific lab -- though I'd like to have a generic implementation based on our BSSE setup
		L2: same as for L1
		L1: wash program refers to a set of parameters for Evoware WASH
	Tip handling defaults:
	Clean:
		Clean overrides:
			//before first aspirate
			before each aspirate
			//before each aspirate of a new liquid
			//between dispenses
			after wet-contact dispense
			after last dispense

		Tip handling:
			none
			get new (drop if necessary,wash,get) [need type to get]
			drop only

		Clean & Tip handling:
			

		cleaning is flagged when tip enters the destination liquid
		cleaning is flagged when the tip will aspirate from a new liquid
		cleanBetween is normally CleanDegree.Rinse
		it will be CleanDegree.Decontaminate, however, if either the source or dest liquids require decontamination
		user can optionally override the cleanDegree

		distinguish between 1) clean if dirty and 2) forced preparatory clean
		only clean the tips we'll need
		the pre-clean instruction at the beginning of a pipetting action should clean all tips which will be used during the procedure
		the between-clean instruction should clean all tips which were previously used
		optimize clean instructions so that cleaning of a tip kind also cleans the tips of any clean instructions for that tip kind which come later, but only for clean instruction of the same degree
		optimize clean instructions which are right next to each other so that only one of them is performed
		At the T1 level: tips and degree should already be specified, meaning we need to get the degree information from the BsseRobot
	Pipetting policies:
		prefix:
			Roboliq
		naming for dispense position:
			Air - free dispense
			Top - dispense near top surface of liquid
			Mid?? dispense below top of liquid
			Bot?? dispense near bottom of well
			Dry - dispense at bottom of dry well
			Mix?? for mixing
		speeds:
			Fast
			Slow
			Norm
		example names:
			Roboliq_Cells_Air_1000
			Roboliq_Water_Air_1000
			Roboliq_Water_Air_0050
			Roboliq_Water_Dry_1000
			Roboliq_Water_Dry_0050
			Roboliq_Water_Wet_1000
			Roboliq_Water_Wet_0050
			Roboliq_DMSO_Air_1000
			Roboliq_Decon_???
			+ glycerol 1000 and 50 (oil can also be pipetted with this class)
		classes for how to do cleaning:
			always decontaminate before aspirate
			tip must be clean of extraneous liquids before dispense
			normally, whenever an extraneous contaminant is on the tip, we should decontaminate before entering another well;
				but, we could have something like a ContaminantGroupId which allows for a lesser form of cleaning

	T0 tokens can have estimated times associated with them
	
	Devices which deal with plates:
		common atomic commands for external devices: open, close, run, start
		check for plate compatibility; if replating is required, the user must specify this in the setup somehow
		for higher-level commands, device should take multiple plates and can either process them sequentially or simultaneously


x	DOC
x	#
	TABLE
	OPTION
x	=
x	LIST
x	REAGENT
.	LABWARE
x	TRANSFER_LOCATIONS
 *	TRANSFER_SAMPLES
 *	TRANSFER_WELLS
 *	DIST_REAGENT
x	DIST_REAGENT2
	UNITE_AND_TRANSFER
	RUN
	LOOP
	ENDLOOP
 *	DIST_WELL
	PREPARE_MIX
	PREPARE_LIST
	MPDIST
	MPCHECKER
	MPREPLICATE
	MPREPLICATE384
	DILUTE_AND_REPLICATE384
	DILPROG
	PREPARE_MATRIX
 *	DIST_COL2ROW
	EQUAL_CONC
	SERIAL_DILUTION
	PLANNED_DILUTION
	ELUTE_SAMPLES
	SEQ_PURE
	ADD_AND_TRANSFER
	PCR_PURE
	MP_MINIPREP
	PG_PREPARE_STD
	PG_PREPARE_SAMPLE
	PLATE_TO_PCR
	PCR_SCHEDULE
	VACUUM
	VACUUM_ON
	VACUUM_OFF
x	MIX_WELLS
	WAIT
	PROMPT
 *	GET_TIPS
 *	DROP_TIPS
	ROCHE_OPEN
	ROCHE_CLOSE
	ROCHE_RUN
	RUN_PCR
	PCR_RUN
	PCR_OPEN
	PCR_CLOSE
	PCR_COVER
	PCR_UNCOVER
	RUN_PCR_OPEN
	PCR_RUN_OPEN
	PR_OPEN
	PR_CLOSE
	PR_WAIT
	PR_RUN
	PR_MEASURE
	REMOTE
 *	EXECUTE
	READER_OPEN
	READER_CLOSE
	READER_MEASURE_OD
	READER_MEASURE_GFP
	READER_MEASURE
	READER_SET_TEMP
	INC_CLOSE
	INC_STOP
	INC_SHAKE
	INC_TEMP
	LINKER_POS
	START_SCRIPT
 *	EVOSUB
	CSLGET
	CSLPUT
	CSLLOOP
	CFGRUN
	TRANSFER_OBJECT
	SMS
 	SHAKER_START
 *	SHAKE
	SHAKER_STOP
	MOVE_OBJECT
	START_TIMER
	WAIT_TIMER
 *	MOVE_PLATE
 *	EMAIL
 *	SMS
	LOGMIX
	LOGLIST
	LOGPLATE
	CEPLATE
	BIOPLATE
	MULTINAPLATE
	RCHPLATE
	SEQPLATE
	%

Questions for Weizmann:
	What happens with the % (ChecklistComment) commands?

