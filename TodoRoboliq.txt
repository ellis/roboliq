http://stackoverflow.com/questions/3900307/cleaner-way-to-update-nested-structures

Evoware commands:
x	asperate
x	dispense
1a?	wash
3a	mix
4a	wait
5a	shake
	transfer
	trash
Evoware peripheral commands:
	seal
	peel
	pcr
	filter
	centrifuge
	...
T1 commands:
x	aspirate
x	dispense
1b?	clean
3b?	mix
4b	wait
5b	shake
	transfer
T2 commands:
1c?	pipette liquid
	clean
2a?	pipette(List[SrcDestVolume])
2b?	copy plate
3c?	mix
4c	wait
5c	shake
	transfer
	PCR
	filter/centrifuge
	plate (put drops on a larger plate)
T3 commands:
	pipette liquid (this is like T2, but allows for unset values, and doesn't continue to T1 until all values have been set)
	...
RoboEase commands:
	start implementing these to see what problems I run into
2c	copy plate
Evoware interaction:
	load evoware configuration
4b	create program to monitor overall script progress
4c	send scripts to evoware
4d	recognize when evoware script is done
4e	run some command when evoware script is done
4f	T2_Wait: continue script after specified wait
	T2_
	get data from evoware and peripherals
	user interaction (such as when doing a PCR and don't have a connected PCR machine)
User interface:
	Show user which decisions need/can be made
	Let user specify stuff


Tuval/Yair:
	configuration files for their robots
	send them my code
	send them list of implemented RoboEase commands
	get date for coming to Weizmann
Code:
x	split devices project into commands and devices
x	L1C_Wash
x	L*C_Mix
x	L2C_Clean
	create evoware translator for existing L1 commands
	figure out how to clean BSSE tips
	figure out how to clean Weizmann tips
	roboease: accumulate commands and send them though the compiler
	roboease: LABWARE
	roboease: MIX
	roboease: TRANSFER
	create Syringe object and decouple it from the Tip object, so that tips can be exchanged
	Add Comment()s to evoware output
	roboease: try using parboiled as a replacement for scala's parser combinator (https://github.com/sirthias/parboiled/wiki)
	BsseRobot.batch*spirate() needs to batch on volume too?
	each token has a source reference so that we can ultimately find the line/col of sourcecode which a particular token came from
x	have robot decide on Aspiration/Dispense strategy for T1 tokens
x	each T2 token produces a sequence of T1 tokens
x	robot tells which tips can be used in batch for a particular token
x	setup unit tests for sbt
	Device and compilation concepts:
		Compiler
		CommandCompiler
		Device
		DeviceState
		DeviceKnowledge
		RobotState
		RobotKnowledge
		CompilerContext

		The compiler is given CompileHandlers which handle compilation of commands

		RobotState:
			RobotState contains a map of Device -> DeviceState

		RobotKnowledge:

		Objects:
			Obj -- simple placeholder
			ObjConfigL3 -- mutable configuration data for an object
			ObjStateL3 -- state data about an object on the L3 level of abstraction
			ObjConfigL1 -- immutable L1 data about an object
			ObjStateL1 -- variables which may change over time
		Devices:
			Device
			DeviceStateL3
			DeviceStateL1
		
		When compiling a command, we may need the following context information:
			Compiler (if we need to compile additional commands and score the results)
			Devices
			DeviceStates/DeviceKnowledge
			locations of parts

		Construction of Compiler object:
			create devices we want
			create RobotState object
			add initial device states for all devices to RobotState
			--
			create CommandCompilers
			create Compiler
			register CommandCompilers with Compiler
			--
			create initial device knowledge for all devices

	Knowledge Base:
		parts carry almost no data (at most a string label and a numeric id)
		two forms of data:
			partially specified
			fully specified
		the data object for a given part is created by a factory function in order to allow the user to add new parts; or alternatively, handlers can be registered
		the conversion from partially specified info to fully specified is also taken care of by the handlers
	Compiling:
		L3 -> L2: knowledgebase
		L2 -> L1: initial robot state
		L1 -> L0: nothing?
		given a set of L3 commands:
			find new defaults to add to kb
			concretize existing kb
			add knowledge from all nodes in tree
			for each command in top list
				compile
				abort on error
				otherwise add knowledge from all new nodes
				process each translated item in the same way
			if knowledge has been updated
				repeat process
		CompileNode
			cmd
			result
			children
	Alternative compiling levels:
		NEED TO SPLIT CONFIG AND STATE FOR OBJSETUP AGAIN IN ORDER TO KEEP TRACK OF STATE IN HIGHER LEVEL COMMANDS?  Maybe not, since commands which need state could possibly delay translation until L1 state is available...?
		compilation cycles:
			each compilation run produces a linear list of commands rather than a tree
			L3 command can either replace itself with a list of other L3 commands or translate L2 commands
				NOTE: this might be too restrictive.  How about letting L2 commands translate to a list of both L2 and L1 commands?
			steps:
				optionally replace L3 commands with other L3 commands
				add knowledge from L3 commands
				abort if knowledge is not complete
				translate each L3 command to L2 commands (use ObjConfig parameters instead of Obj) then to L1 commands, abort on first error
				
		processor hierarchy:
			Pa: add to knowledgebase
			Pa: concretize knowledgebase to create ObjConfig and ObjState0
			Ta: translate to commands taking ObjConfig params
				inp:
			Tb: use compiler object to choose among various possible translations (via scoring)
				inp+: compiler
			Tc: 
				inp-: compiler
			-
				goal: translate to new command params: ObjConfig
				inp-: kb
				inp+: ObjConfig, ObjState0
			-
				goal: 



			2:	inp: ObjConfig, RobotState
			1:	inp: ObjState
				mod: nothing
				out: native format
			L4P: 
				inp: kb, Obj, ObjSetup, ObjConfig, RobotState
				mod: kb, ObjSetup
				out: L3C with ObjConfig parameters
			L3P:
				inp: ObjConfig, RobotState
				mod: nothing
				out: L2C with ObjConfig parameters
			L2P:
				inp: ObjConfig, RobotState
				mod: RobotState
				out: L1C with ObjState parameters
			L1P:
				inp: ObjState
				mod: nothing
				out: native format
		command hierarchy:
			A: need only object references
			 : processed by L3 compiler
			B: need object configs
			 : processed by L2 compiler
			 : processed by L1 compiler
			C: need object states
				NOTE: interesting thought, but note that such commands are not in a position to update state
		compile with (incomplete) knowledgebase:
			L3: update knowledgebase and ObjSetup, output possible additional L3 commands and L3 state
		compile with config:
			L3: output Pending or L3/L2 translations
		compile with state:
			L3: output L3/L2 translations
		once knowledgebase is complete, translate to equivalent commands using ObjConfig parameters
	Pipetting:
		state should only be updated by the underlying robot/device implementation based on L1 commands
		createCycles can try dispensing until an invalid state is reached, then revert to the previous state and start the next cycle
		cycles:
			start with assumption that tips are clean
			get first tip/dest set and associate source liquid with tip
			get pipetting policy and liquid class for each dispense
			create L1 dispense command
			update tip liquid attributes for it's post-dispense state
			add volume dispensed to amount required for tip
			peek at next tip/dest set, and check whether:
				each tip can still access the same set of source wells
				each tip can accommodate the additional volume
				dispense does not require cleaning
	tip handling in Wash vs Dispose:
		fixed tips:
			do nothing, rinse, thorough wash, decontaminate, decontaminate with pre-rinse
		disposable tips:
			do nothing, replace (drop tip, wash syringe, get new tip)
	Clean:
		Clean overrides:
			before start
			before each aspirate
			before each aspirate of a new liquid
			between dispenses
			after having entered dest liquid
			after last dispense

		cleaning is flagged when tip enters the destination liquid
		cleaning is flagged when the tip will aspirate from a new liquid
		cleanBetween is normally CleanDegree.Rinse
		it will be CleanDegree.Decontaminate, however, if either the source or dest liquids require decontamination
		user can optionally override the cleanDegree

		distinguish between 1) clean if dirty and 2) forced preparatory clean
		only clean the tips we'll need
		the pre-clean instruction at the beginning of a pipetting action should clean all tips which will be used during the procedure
		the between-clean instruction should clean all tips which were previously used
		optimize clean instructions so that cleaning of a tip kind also cleans the tips of any clean instructions for that tip kind which come later, but only for clean instruction of the same degree
		optimize clean instructions which are right next to each other so that only one of them is performed
		At the T1 level: tips and degree should already be specified, meaning we need to get the degree information from the BsseRobot
	T0 tokens can have estimated times associated with them
TRANSFER_LOCATIONS
TRANSFER_SAMPLES
TRANSFER_WELLS
DIST_REAGENT
DIST_REAGENT2
UNITE_AND_TRANSFER
RUN
LOOP
ENDLOOP
DIST_WELL
PREPARE_MIX
PREPARE_LIST
MPDIST
MPCHECKER
MPREPLICATE
MPREPLICATE384
DILUTE_AND_REPLICATE384
DILPROG
PREPARE_MATRIX
DIST_COL2ROW
EQUAL_CONC
SERIAL_DILUTION
PLANNED_DILUTION
ELUTE_SAMPLES
SEQ_PURE
ADD_AND_TRANSFER
PCR_PURE
MP_MINIPREP
PG_PREPARE_STD
PG_PREPARE_SAMPLE
PLATE_TO_PCR
PCR_SCHEDULE
VACUUM
VACUUM_ON
VACUUM_OFF
MIX_WELLS
WAIT
PROMPT
GET_TIPS
DROP_TIPS
ROCHE_OPEN
ROCHE_CLOSE
ROCHE_RUN
RUN_PCR
PCR_RUN
PCR_OPEN
PCR_CLOSE
PCR_COVER
PCR_UNCOVER
RUN_PCR_OPEN
PCR_RUN_OPEN
PR_OPEN
PR_CLOSE
PR_WAIT
PR_RUN
PR_MEASURE
REMOTE
EXECUTE
READER_OPEN
READER_CLOSE
READER_MEASURE_OD
READER_MEASURE_GFP
READER_MEASURE
READER_SET_TEMP
INC_CLOSE
INC_STOP
INC_SHAKE
INC_TEMP
LINKER_POS
START_SCRIPT
EVOSUB
CSLGET
CSLPUT
CSLLOOP
CFGRUN
TRANSFER_OBJECT
SMS
SHAKER_START
SHAKE
SHAKER_STOP
MOVE_OBJECT
START_TIMER
WAIT_TIMER
MOVE_PLATE
EMAIL
SMS
LOGMIX
LOGLIST
LOGPLATE
CEPLATE
BIOPLATE
MULTINAPLATE
RCHPLATE
SEQPLATE
