http://stackoverflow.com/questions/3900307/cleaner-way-to-update-nested-structures

Evoware commands:
x	asperate
x	dispense
1a?	wash
3a	mix
4a	wait
5a	shake
	transfer
	trash
Evoware peripheral commands:
	seal
	peel
	pcr
	filter
	centrifuge
	...
T1 commands:
x	aspirate
x	dispense
1b?	clean
3b?	mix
4b	wait
5b	shake
	transfer
T2 commands:
1c?	pipette liquid
	clean
2a?	pipette(List[SrcDestVolume])
2b?	copy plate
3c?	mix
4c	wait
5c	shake
	transfer
	PCR
	filter/centrifuge
	plate (put drops on a larger plate)
T3 commands:
	pipette liquid (this is like T2, but allows for unset values, and doesn't continue to T1 until all values have been set)
	...
RoboEase commands:
	start implementing these to see what problems I run into
2c	copy plate
Evoware interaction:
	load evoware configuration
4b	create program to monitor overall script progress
4c	send scripts to evoware
4d	recognize when evoware script is done
4e	run some command when evoware script is done
4f	T2_Wait: continue script after specified wait
	T2_
	get data from evoware and peripherals
	user interaction (such as when doing a PCR and don't have a connected PCR machine)
User interface:
	Show user which decisions need/can be made
	Let user specify stuff


Tuval/Yair:
	configuration files for their robots
	send them my code
	send them list of implemented RoboEase commands
	get date for coming to Weizmann
Code:
x	split devices project into commands and devices
x	L1C_Wash
x	L*C_Mix
x	L2C_Clean
x	create evoware translator for existing L1 commands
x	figure out how to clean BSSE tips
	devices: add bTipPermanent to Tip or TipConfig
x	devices: add sTipType to TipState
.	devices: PipetteDevice: return aspirate/dispense volumes based on tip type
	devices: set initial tip state in BSSE pipette device
x	devices: set tip state in DROP and GET commands
x	devices: L*_GetTip/L*_DropTip
x	devices: L3P_Clean_Discardable for cleaning Weizmann tips
x	devices: L3P_Pipette: update to accommodate tip disposal
	devices: L3P_Pipette/L*_TipsGet: drop all used tips if we won't need then anymore, even if the next aspirate only uses some tips
	devices: L3P_Pipette: update to use Roboease TipPolicies and dispose tips when finished
	devices: set initial tip type in TipState for fixed tips
	devices: implement mixing option in L3P_Pipette
x	evoware: L*_GetTip/L*_DropTip
x	roboease: accumulate commands and send them though the compiler
x	roboease: LABWARE
x	roboease: MIX
	roboease: test liquid class, tip options, mix options
	roboease: create PipetteDevice subclass for Weizmann roboease scripts
	roboease: TRANSFER
	roboease: TABLE
	roboease: add comments about tip usage to output
	roboease: somehow add default liquid class to a liquid (for example, add a Map[Liquid, String] to WeizmannPipetteDevice)
x	roboease-evoware: create project
x	roboease-evoware: translate final commands to Evoware output
x	roboease-evoware: copy and update test program from roboease project
x	roboease-evoware: WeizmannPipetteDevice: use proper tip names, e.g. "DiTi 200ul"
x	roboease-evoware: Wash: why is wash volume always "0" in Mix section?
x	roboease-evoware: Wash: get other parameter values from evolab scripts
6	roboease-evoware: Wash: add an emulation mode in order to output same string as roboease
x	roboease-evoware: check whether 200ul tips automatically get chosen when pipetting 150ul in Rotem_Script01.esc
x	roboease-evoware: Mix: use liquid class from MIX_WELLS
x	roboease-evoware: Mix: second to last parameter should be 15 instead of 0?
7	roboease-evoware: pipette: default tip policy of always discarding
8	roboease-evoware: pipette: not dispensing to proper wells in Rotem_Script01.esc
	roboease-evoware: print out appropriate header
	roboease: try using parboiled as a replacement for scala's parser combinator (https://github.com/sirthias/parboiled/wiki)
	BsseRobot.batch*spirate() needs to batch on volume too?
	each token has a source reference so that we can ultimately find the line/col of sourcecode which a particular token came from
x	have robot decide on Aspiration/Dispense strategy for T1 tokens
x	each T2 token produces a sequence of T1 tokens
x	robot tells which tips can be used in batch for a particular token
x	setup unit tests for sbt
	Device and compilation concepts:
		Compiler
		CommandCompiler
		Device
		DeviceState
		DeviceKnowledge
		RobotState
		RobotKnowledge
		CompilerContext

		The compiler is given CompileHandlers which handle compilation of commands

		RobotState:
			RobotState contains a map of Device -> DeviceState

		RobotKnowledge:

		Objects:
			Obj -- simple placeholder
			ObjConfigL3 -- mutable configuration data for an object
			ObjStateL3 -- state data about an object on the L3 level of abstraction
			ObjConfigL1 -- immutable L1 data about an object
			ObjStateL1 -- variables which may change over time
		Devices:
			Device
			DeviceStateL3
			DeviceStateL1
		
		When compiling a command, we may need the following context information:
			Compiler (if we need to compile additional commands and score the results)
			Devices
			DeviceStates/DeviceKnowledge
			locations of parts

		Construction of Compiler object:
			create devices we want
			create RobotState object
			add initial device states for all devices to RobotState
			--
			create CommandCompilers
			create Compiler
			register CommandCompilers with Compiler
			--
			create initial device knowledge for all devices

	Knowledge Base:
		parts carry almost no data (at most a string label and a numeric id)
		two forms of data:
			partially specified
			fully specified
		the data object for a given part is created by a factory function in order to allow the user to add new parts; or alternatively, handlers can be registered
		the conversion from partially specified info to fully specified is also taken care of by the handlers
	Compiling 2011-08-23:
		L4 preprocessing: Knowledgebase
			purpose: fill in unknown parameter values
		L4 -> L3: Obj, RobotState
			purpose: translate from unfixed to fixed commands
		L3 -> L2: ObjConfig, RobotState, compile
			purpose: break down into simpler commands
		L2 -> L1: ObjConfig, RobotState
			purpose: update state and create state-ignorant commands
		L1 -> L0: ObjConfig

		L4/L3: same commands, except L4 uses Obj parameters, and L3 uses ObjConfig parameters
		L3: high-level commands (with all parameters)
		L2: commands which update state; these could also be the commands that are used for scoring
		L2/L1: same commands, except that all useful state information is added to the L1 command
		L1: commands used for native translation (do not rely on state)
	Compiling:
		L3 -> L2: knowledgebase
		L2 -> L1: initial robot state
		L1 -> L0: nothing?
		given a set of L3 commands:
			find new defaults to add to kb
			concretize existing kb
			add knowledge from all nodes in tree
			for each command in top list
				compile
				abort on error
				otherwise add knowledge from all new nodes
				process each translated item in the same way
			if knowledge has been updated
				repeat process
		CompileNode
			cmd
			result
			children
	Alternative compiling levels:
		NEED TO SPLIT CONFIG AND STATE FOR OBJSETUP AGAIN IN ORDER TO KEEP TRACK OF STATE IN HIGHER LEVEL COMMANDS?  Maybe not, since commands which need state could possibly delay translation until L1 state is available...?
		compilation cycles:
			each compilation run produces a linear list of commands rather than a tree
			L3 command can either replace itself with a list of other L3 commands or translate L2 commands
				NOTE: this might be too restrictive.  How about letting L2 commands translate to a list of both L2 and L1 commands?
			steps:
				optionally replace L3 commands with other L3 commands
				add knowledge from L3 commands
				abort if knowledge is not complete
				translate each L3 command to L2 commands (use ObjConfig parameters instead of Obj) then to L1 commands, abort on first error
				
		processor hierarchy:
			challenges:
				I'd like to be able to compile the commands in a preliminary way without a specific robot implementation
				this might mean that we need two types of state objects: ObjState and RobotState
				we also want to run through a protocol to see how much liquid is aspirated from a source well in order to know what the initial volume
				this means that we need two runs, and only the second run produces errors when well volume goes below 0
				we could pass ObjState params instead of ObjConfig, but then we'd need to compile every command before adding a new one
	Pipetting:
		state should only be updated by the underlying robot/device implementation based on L1 commands
		createCycles can try dispensing until an invalid state is reached, then revert to the previous state and start the next cycle
		cycles:
			start with assumption that tips are clean
			get first tip/dest set and associate source liquid with tip
			get pipetting policy and liquid class for each dispense
			create L1 dispense command
			update tip liquid attributes for it's post-dispense state
			add volume dispensed to amount required for tip
			peek at next tip/dest set, and check whether:
				each tip can still access the same set of source wells
				each tip can accommodate the additional volume
				dispense does not require cleaning
	tip handling in Wash vs Dispose:
		fixed tips:
			do nothing, rinse, thorough wash, decontaminate, decontaminate with pre-rinse
		disposable tips:
			do nothing, replace (drop tip, wash syringe, get new tip), drop only
	L3C_Aspirate:
		parameters:
			tips, wells, volumes, policies
			clean degrees
			tip handling (tip type, action: none/new/force-replace)
		for disposable tips:
			if tip already present:
				if require different tip type || action == force-replace, force replacement
			else force-replacement
	Tip handling overrides:
		tip replacement action for each clean point
		tip wash action for each clean point
	Tip wash actions:
		cell | dna | other
		contamination levels: none, minor, major
		what about distinction between inside and outside?
		how to define a liquid so that we know what default tip handling actions to take for both disposable and permanent tips?
		contamination should be a map over an enumeration value so that additional contamination types can be easily added
	Wash programs:
		Later in development, I'd like for wash programs to target specific contaminants
		One challenge then would be how to keep new contaminants in sync with existing wash programs
		Maybe by having new contaminants subclass existing ones when appropriate

		decide on wash program based on the desired wash intensity and the contamination of the tips

		L3: must be implemented for a specific lab -- though I'd like to have a generic implementation based on our BSSE setup
		L2: same as for L1
		L1: wash program refers to a set of parameters for Evoware WASH
	Tip handling defaults:
	Clean:
		Clean overrides:
			//before first aspirate
			before each aspirate
			//before each aspirate of a new liquid
			//between dispenses
			after wet-contact dispense
			after last dispense

		Tip handling:
			none
			get new (drop if necessary,wash,get) [need type to get]
			drop only

		Clean & Tip handling:
			

		cleaning is flagged when tip enters the destination liquid
		cleaning is flagged when the tip will aspirate from a new liquid
		cleanBetween is normally CleanDegree.Rinse
		it will be CleanDegree.Decontaminate, however, if either the source or dest liquids require decontamination
		user can optionally override the cleanDegree

		distinguish between 1) clean if dirty and 2) forced preparatory clean
		only clean the tips we'll need
		the pre-clean instruction at the beginning of a pipetting action should clean all tips which will be used during the procedure
		the between-clean instruction should clean all tips which were previously used
		optimize clean instructions so that cleaning of a tip kind also cleans the tips of any clean instructions for that tip kind which come later, but only for clean instruction of the same degree
		optimize clean instructions which are right next to each other so that only one of them is performed
		At the T1 level: tips and degree should already be specified, meaning we need to get the degree information from the BsseRobot
	T0 tokens can have estimated times associated with them
TRANSFER_LOCATIONS
TRANSFER_SAMPLES
TRANSFER_WELLS
DIST_REAGENT
DIST_REAGENT2
UNITE_AND_TRANSFER
RUN
LOOP
ENDLOOP
DIST_WELL
PREPARE_MIX
PREPARE_LIST
MPDIST
MPCHECKER
MPREPLICATE
MPREPLICATE384
DILUTE_AND_REPLICATE384
DILPROG
PREPARE_MATRIX
DIST_COL2ROW
EQUAL_CONC
SERIAL_DILUTION
PLANNED_DILUTION
ELUTE_SAMPLES
SEQ_PURE
ADD_AND_TRANSFER
PCR_PURE
MP_MINIPREP
PG_PREPARE_STD
PG_PREPARE_SAMPLE
PLATE_TO_PCR
PCR_SCHEDULE
VACUUM
VACUUM_ON
VACUUM_OFF
MIX_WELLS
WAIT
PROMPT
GET_TIPS
DROP_TIPS
ROCHE_OPEN
ROCHE_CLOSE
ROCHE_RUN
RUN_PCR
PCR_RUN
PCR_OPEN
PCR_CLOSE
PCR_COVER
PCR_UNCOVER
RUN_PCR_OPEN
PCR_RUN_OPEN
PR_OPEN
PR_CLOSE
PR_WAIT
PR_RUN
PR_MEASURE
REMOTE
EXECUTE
READER_OPEN
READER_CLOSE
READER_MEASURE_OD
READER_MEASURE_GFP
READER_MEASURE
READER_SET_TEMP
INC_CLOSE
INC_STOP
INC_SHAKE
INC_TEMP
LINKER_POS
START_SCRIPT
EVOSUB
CSLGET
CSLPUT
CSLLOOP
CFGRUN
TRANSFER_OBJECT
SMS
SHAKER_START
SHAKE
SHAKER_STOP
MOVE_OBJECT
START_TIMER
WAIT_TIMER
MOVE_PLATE
EMAIL
SMS
LOGMIX
LOGLIST
LOGPLATE
CEPLATE
BIOPLATE
MULTINAPLATE
RCHPLATE
SEQPLATE
